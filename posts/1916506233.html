<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Android画面显示流程 | YounghBlog</title><meta name="author" content="Youngh"><meta name="copyright" content="Youngh"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文将会介绍从 App 画出一帧画面到这帧画面被传送到屏幕进行显示的整个过程。这其中会涉及到一些硬件的基础知识，但这些硬件并不是本文关注的重点，介绍它们主要是为了跟软件层面关联起来，以便对 Android 的显示流程形成一个完整的认知体系。 先来简单介绍一下本文所涉及的硬件以及内核层中的几个概念。  预备知识 ION：Android 流行的内存管理机制，处在内核空间。 DRM：Direct Ren"><meta property="og:type" content="article"><meta property="og:title" content="Android画面显示流程"><meta property="og:url" content="https://younghblog.gitee.io/posts/1916506233.html"><meta property="og:site_name" content="YounghBlog"><meta property="og:description" content="本文将会介绍从 App 画出一帧画面到这帧画面被传送到屏幕进行显示的整个过程。这其中会涉及到一些硬件的基础知识，但这些硬件并不是本文关注的重点，介绍它们主要是为了跟软件层面关联起来，以便对 Android 的显示流程形成一个完整的认知体系。 先来简单介绍一下本文所涉及的硬件以及内核层中的几个概念。  预备知识 ION：Android 流行的内存管理机制，处在内核空间。 DRM：Direct Ren"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img.gejiba.com/images/02444853758d96ea1ce979fcd95b7973.md.webp"><meta property="article:published_time" content="2022-10-08T15:44:58.000Z"><meta property="article:modified_time" content="2022-10-08T16:10:13.152Z"><meta property="article:author" content="Youngh"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img.gejiba.com/images/02444853758d96ea1ce979fcd95b7973.md.webp"><link rel="shortcut icon" href="https://cdn1.tianli0.top/gh/exploreMeta/cdn/img/logo/favicon.ico"><link rel="canonical" href="https://younghblog.gitee.io/posts/1916506233"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="stylesheet" href="https://jokerdig.com/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.0.0/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:300},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn1.tianli0.top/npm/flickr-justified-gallery@2/dist/fjGallery.min.js",css:"https://cdn1.tianli0.top/npm/flickr-justified-gallery@2/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Android画面显示流程",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-10-09 00:10:13"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){if(0!==a){a*=864e5,t={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(t))}},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=e=>new Promise((t,a)=>{const o=document.createElement("script");o.src=e,o.async=!0,o.onerror=a,o.onload=o.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(o.onload=o.onreadystatechange=null,t())},document.head.appendChild(o)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")},"dark"===(e=saveToLocal.get("theme"))?activateDarkMode():"light"===e&&activateLightMode(),void 0!==(e=saveToLocal.get("aside-status"))&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside")),/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/exploreMeta/cdn/css/index.min.css"><link rel="stylesheet" href="https://jokerdig.com/css/index.css"><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/exploreMeta/cdn/css/haa.css"><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/rss2.xml" title="YounghBlog" type="application/rss+xml"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/3cb1dc95c490420f129fb73888c41e12.md.webp" onerror='onerror=null,src="https://img.gejiba.com/images/4f60b4e053a96873d937752732c06a09.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://img.gejiba.com/images/02444853758d96ea1ce979fcd95b7973.md.webp)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">YounghBlog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Android画面显示流程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-08T15:44:58.000Z" title="发表于 2022-10-08 23:44:58">2022-10-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-08T16:10:13.152Z" title="更新于 2022-10-09 00:10:13">2022-10-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Android%E5%9F%BA%E7%A1%80/">Android基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>53分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>本文将会介绍从 App 画出一帧画面到这帧画面被传送到屏幕进行显示的整个过程。这其中会涉及到一些硬件的基础知识，但这些硬件并不是本文关注的重点，介绍它们主要是为了跟软件层面关联起来，以便对 Android 的显示流程形成一个完整的认知体系。</p><p>先来简单介绍一下本文所涉及的硬件以及内核层中的几个概念。</p><h2 id="预备知识"><a class="markdownIt-Anchor" href="#预备知识"></a> 预备知识</h2><p><strong>ION</strong>：Android 流行的内存管理机制，处在内核空间。</p><p><strong>DRM</strong>：Direct Rendering Manager，直接渲染管理器，也在内核空间。提供了一组 API，用户空间程序可以通过它发送画面数据到 GPU，也可以使用它执行诸如配置分辨率、刷新率之类的设置操作。目前在高通平台手机 Android 系统上的显示系统也是使用的这组 API 来完成画面的渲染更新。</p><p>一个典型的 Android 显示系统一般包括以下三个部分：</p><ul><li><strong>SOC</strong>：负责绘画与多图层的合成，把合成好的数据传输给 DDIC。</li><li><strong>DDIC</strong>：负责把 Buffer 里的数据写到 <strong>GRAM</strong>（显示存储器）中。</li><li><strong>Panel</strong>：不断扫描 GRAM 以显示内容。</li></ul><h2 id="用户空间的帧数据流"><a class="markdownIt-Anchor" href="#用户空间的帧数据流"></a> 用户空间的帧数据流</h2><p>应用要绘制一个画面，首先要向 SurfaceFlinger（SF）申请一个画布，这个画布所使用的 Buffer 是 SF 通过 allocator service 分配的。allocator service 通过 ION 从内核中开辟一块内存出来作为共享内存，被 HWC Service 共享。其中每个图层都会申请一个独立的 Buffer，并由 SF 来控制这块 Buffer 的所有权，随着状态的不同，所有权会在 App、SF、HWC Service 之间流转。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/c3ccd4dc0cc97fcea3e377b7f6bf0301.webp" alt=""></p><p>HWC Service 会通过 DRM 与内核打交道，负责把 SF 传过来的图层进行合成，并将合成后的画面提交到 DRM 去显示。</p><p><strong>1. App到SurfaceFlinger</strong></p><p>应用首先通过 Surface 的接口向 SurfaceFlinger 申请一块 Buffer。需要说明的是，Surface 刚创建的时候是不会分配 Buffer 的，只有应用第一次绘画时调用 dequeueBuffer 才会让 SF 去申请 Buffer，然后在应用侧通过 importBuffer 把这块内存映射到应用的进程空间。</p><p>之后应用通过 dequeueBuffer 拿到画布，绘制好后再通过 queueBuffer 向 SF 提交数据。这个提交操作并不是把内存复制一份给 SF，而是把共享内存的控制权交还给 SF，SF 再把拿来的多个应用的共享内存送给 HWC 去合成。</p><p><strong>2. SurfaceFlinger到HWC</strong></p><p>HWC Service 负责将 SF 送来的图层做合成，形成最终的画面，然后通过 DRM 更新到屏幕上去。</p><p><strong>3. HWC到内核</strong></p><p>HWC Service 使用 libdrm 向 DRM 提交合成后的帧数据，最终调用的是 <code>drmModeAtomicCommit()</code> 接口，该接口又会通过系统函数 <code>ioctl()</code> 调用到内核去处理这些数据，完成 App 画面显示到屏幕的过程。</p><p>为了更有效地利用时间，这样的共享内存不止一份，因此就需要设计一个机制来管理这些 Buffer，这就是 BufferQueue。</p><h2 id="bufferqueue"><a class="markdownIt-Anchor" href="#bufferqueue"></a> BufferQueue</h2><p>BufferQueue 要解决的是生产者和消费者的同步问题：App 生产画面，SF 消费画面；SF 生产画面，HWC 消费画面。用来存储这些画面的存储区是 FrameBuffer，下面我们以 App 为生产者，SF 为消费者为例来了解一下 BufferQueue 的内部设计。</p><h3 id="bufferstate的切换"><a class="markdownIt-Anchor" href="#bufferstate的切换"></a> BufferState的切换</h3><p>在 BufferQueue 的设计中，一个 Buffer 的状态有以下几种：</p><p><strong>FREE</strong>：表示该 Buffer 可以被生产者 dequeue，此时 BufferSlot 的拥有者是 BufferQueue。当被 dequeue 之后它的状态会变成 DEQUEUED。</p><p><strong>DEQUEUED</strong>：表示该 Buffer 已经被生产者 dequeue，但还没有被 queue 或者 cancle，此时 BufferSlot 的拥有者是生产者。当被 queue 之后其状态会变为 QUEUED，或者被 cancle 之后会变为 FREE。</p><p><strong>QUEUED</strong>：表示该 Buffer 已经被生产者填充并且被 queue 到了 BufferQueue 中，此时 BufferSlot 的拥有者是 BufferQueue。当被 acquire 之后其状态会变为 ACQUIRED。</p><p><strong>ACQUIRED</strong>：表示该 Buffer 已经被消费者 acquire，此时 BufferSlot 的拥有者是消费者。当被 release 之后其状态会变为 FREE。</p><p><strong>SHARED</strong>：表示该 Buffer 正在共享模式中被使用。它可以同时处于除 FREE 外的任意状态的组合，也可以多次被 dequeue、queue 或者 acquire。</p><p>这里多次提到了 BufferSlot，那它究竟是什么呢？</p><h3 id="bufferslot"><a class="markdownIt-Anchor" href="#bufferslot"></a> BufferSlot</h3><p>每一个 App 的图层在 SF 里称为一个 Layer，而每个 Layer 都拥有一个独立的 BufferQueue，每个 BufferQueue 都有多个 Buffer。Android 系统上目前支持每个 Layer 最多 64 个 Buffer，每个 Buffer 用一个结构体 BufferSlot 来表示。</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/ffb559c74f0033cd5147341cd6f7f392.webp" alt="image-20220925171857831" style="zoom:50%"><p>BufferSlot 中的一些重要成员如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/include/gui/BufferSlot.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BufferSlot</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    sp&lt;GraphicBuffer&gt; mGraphicBuffer; <span class="comment">// 指向为这个Slot分配的Buffer</span></span><br><span class="line">    BufferState mBufferState; <span class="comment">// BufferSlot的当前状态</span></span><br><span class="line">    <span class="type">uint64_t</span> mFrameNumber; <span class="comment">// 被queue的帧的编号，在按LRU顺序dequeue申请Buffer时会使用</span></span><br><span class="line">    sp&lt;Fence&gt; mFence; <span class="comment">// 后面再分析</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于这 64 个 BufferSlot，其分类如下：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/d1b729b9f16996eb1b54626cf918c6cf.webp" alt="image-20220925173700870"></p><p>处于 FREE状态的 Slot 根据是否已经为其分配过内存，可以分成两部分，如图所示。所以如果我们在代码中看到是从 mFreeSlots 里拿出一个 BufferSlot，那就说明这个 BufferSlot 还没有分配 GraphicBuffer，可能是第一次被使用到。</p><h3 id="bufferqueue构造"><a class="markdownIt-Anchor" href="#bufferqueue构造"></a> BufferQueue构造</h3><p>BufferQueue 的创建方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/BufferQueue.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BufferQueue::createBufferQueue</span><span class="params">(sp&lt;IGraphicBufferProducer&gt;* outProducer, sp&lt;IGraphicBufferConsumer&gt;* outConsumer, <span class="type">bool</span> consumerIsSurfaceFlinger)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">sp&lt;BufferQueueCore&gt; <span class="title">core</span><span class="params">(<span class="keyword">new</span> BufferQueueCore())</span></span>;</span><br><span class="line">    <span class="function">sp&lt;IGraphicBufferProducer&gt; <span class="title">producer</span><span class="params">(<span class="keyword">new</span> BufferQueueProducer(core, consumerIsSurfaceFlinger))</span></span>;</span><br><span class="line">    <span class="function">sp&lt;IGraphicBufferConsumer&gt; <span class="title">consumer</span><span class="params">(<span class="keyword">new</span> BufferQueueConsumer(core))</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法会先创建 BufferQueueCore，然后再使用它分别去创建生产者 BufferQueueProducer 和消费者 BufferQueueConsumer。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/include/gui/BufferQueueCore.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferQueueCore</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase &#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">BufferQueueProducer</span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">BufferQueueConsumer</span>;  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// mSlots是一个BufferSlot数组，允许GraphicBuffer所有权在生产者和消费者之间不通过Binder转移</span></span><br><span class="line">    BufferQueueDefs::SlotsType mSlots;</span><br><span class="line">    <span class="comment">// mMaxDequeuedBufferCount是生产者一次可以dequeue的Buffer数</span></span><br><span class="line">    <span class="comment">// 默认为1，生产者可以通过setMaxDequeuedBufferCount()函数修改默认值</span></span><br><span class="line">    <span class="type">int</span> mMaxDequeuedBufferCount;</span><br><span class="line">    <span class="comment">// mQueue是一个用于同步模式的先进先出的Buffer队列</span></span><br><span class="line">    Fifo mQueue;  </span><br><span class="line">    <span class="comment">// mFreeSlots包含所有FREE且还没有分配Buffer的Slot</span></span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mFreeSlots;</span><br><span class="line">    <span class="comment">// mFreeBuffers包含所有FREE且已分配Buffer的Slot</span></span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; mFreeBuffers;</span><br><span class="line">    <span class="comment">// mUnusedSlots包含所有当前未使用的Slot，它们应该FREE且未分配Buffer</span></span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; mUnusedSlots;</span><br><span class="line">    <span class="comment">// mActiveBuffers包含所有非FREE状态的Slot</span></span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mActiveBuffers;  </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看一下<strong>应用上帧</strong>（应用提交绘制好的帧数据到 SF）时 SF 是如何管理分配这些 Slot 的。</p><h3 id="应用获取graphicbuffer"><a class="markdownIt-Anchor" href="#应用获取graphicbuffer"></a> 应用获取GraphicBuffer</h3><p>应用第一次 dequeueBuffer 前会通过 <code>connect()</code> 接口和 SurfaceFlinger 建立连接。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/Surface.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Surface::connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> api, <span class="type">const</span> sp&lt;IProducerListener&gt;&amp; listener, <span class="type">bool</span> reportBufferRemoval)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>(); <span class="comment">// 可以在systrace中看到</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 这里通过Binder调用和SurfaceFlinger建立连接</span></span><br><span class="line">    <span class="type">int</span> err = mGraphicBufferProducer-&gt;<span class="built_in">connect</span>(listener, api, mProducerControlledByApp, &amp;output);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用在第一次 <code>dequeueBuffer()</code> 时会调用 <code>requestBuffer()</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/Surface.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Surface::dequeueBuffer</span><span class="params">(<span class="type">android_native_buffer_t</span>** buffer, <span class="type">int</span>* fenceFd)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>(); <span class="comment">// 可以在systrace中看到</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 这里尝试去dequeueBuffer，但因为第一次SF中对应Layer的Slot还没有分配Buffer</span></span><br><span class="line">    <span class="comment">// 所以SF回复的flag会带有BUFFER_NEEDS_REALLOCATION标识</span></span><br><span class="line">    <span class="type">status_t</span> result = mGraphicBufferProducer-&gt;<span class="built_in">dequeueBuffer</span>(&amp;buf, &amp;fence, dqInput.width, dqInput.height, dqInput.format, dqInput.usage, &amp;mBufferAge, dqInput.getTimestamps ? &amp;frameTimestamps : <span class="literal">nullptr</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ((result &amp; IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) || gbuf == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        result = mGraphicBufferProducer-&gt;<span class="built_in">requestBuffer</span>(buf, &amp;gbuf);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"> ...</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在 SF 端，第一次收到 <code>dequeueBuffer()</code> 时发现分配出来的 Slot 没有 GraphicBuffer，这时会去申请对应的 Buffer：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/BufferQueueProducer.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BufferQueueProducer::dequeueBuffer</span><span class="params">(<span class="type">int</span>* outSlot, sp&lt;android::Fence&gt;* outFence, <span class="type">uint32_t</span> width, <span class="type">uint32_t</span> height, PixelFormat format, <span class="type">uint64_t</span> usage, <span class="type">uint64_t</span>* outBufferAge, FrameEventHistoryDelta* outTimestamps)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ((buffer == <span class="literal">nullptr</span>) ||</span><br><span class="line">        buffer-&gt;<span class="built_in">needsReallocation</span>(width, height, format, BQ_LAYER_COUNT, usage)) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 发现需要分配Buffer，做个标记</span></span><br><span class="line">        returnFlags |= BUFFER_NEEDS_REALLOCATION;</span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (returnFlags &amp; BUFFER_NEEDS_REALLOCATION) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// new一个GraphicBuffer</span></span><br><span class="line">        sp&lt;GraphicBuffer&gt; graphicBuffer = <span class="keyword">new</span> <span class="built_in">GraphicBuffer</span>(width, height, format, BQ_LAYER_COUNT, usage, &#123;mConsumerName.<span class="built_in">string</span>(), mConsumerName.<span class="built_in">size</span>()&#125;);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 将新创建的GraphicBuffer给到对应的Slot</span></span><br><span class="line">        mSlots[*outSlot].mGraphicBuffer = graphicBuffer;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 此时返回给应用的flags仍然带有BUFFER_NEEDS_REALLOCATION标记</span></span><br><span class="line">    <span class="keyword">return</span> returnFlags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用侧收到带有 <code>BUFFER_NEEDS_REALLOCATION</code> 标记的返回结果后，会调用 <code>requestBuffer()</code> 来获取对应 Buffer 的信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/BufferQueueProducer.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BufferQueueProducer::requestBuffer</span><span class="params">(<span class="type">int</span> slot, sp&lt;GraphicBuffer&gt;* buf)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mSlots[slot].mRequestBufferCalled = <span class="literal">true</span>;</span><br><span class="line">    *buf = mSlots[slot].mGraphicBuffer;</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的主要用作就是把 GraphicBuffer 传递到应用侧。</p><p>这里思考一个问题：既然 SF 在响应 <code>dequeueBuffer()</code> 时就已经为 Slot 创建了 GraphicBuffer，为什么还需要应用侧再次调用 <code>requestBuffer()</code> 时才会把 GraphicBuffer 传给应用？ 为什么 <code>dequeueBuffer()</code> 不直接返回呢？</p><p>要回答这个问题，我们需要看下应用侧接口 <code>dequeueBuffer()</code> 函数的设计：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/include/gui/IGraphicBufferProducer.h</span></span><br><span class="line">virtual <span class="type">status_t</span> <span class="title function_">dequeueBuffer</span><span class="params">(<span class="type">int</span>* slot, sp&lt;Fence&gt;* fence, <span class="type">uint32_t</span> w, <span class="type">uint32_t</span> h, PixelFormat format, <span class="type">uint64_t</span> usage, <span class="type">uint64_t</span>* outBufferAge, FrameEventHistoryDelta* outTimestamps)</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>注意第一个参数只是返回一个 int 指针，它表示的是 64 个 Slot 里的某一个 Slot，并不对应为其分配的 GraphicBuffer 信息，并且其他参数里也不会返回这个 Slot 所对应的 GraphicBuffer 的信息。但在应用侧拿到这个 Slot 之后，还需拿到确确实实的 GraphicBuffer 才能把共享内存 mmap 到自已的进程空间，才能在上面绘画，而显然这个接口的设计并不会带来 GraphicBuffer 的信息。</p><p>那设计之初为什么不把这个信息放进来呢？ 因为这个接口调用太频繁了，比如在 90 fps 的设备上，一秒钟该接口要执行 90 次，但这个信息只需要传递一次就可以了，如果每次这个接口都要带上 GraphicBuffer 的信息，就会传输很多冗余的数据，所以不如加入一个新的 API，即 <code>requestBuffer()</code> 来完成 GraphicBuffer 传递的事情。</p><p>应用侧在 <code>requestBuffer()</code> 后会拿到 GraphicBuffer 的信息，然后会通过 <code>importBuffer()</code> 在本进程内通过 Binder 传过来的 Parcel 包把 GraphicBuffer 重建出来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/ui/GraphicBuffer.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">GraphicBuffer::unflatten</span><span class="params">(<span class="type">void</span> <span class="type">const</span>*&amp; buffer, <span class="type">size_t</span>&amp; size, <span class="type">int</span> <span class="type">const</span>*&amp; fds,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">size_t</span>&amp; count)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取从SurfaceFlinger传过来的Buffer</span></span><br><span class="line">    <span class="type">status_t</span> err = mBufferMapper.<span class="built_in">importBuffer</span>(handle, <span class="built_in">uint32_t</span>(width), <span class="built_in">uint32_t</span>(height), <span class="built_in">uint32_t</span>(layerCount), format, usage, <span class="built_in">uint32_t</span>(stride), &amp;importedHandle);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="buffer管理"><a class="markdownIt-Anchor" href="#buffer管理"></a> Buffer管理</h3><p><a href="#BufferSlot">前面</a> 提到了每个 Layer 都有最多 64 个 BufferSlot，但不是每个 Layer 都能用到这么多。每个 Layer 最多可用多少个 Buffer 是在这里设置的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/BufferQueueLayer.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BufferQueueLayer::onFirstRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// BufferQueueCore::mMaxDequeuedBufferCount默认是1</span></span><br><span class="line">    <span class="comment">// 当这里设为2时表示生产者一次可以dequeue的Buffer数为3，因为在BufferQueueCore那里会+1</span></span><br><span class="line">    mProducer-&gt;<span class="built_in">setMaxDequeuedBufferCount</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 App 侧看，前三帧都会有 requestBuffer 和 importBuffer，在第四帧时就没有了，因为我们当前系统一共使用了 3 个 Buffer。也就是说，应用所使用的画布是在前三帧被分配出来的，从第四帧开始进入稳定上帧期，这时会重复循环利用前三次分配的 Buffer。</p><p>看一下 BufferSlot 管理的场景：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/b3cdbe68645fb6318967137011253082.webp" alt=""></p><p><strong>Time 1</strong>：如图所示，初始状态下有 0、1、2 三个 BufferSlot，由于它们没有分配过 GraphicBuffer，所以都在 mFreeSlots 列表中。当应用 dequeueBuffer 时，SF 会先检查在 mFreeBuffers 队列中是否有 Slot，如果有则直接分配给应用。而显然此时 mFreeBuffers 是空的，这时 SF 会去 mFreeSlots 里找出第一个 Slot，也就是 0 号 Slot，所以在 dequeueBuffer 结束时应用就拿到了 0 号 Slot 的使用权，于此同时 SF 也会为 0 号 Slot 分配 GraphicBuffer，之后应用将通过 requestBuffer 和 importBuffer 来获取到该 Slot 的实际内存空间。</p><p>应用 dequeueBuffer 之后 0 号 Slot 切换到 DEQUEUED 状态，并被放入 mActiveBuffers 列表。</p><p><strong>Time 2</strong>：应用完成绘制后通过 queueBuffer 来提交绘制好的画面，完成后 0 号 Slot 状态变为 QUEUED 状态，（从 mActiveBuffers 取出）放入 mQueue 队列，此时 1、2 号 Slot 还停留在 mFreeSlots 队列中。（**图中每个 Time 中每种颜色的 Buffer 都只会有一个！**这里有两个 0 号 Buffer 只是将两步合并了）</p><p><strong>Time 3</strong>：上面这个状态会一直持续到下一个 Vsync-sf 信号到来。当 Vsync-sf 信号到来时，SF 主线程会检查 mQueue 队列中是否有 Slot，有就意味着有应用上帧。这时它会通过 acquireBuffer 把该 Slot（0 号 Slot）从 mQueue 中取出放入 mActiveBuffers 中，并将 Slot 的状态切换到 ACQUIRED，代表这个 Slot 已经被拿去做画面合成。</p><p><strong>Time 4</strong>：接下来应用继续调用 dequeueBuffer 申请 buffer，此时 0 号 Slot 在 mActiveBuffers 里，1、2 号在 mFreeSlots 里，SF 仍然是先检查 mFreeBuffers 里有没有 Slot，再检查 mFreeSlots，于是取出了 1 号 Slot 给到应用侧，同时 1 号 Slot 状态切换到 DEQUEUED 状态， 放入 mActiveBuffers 里。</p><p><strong>Time 5</strong>：1 号 Slot 应用绘画完毕，通过 queueBuffer 提交上来，这时 1 号 Slot 状态由 DEQUEUED 状态切换到了 QUEUED 状态，进入 mQueue 队列，之后将维持该状态直到下一个 Vsync-sf 信号到来。</p><p><strong>Time 6</strong>：此时 Vsync-sf 信号到来，发现 mQueue 中有个 Slot 1，这时 SF 主线程会把它取出，然后把状态切换到 ACQUIRED，并放入 mActiveBuffers 里。</p><p><strong>Time 7</strong>：这时 0 号 Slot 已经被 HWC Service 使用完毕，通过 releaseBuffer 还了回来，0 号 Slot 的状态将从 ACQUIRED 切换回 FREE，SF 会把它从 mActivieBuffers 里拿出来放入 mFreeBuffers 里。注意这时放入的是 mFreeBuffers 而不是 mFreeSlots ，因为此时 0 号 Slot 是有 GraphicBuffer 的。</p><p>在上述过程中，SF 收到应用 dequeueBuffer 请求时处在 FREE 状态的 Slot 都还没有分配过 GraphicBuffer。这通常发生在一个 Surface 的前几帧时间内，如在三个 Buffer 时的前三帧。之后的 mFreeBuffers 里已经有了 Slot，继续看下此时申请 Buffer 的情况：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/6563fdf526783a7007d9fc10e53d52ff.webp" alt=""></p><p><strong>Time 11</strong>：当下的状态是 0、1 两个 Slot 都在 mFreeBuffers 中，2 号 Slot 在 mActiveBuffers 中，这时应用过来 dequeueBuffer。</p><p><strong>Time 12</strong>：SF 仍然会先查看 mFreeBuffers，发现 0 号可用，于是该 Slot 的状态由 FREE 切换到 DEQUEUED 状态，并被放入 mActiveBuffers 中。</p><p><strong>Time 13</strong>：应用对 0 号 Slot 的绘图完成后通过 queueBuffer 提交绘制好的画面，这时状态从 DEQUEUED 切换到 QUEUED，0 号 Slot 被放入 mQueue 队列中，之后会维持该状态直到下一个 Vsync-sf 信号到来。</p><p><strong>Time 14</strong>：这时 Vsync-sf 信号到来，SF 主线程中检查 mQueue 队列中是否有 Slot，发现有 0 号 Slot，于是放入 mActiveBuffers 中，并通过 aquireBuffer 将其状态切换到 ACQUIRED，代表这个 Slot 已经被拿去做画面合成。</p><p>这个过程中应用申请 Buffer 时已经有处于 FREE 状态的 Slot 是分配过 GraphicBuffer 的，这种情况多发生在 Surface 的稳定上帧期。</p><p>再来关注一下 acquireBuffer 和 releaseBuffer 的过程：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/e1509e9dd23678529a6b08491f41723f.webp" alt=""></p><p><strong>Time 23</strong>：当前 mQueue 中有两个 Buffer。</p><p><strong>Time 24</strong>：Vsync-sf 信号到达，SF 通过 acquireBuffer 从 mQueue 队列取走 0 号 Slot。</p><p><strong>Time 25</strong>：再一次 Vsync-sf 到来，这时 SF 会先查看 mQueue 中是否有 Buffer，发现有 2 号 Slot，于是通过 acquireBuffer 取走 2 号 Slot。</p><p><strong>Time 26</strong>：此时 0 号 Slot 已经被 HWC Service 使用完毕，通过 releaseBuffer 把 Slot 还了回来，0 号 Slot 在此刻进入 mFreeBuffers。</p><p>这里需要注意两个时序：</p><ul><li><strong>每次 Vsync-sf 信号到来时总是先查看 mQueue 队列看是否有 Layer 上帧，然后才会走到 releaseBuffer 把 HWC Service 使用完的 Slot 回收回来。</strong></li><li><strong>本次 Vsync-sf 被 aquireBuffer 取走的 Slot 总是会在下一个 Vsync-sf 时才会被 release 回来。</strong></li></ul><p>由上述过程不难看出，如果应用上帧速度较慢，比如其上帧周期时长大于两倍屏幕刷新周期时，每次应用来 dequeueBuffer 时前一次 queueBuffer 的 BufferSlot 都已经被 release 回来了，这时总会在 mFreeBuffers 里找到可用的，那么就不需要三个 Slot 都分配出 GraphicBuffer。</p><p>releaseBuffer 是在 postComposition 里调用的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::postComposition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; layer: mLayersWithQueuedFrames) &#123;</span><br><span class="line">        ...</span><br><span class="line">        layer-&gt;<span class="built_in">releasePendingBuffer</span>(<span class="comment">/*dequeueReadyTime*/</span> now);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要主线程执行到这个 <code>postComposition()</code> 函数就一定会让集合中的 layer 去执行 <code>releasePendingBuffer()</code>，该函数会调用到 <code>releaseBuffer()</code>。</p><p>mLayersWithQueuedFrames 里的 Layer 是在这里被加入进来的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SurfaceFlinger::latchBuffers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mDrawingState.<span class="built_in">traverse</span>([&amp;](Layer* layer) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;<span class="built_in">hasReadyFrame</span>()) &#123;</span><br><span class="line">            ...</span><br><span class="line">            mLayersWithQueuedFrames.<span class="built_in">emplace</span>(layer);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Layer 的 <code>releasePendingBuffer()</code> 里会把对应的 Slot 的状态切换为 FREE，之后该 Slot 是很可能被应用通过 <code>dequeueBuffer()</code> 获取到的。那么怎么能确定 Buffer 已经被 HWC Service 使用完了呢？如果 HWC Service 还没使用完，而应用却申请到了这个 Buffer，那 Buffer 中的数据极有可能会出错。该怎么解决这个问题呢？这就要靠 Fence 了，这个我们稍后再来介绍。</p><p>我们再从帧数据更新的流程上来看下 BufferSlot 的管理，从 Systrace（屏幕刷新率为 90 Hz）上可以观察到的应用上帧的全景图：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/2c9a66e0ffc67b0447374b9c799ade34.webp" alt=""></p><p>这里是以一个 SurfaceView（自主）上帧为例：</p><ul><li><p>首先应用通过 dequeueBuffer 拿到了 BufferSlot 0，开始第 1 步绘图；</p></li><li><p>绘图完成后通过 queueBuffer 将 Slot 0 提交到 SF，下一个 Vsync-sf 信号到达后，开始第 2 步图层处理；</p></li><li><p>这时 SF 通过 aquireBuffer 把 Slot 0 拿去给到 HWC Service，与此同时进入第 3 步；</p></li><li><p>HWC Service 开始对多个图层做合成，合成后通知 DRM 模块传输给 DDIC，Panel 再把图像显示到屏幕。</p></li></ul><h3 id="代码接口"><a class="markdownIt-Anchor" href="#代码接口"></a> 代码接口</h3><p>以 App 为生产者、SF 为消费者为例，BufferQueue 的 Slot 管理核心代码由 BufferQueueCore、BufferQueueProducer 和 BufferQueueConsumer 组成。生产者这边还有一个 Surface，它是应用侧操作 BufferQueue 的接口。Android 规定，BufferQueue 的 Buffer 必须在 Consumer 侧分配，因此 BufferQueue 的核心 Slot 管理代码是在 SF 进程中执行的。它们之间的关系如下：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/825eebf6745858ef87f844d2bc696828.webp" alt=""></p><p>IGraphicBufferProducer 规定了 BufferQueue 向生产者提供的接口有哪些，比如请求 Buffer 用到的 dequeueBuffer、提交 Buffer 用到的 queueBuffer 等等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/include/gui/IGraphicBufferProducer.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IGraphicBufferProducer</span> : <span class="keyword">public</span> IInterface &#123;</span><br><span class="line">    <span class="comment">// connect会将客户端API与IGraphicBufferProducer建立连接</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">connect</span><span class="params">(<span class="type">const</span> sp&lt;IProducerListener&gt;&amp; listener, <span class="type">int</span> api, <span class="type">bool</span> producerControlledByApp, QueueBufferOutput* output)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">requestBuffer</span><span class="params">(<span class="type">int</span> slot, sp&lt;GraphicBuffer&gt;* buf)</span> </span>= <span class="number">0</span>; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">dequeueBuffer</span><span class="params">(<span class="type">int</span>* slot, sp&lt;Fence&gt;* fence, <span class="type">uint32_t</span> w, <span class="type">uint32_t</span> h, PixelFormat format, <span class="type">uint64_t</span> usage, <span class="type">uint64_t</span>* outBufferAge, FrameEventHistoryDelta* outTimestamps)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">queueBuffer</span><span class="params">(<span class="type">int</span> slot, <span class="type">const</span> QueueBufferInput&amp; input, QueueBufferOutput* output)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// disconnect会断开客户端API与IGraphicBufferProducer的连接</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">disconnect</span><span class="params">(<span class="type">int</span> api, DisconnectMode mode = DisconnectMode::Api)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>connect()</code> 接口在开始上帧前调用一次，主要用来让生产者和消费者沟通一些参数，比如 API 版本、Buffer 的大小和个数等。</p><p><code>disconnect()</code> 用于在生产者不再生产时断开连接，以通知消费端清理一些资源。</p><p>IGraphicBufferConsumer 则规定了 BufferQueue 向消费者提供的接口有哪些，比如从 mQueue 队列中取出 Buffer、归还 Buffer 到 BufferQueue 等等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/include/gui/IGraphicBufferConsumer.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IGraphicBufferConsumer</span> : <span class="keyword">public</span> IInterface &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">acquireBuffer</span><span class="params">(BufferItem* buffer, <span class="type">nsecs_t</span> presentWhen, <span class="type">uint64_t</span> maxFrameNumber = <span class="number">0</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">releaseBuffer</span><span class="params">(<span class="type">int</span> buf, <span class="type">uint64_t</span> frameNumber, EGLDisplay display, EGLSyncKHR fence, <span class="type">const</span> sp&lt;Fence&gt;&amp; releaseFence)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3><p>用一张图来总结一下在 Triple Buffer 下应用连续上帧过程中三个 Buffer 的使用情况，以及在此过程中应用和 SF 是如何配合的：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/e2e2adf29bd3187d48bf4c994014188e.webp" alt=""></p><p>应用在每个 Vsync 信号到来后都会通过 dequeueBuffer/queueBuffer 来申请 Buffer 和提交绘图数据；</p><p>SF 会在 Vsync 信号到来时取走 Buffer 去做合成和显示， 并在下一个 Vsync 到来时归还 Buffer。如此循环。</p><h2 id="fence"><a class="markdownIt-Anchor" href="#fence"></a> Fence</h2><p>Fence 是内核提供的不同硬件之间的同步机制，在用户空间我们可以将它视为一把锁，它代表了某个硬件对共享资源的占用情况。</p><h3 id="为什么要有fence"><a class="markdownIt-Anchor" href="#为什么要有fence"></a> 为什么要有Fence</h3><p>一般凡是共享的资源都要建立一个同步机制来管理。比如在多线程编程中对临界资源通过加锁实现互斥访问，BufferQueue 中 SF 和应用对共享内存（帧缓冲）的访问中有 BufferState 来标识共享内存控制权的方法来做同步。没有同步机制的无序访问极可能造成数据混乱。</p><p>BufferState 的方式只是解决了在 CPU 管理之下，当下共享内存的控制权归属问题。当共享资源是在两个硬件中时，情况就不同了。比如当一个帧缓冲区共享内存给到 GPU 时，GPU 并不清楚 CPU 还有没有在使用它；同样地，当 GPU 在使用共享内存时，CPU 也不清楚 GPU 是否已使用完毕。</p><blockquote><p>以 CPU 调用 OpenGL 函数进行绘图为例：首先 CPU 侧调用 <code>glClear()</code> 清空画布，再调用 <code>glXXX()</code> 绘制各种画面。对于 CPU 来说，在 <code>glXXX()</code> 执行完毕后，它的绘图工作已经完成了，但其实 <code>glXXX()</code> 的具体工作是由 GPU 来完成的，CPU 侧的 <code>glXXX()</code> 只是在向 GPU 传达任务而已。任务传达完并不意味着任务已经完成了，真正的任务完成是要等 GPU 做完 <code>glXXX()</code> 所对应的工作。</p><p>从 CPU 下达完任务到 GPU 完成任务之间存在时差，这个时差受 GPU 工作频率的影响，并且不是一个定值。在 OpenGL 的语境中，CPU 可以通过 <code>glFilish()</code> 来等待 GPU 完成所有工作，但这显然浪费了 CPU 本可以并行工作的时间。</p><p>在本例中，CPU 下达了要在画布上绘画的指令给 GPU，而 GPU 什么时候画完是不确定的。这里的画布就是共享资源，CPU 和 GPU 的工作完全是异步的。Fence 提供了一种方式来处理不同硬件对共享资源的访问控制。</p></blockquote><p>我们可以这样理解 Fence 的工作原理：</p><p>Fence 是一个内核 Driver，对一个 Fence 对象的操作有两种：signal 和 wait。当生产者（App）向 GPU 下达完很多绘图指令后 GPU 开始工作，这时 CPU 就认为绘图工作已经完成了。之后把创建的 Fence 对象通过 Binder 通知给消费者（SF）。消费者收到通知后，并不知道 GPU 是否已经绘图完毕，即 GPU 是否已对共享资源访问完毕，于是先通过 Fence 对象的 wait 方法等待，直到 GPU 绘图完成后调用 Fence 的 signal 方法， 才会从 wait 中跳出。这个 signal 是由内核 Driver 来完成的。有了 Fence 的情况下，CPU 在完成自已的工作后就可以继续做其他事情，到了真正要使用共享资源时再通过 Fence wait 来和 GPU 同步，尽最大可能做到了让不同硬件并行工作。</p><h3 id="与bufferqueue的协作方式"><a class="markdownIt-Anchor" href="#与bufferqueue的协作方式"></a> 与BufferQueue的协作方式</h3><p>以 App（生产者）和 SF（消费者）间的交互来看下 Fence 在其中的作用：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/2e4f2033e4b51e2d94ba75fdbe1f3ae2.webp" alt=""></p><p>首先 App 通过 dequeueBuffer 获得某一 Slot 的使用权，这时 Slot 的状态切换为 DEQUEUED。随着 dequeueBuffer 返回的还有一个 releaseFence 对象，此时 releaseFence 还没有 signal， 这意味着虽然在 CPU 这边已经拿到了 Buffer 的使用权，但别的硬件还在使用这个 Buffer。因此 GPU 还不能直接在上面绘画，它要等 releaseFence 收到 signal 信号后才可以绘画。</p><p>releaseFence 收到 signal 信号之后，我们假设 GPU 工作时间较长，在它完成之前 CPU 侧 APP 已经完成了 queueBuffer 动作，这时 Slot 的状态已切换为 QUEUED，并且下一个 vsync 已经到来，Slot 状态变为 ACQUIRED。这在 CPU 侧代表该 Buffer 给 HWC 去合成了，但这时 HWC 还不能去读里面的数据，它还需要等待 acauireFence 的 signal 信号，只有等到该信号才代表 GPU 的绘画工作真正做完了。</p><p>acauireFence 收到 signal 信号之后，HWC 就可以去读帧缓冲区的数据，完成图层的合成工作。</p><p>同样地，当 SF 执行到 releaseBuffer 时，并不能代表 HWC 已经完成合成工作了，但这不妨碍 releaseBuffer 流程继续执行。虽然 HWC 还在使用缓冲区做合成，但帧缓冲区的 Slot 有可能已经被应用申请走变成 DEQUEUED 状态了。 这意味着虽然在 CPU 这边已经拿到了 Buffer 的使用权，但别的硬件还在使用这个 Buffer。因此 GPU 还不能直接在上面绘画，它要等 releaseFence 收到 signal 信号后才可以绘画。</p><h4 id="相关代码"><a class="markdownIt-Anchor" href="#相关代码"></a> 相关代码</h4><p>应用侧申请 Buffer 的同时会获取到一个 Fence 对象（releaseFence）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/Surface.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Surface::dequeueBuffer</span><span class="params">(<span class="type">android_native_buffer_t</span>** buffer, <span class="type">int</span>* fenceFd)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    sp&lt;Fence&gt; fence;</span><br><span class="line">    <span class="type">status_t</span> result = mGraphicBufferProducer-&gt;<span class="built_in">dequeueBuffer</span>(&amp;buf, &amp;fence, dqInput.width, dqInput.height, dqInput.format, dqInput.usage, &amp;mBufferAge, dqInput.getTimestamps ? &amp;frameTimestamps : <span class="literal">nullptr</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SF 侧去读取 Slot 中的 Fence 对象并返回给应用侧：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/BufferQueueProducer.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BufferQueueProducer::dequeueBuffer</span><span class="params">(<span class="type">int</span>* outSlot, sp&lt;android::Fence&gt;* outFence, <span class="type">uint32_t</span> width, <span class="type">uint32_t</span> height, PixelFormat format, <span class="type">uint64_t</span> usage, <span class="type">uint64_t</span>* outBufferAge, FrameEventHistoryDelta* outTimestamps)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 把Slot里记录的mFence对象返回出去，就是应用侧拿到的releaseFence</span></span><br><span class="line">    *outFence = (mCore-&gt;mSharedBufferMode &amp;&amp; mCore-&gt;mSharedBufferSlot == found) ? Fence::NO_FENCE : mSlots[found].mFence;</span><br><span class="line">    mSlots[found].mEglFence = EGL_NO_SYNC_KHR;</span><br><span class="line">    mSlots[found].mFence = Fence::NO_FENCE;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用侧上帧时要创建一个 Fence 对象（acquireFence）来代表 GPU 的功能还在进行中，并在提交 Buffer 的同时把 Fence 对象传给 SF：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/Surface.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Surface::queueBuffer</span><span class="params">(<span class="type">android_native_buffer_t</span>* buffer, <span class="type">int</span> fenceFd)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    IGraphicBufferProducer::QueueBufferInput input;</span><br><span class="line">    <span class="built_in">getQueueBufferInputLocked</span>(buffer, fenceFd, mTimestamp, &amp;input);</span><br><span class="line">    <span class="type">status_t</span> err = mGraphicBufferProducer-&gt;<span class="built_in">queueBuffer</span>(i, input, &amp;output);</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Surface::getQueueBufferInputLocked</span><span class="params">(<span class="type">android_native_buffer_t</span>* buffer, <span class="type">int</span> fenceFd,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">nsecs_t</span> timestamp, IGraphicBufferProducer::QueueBufferInput* out)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">sp&lt;Fence&gt; <span class="title">fence</span><span class="params">(fenceFd &gt;= <span class="number">0</span> ? <span class="keyword">new</span> Fence(fenceFd) : Fence::NO_FENCE)</span></span>;</span><br><span class="line">    <span class="function">IGraphicBufferProducer::QueueBufferInput <span class="title">input</span><span class="params">(timestamp, isAutoTimestamp, <span class="keyword">static_cast</span>&lt;android_dataspace&gt;(mDataSpace), crop, mScalingMode, mTransform ^ mStickyTransform, fence, mStickyTransform, mEnableFrameTimestamps)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先通过 <code>getQueueBufferInputLocked()</code> 创建 Fence 对象（13 行），再将其放入 input 参数中（14 行）并返回到 <code>queueBuffer()</code>（4 行），最后将包含了这个 Fence 对象的 input 传给 SF（6 行）。</p><p>SF 侧从 Binder 中获取应用侧传来的 Fence 对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/BufferQueueProducer.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BufferQueueProducer::queueBuffer</span><span class="params">(<span class="type">int</span> slot, <span class="type">const</span> QueueBufferInput &amp;input, QueueBufferOutput *output)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    sp&lt;Fence&gt; acquireFence;</span><br><span class="line">    input.<span class="built_in">deflate</span>(&amp;requestedPresentTimestamp, &amp;isAutoTimestamp, &amp;dataSpace, &amp;crop, &amp;scalingMode, &amp;transform, &amp;acquireFence, &amp;stickyTransform, &amp;getFrameTimestamps);</span><br><span class="line">    ...</span><br><span class="line">    mSlots[slot].mFence = acquireFence; <span class="comment">// 将Slot中的mFence置位acquireFence</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过 systrace 观察一个因 GPU 工作时间太长，从而让 DRM 工作线程卡在等 Fence 的情况：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/25bbb4caed4025625e9e958270b6fc97.webp" alt=""></p><p>如上图所示，complete_commit 函数执行时前面有一段时间陷于等待状态了。那它在等谁呢？从图中我们可以看出它在等 73026 号 fence 的 signal 信号。这种情况说明 DRM 内部的 dma 要去读这 miHoYo.yuanshen 这个应用的 Buffer 时发现应用的 GPU 还没有把画面画完，因此不得不等它画完才能开始读取。但既然都已经送到 crtc_commit（图中左上角）了，至少在 CPU 这侧，该 Slot 的 BufferState 已经是 ACQUIRED 状态了。</p><h2 id="画面更新流程"><a class="markdownIt-Anchor" href="#画面更新流程"></a> 画面更新流程</h2><p>在前面的介绍中，我们从最底层的显示硬件到 APP 与 SF、HWC service 三者的关系，了解了帧数据流动所经过的关键节点，并重点讨论了帧 Buffer 是如何管理的，以及在流动过程中不同硬件之间是如何同步的。接下来我们从应用侧角度从上到下看一下应用所绘制的画面是如何使用到我们上面所设计的流程的。</p><h3 id="画布的申请"><a class="markdownIt-Anchor" href="#画布的申请"></a> 画布的申请</h3><p>应用侧对图层的操作是以 Surface 为接口的，它包含了一些更新画面相关的核心 API：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/include/gui/Surface.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Surface</span> : <span class="keyword">public</span> ANativeObjectBase&lt;ANativeWindow, Surface, RefBase&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">dequeueBuffer</span><span class="params">(ANativeWindowBuffer** buffer, <span class="type">int</span>* fenceFd)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">cancelBuffer</span><span class="params">(ANativeWindowBuffer* buffer, <span class="type">int</span> fenceFd)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">queueBuffer</span><span class="params">(ANativeWindowBuffer* buffer, <span class="type">int</span> fenceFd)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">perform</span><span class="params">(<span class="type">int</span> operation, va_list args)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">disconnect</span><span class="params">(<span class="type">int</span> api, IGraphicBufferProducer::DisconnectMode mode = IGraphicBufferProducer::DisconnectMode::Api)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用要想画出它的画面，首要解决的问题就是 <strong>应用侧的 Surface 对象如何创建，以及如何与 SF 建立联系</strong>。下面我们将从代码中寻找问题的答案。</p><p>在 Android 系统中每个 Activity 都有一个独立的画布（在应用侧称为 Surface，在 SF 侧称为 Layer），Activity 中的各种 View 就是画在了这块画布上。当然也有一个例外，SurfaceView 拥有自已独立的画布，但这里我们先只讨论 Activity 画布的创建过程。</p><p>首先每个应用都会创建自已的 Activity，进而 Android 会为 Activity 创建一个 ViewRootImpl，并调用到它的 <code>performTraversals()</code> 这个函数。该函数里会调用到 <code>relayoutWindow()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/view/ViewRootImpl.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">relayoutWindow</span><span class="params">(WindowManager.LayoutParams params, <span class="type">int</span> viewVisibility, <span class="type">boolean</span> insetsPending)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    ...</span><br><span class="line">    relayoutResult = mWindowSession.relayout(mWindow, params, requestedWidth, requestedHeight, viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : <span class="number">0</span>, mTmpFrames, mPendingMergedConfiguration, mSurfaceControl, mTempInsets, mTempControls, mRelayoutBundle);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mSurfaceControl.isValid()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!useBLAST()) &#123;</span><br><span class="line">            mSurface.copyFrom(mSurfaceControl);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>relayoutWindow()</code> 会通过 WindowSession 跨进程调用到 WMS 的 <code>relayout()</code> 函数，mWindowSession 可以看作是 WMS 在应用侧的代表。之后程序会进入到 WMS 所在的 system_server 进程，执行其 <code>relayoutWindow()</code> 函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">relayoutWindow</span><span class="params">(Session session, IWindow client, LayoutParams attrs,</span></span><br><span class="line"><span class="params">         <span class="type">int</span> requestedWidth, <span class="type">int</span> requestedHeight, <span class="type">int</span> viewVisibility, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">         ClientWindowFrames outFrames, MergedConfiguration mergedConfiguration,</span></span><br><span class="line"><span class="params">         SurfaceControl outSurfaceControl, InsetsState outInsetsState,</span></span><br><span class="line"><span class="params">         InsetsSourceControl[] outActiveControls, Bundle outSyncIdBundle)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    result = createSurfaceControl(outSurfaceControl, result, win, winAnimator);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数会通过 <code>createSurfaceControl()</code> 去创建一个 SurfaceControl 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">createSurfaceControl</span><span class="params">(SurfaceControl outSurfaceControl, <span class="type">int</span> result, WindowState win, WindowStateAnimator winAnimator)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    surfaceController = winAnimator.createSurfaceLocked();</span><br><span class="line">    ...</span><br><span class="line">    surfaceController.getSurfaceControl(outSurfaceControl);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 SurfaceControl 的创建工作是由 WindowStateAnimator 完成的，并且在创建完成之后会通过 <strong>outSurfaceControl</strong> 传出去。这里分别看一下这两个方法：</p><h4 id="createsurfacelocked"><a class="markdownIt-Anchor" href="#createsurfacelocked"></a> createSurfaceLocked()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/wm/WindowStateAnimator.java</span></span><br><span class="line">WindowSurfaceController <span class="title function_">createSurfaceLocked</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    mSurfaceController = <span class="keyword">new</span> <span class="title class_">WindowSurfaceController</span>(attrs.getTitle().toString(), format, flags, <span class="built_in">this</span>, attrs.type);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法创建了一个 WindowSurfaceController 对象，进而再去创建 SurfaceControl 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/wm/WindowSurfaceController.java</span></span><br><span class="line">WindowSurfaceController(String name, <span class="type">int</span> format, <span class="type">int</span> flags, WindowStateAnimator animator, <span class="type">int</span> windowType) &#123;</span><br><span class="line">    ...</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, <span class="string">&quot;new SurfaceControl&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> SurfaceControl.<span class="type">Builder</span> <span class="variable">b</span> <span class="operator">=</span> win.makeSurface()</span><br><span class="line">        .setParent(win.getSurfaceControl())</span><br><span class="line">        .setName(name)</span><br><span class="line">        .setFormat(format)</span><br><span class="line">        .setFlags(flags)</span><br><span class="line">        .setMetadata(METADATA_WINDOW_TYPE, windowType)</span><br><span class="line">        .setMetadata(METADATA_OWNER_UID, mWindowSession.mUid)</span><br><span class="line">        .setMetadata(METADATA_OWNER_PID, mWindowSession.mPid)</span><br><span class="line">        .setCallsite(<span class="string">&quot;WindowSurfaceController&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下 SurfaceControl 对象的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/view/SurfaceControl.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">SurfaceControl</span><span class="params">(SurfaceSession session, String name, <span class="type">int</span> w, <span class="type">int</span> h, <span class="type">int</span> format, <span class="type">int</span> flags, SurfaceControl parent, SparseIntArray metadata, WeakReference&lt;View&gt; localOwnerView, String callsite)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    mNativeObject = nativeCreate(session, name, w, h, format, flags, parent != <span class="literal">null</span> ? parent.mNativeObject : <span class="number">0</span>, metaParcel);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 层创建出了 SurfaceControl 对象，它会通过 JNI 去创建 Native 层的 Surface 对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/android_view_SurfaceControl.cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">nativeCreate</span><span class="params">(JNIEnv* env, jclass clazz, jobject sessionObj, jstring nameStr, jint w, jint h, jint format, jint flags, jlong parentObject, jobject metadataParcel)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    sp&lt;SurfaceComposerClient&gt; client;</span><br><span class="line">    <span class="type">status_t</span> err = client-&gt;<span class="built_in">createSurfaceChecked</span>(<span class="built_in">String8</span>(name.<span class="built_in">c_str</span>()), w, h, format, &amp;surface, flags, parentHandle, std::<span class="built_in">move</span>(metadata));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Surface 的创建在 Native 层会调用 SurfaceComposerClient 的 <code>createSurfaceChecked()</code> 方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/SurfaceConposerClient.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">SurfaceComposerClient::createSurfaceChecked</span><span class="params">(<span class="type">const</span> String8&amp; name, <span class="type">uint32_t</span> w, <span class="type">uint32_t</span> h, PixelFormat format, sp&lt;SurfaceControl&gt;* outSurface, <span class="type">uint32_t</span> flags, <span class="type">const</span> sp&lt;IBinder&gt;&amp; parentHandle, LayerMetadata metadata, <span class="type">uint32_t</span>* outTransformHint)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    err = mClient-&gt;<span class="built_in">createSurface</span>(name, w, h, format, flags, parentHandle, std::<span class="built_in">move</span>(metadata), &amp;handle, &amp;gbp, &amp;id, &amp;transformHint);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 mClient 是 <code>sp&lt;ISurfaceComposerClient&gt;</code> 类型，因此继续往下看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/ISurfaceConposerClient.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">createSurface</span><span class="params">(<span class="type">const</span> String8&amp; name, <span class="type">uint32_t</span> width, <span class="type">uint32_t</span> height, PixelFormat format, <span class="type">uint32_t</span> flags, <span class="type">const</span> sp&lt;IBinder&gt;&amp; parent, LayerMetadata metadata, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp, <span class="type">int32_t</span>* outLayerId, <span class="type">uint32_t</span>* outTransformHint)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">callRemote</span>&lt;<span class="keyword">decltype</span>(&amp;ISurfaceComposerClient::createSurface)&gt;(Tag::CREATE_SURFACE, name, width, height, format, flags, parent, std::<span class="built_in">move</span>(metadata), handle, gbp, outLayerId, outTransformHint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>callRemote()</code> 会通过 Binder 跨进程调用到 SurfaceFlinger 进程中 <code>Client.cpp</code> 中的 <code>createSurface()</code> 方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/Client.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Client::createSurface</span><span class="params">(<span class="type">const</span> String8&amp; name, <span class="type">uint32_t</span> <span class="comment">/* w */</span>, <span class="type">uint32_t</span> <span class="comment">/* h */</span>, PixelFormat <span class="comment">/* format */</span>, <span class="type">uint32_t</span> flags, <span class="type">const</span> sp&lt;IBinder&gt;&amp; parentHandle, LayerMetadata metadata, sp&lt;IBinder&gt;* outHandle, sp&lt;IGraphicBufferProducer&gt;* <span class="comment">/* gbp */</span>, <span class="type">int32_t</span>* outLayerId, <span class="type">uint32_t</span>* outTransformHint)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> mFlinger-&gt;<span class="built_in">createLayer</span>(args, outHandle, parentHandle, outLayerId, <span class="literal">nullptr</span>, outTransformHint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 SF 支持很多不同类型的 Layer，这里我们只以 BufferQueueLayer 为例进行介绍。当 SF 收到这个远程调用后会 new 一个 BufferQueueLayer 出来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">SurfaceFlinger::createLayer</span><span class="params">(LayerCreationArgs&amp; args, sp&lt;IBinder&gt;* outHandle, <span class="type">const</span> sp&lt;IBinder&gt;&amp; parentHandle, <span class="type">int32_t</span>* outLayerId, <span class="type">const</span> sp&lt;Layer&gt;&amp; parentLayer, <span class="type">uint32_t</span>* outTransformHint)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceBufferQueue:</span><br><span class="line">    <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceBufferState: &#123;</span><br><span class="line">        result = <span class="built_in">createBufferStateLayer</span>(args, outHandle, &amp;layer);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，BufferQueue 与 BufferState 所对应的 Layer 都是 BufferStateLayer。</p><p>简单梳理一下上述过程：为了申请一块画布，应用先创建了一个 ViewRoot 对象出来用于跟 WMS 进行通信，然后 WMS 创建出了 SurfaceControl 对象。在该对象的创建过程中经过层层调用，最终又在 SurfaceFlinger 进程中创建出了一个 Layer。那 Surface 对象又是在哪里创建出来的呢？继续看另一条分支：</p><h4 id="getsurfacecontrol"><a class="markdownIt-Anchor" href="#getsurfacecontrol"></a> getSurfaceControl()</h4><p>WMS 的 <code>createSurfaceControl()</code> 方法中是通过 <code>getSurfaceControl()</code> 将 outSurfaceControl 传出去的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/wm/WindowSurfaceController.java</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">getSurfaceControl</span><span class="params">(SurfaceControl outSurfaceControl)</span> &#123;</span><br><span class="line">    outSurfaceControl.copyFrom(mSurfaceControl, <span class="string">&quot;WindowSurfaceController.getSurfaceControl&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyFrom</span><span class="params">(<span class="meta">@NonNull</span> SurfaceControl other, String callsite)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    assignNativeObject(nativeCopyFromSurfaceControl(other.mNativeObject), callsite);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>nativeCopyFromSurfaceControl()</code> 会调用到 JNI 层代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/android_view_SurfaceControl.cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">nativeCopyFromSurfaceControl</span><span class="params">(JNIEnv* env, jclass clazz, jlong surfaceControlNativeObj)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    sp&lt;SurfaceControl&gt; newSurface = <span class="keyword">new</span> <span class="built_in">SurfaceControl</span>(surface);</span><br><span class="line">    newSurface-&gt;<span class="built_in">incStrong</span>((<span class="type">void</span> *)nativeCreate);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(newSurface.<span class="built_in">get</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数主要是通过 Native 层 SurfaceControl 的拷贝构造函数重新深拷贝了一个 SurfaceControl。拿到这个新的 SurfaceControl 对象后，会被作为参数传入 <code>assignNativeObject()</code> 函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/view/SurfaceControl.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">assignNativeObject</span><span class="params">(<span class="type">long</span> nativeObject, String callsite)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    mNativeObject = nativeObject;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数将深拷贝的 SurfaceControl 对象赋值给传入的 outSurfaceControl 的成员变量 mNativeObject。函数执行完后层层返回，跨进程调用回到 WMS，一直到 <a href="#%E7%94%BB%E5%B8%83%E7%9A%84%E7%94%B3%E8%AF%B7"><code>ViewRootImpl.java</code></a> 中的 <a href="#%E7%94%BB%E5%B8%83%E7%9A%84%E7%94%B3%E8%AF%B7"><code>relayoutWindow()</code></a> 函数，在第 19 行中通过 Surface 的 <code>copyFrom()</code> 方法从 SurfaceControl 中创建出了 Surface。</p><p>这里在 Java 层创建的 Surface 是如何拿到帧 Buffer 的操作接口的呢？我们来看下 Surface 的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/view/Surface.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Surface</span> <span class="keyword">implements</span> <span class="title class_">Parcelable</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">nativeLockCanvas</span><span class="params">(<span class="type">long</span> nativeObject, Canvas canvas, Rect dirty)</span> <span class="keyword">throws</span> OutOfResourcesException;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeUnlockCanvasAndPost</span><span class="params">(<span class="type">long</span> nativeObject, Canvas canvas)</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Surface 内部有两个关键函数：<code>nativeLockCanvas()</code> 和 <code>nativeUnlockCanvasAndPost()</code>，它们其实对应了 <code>dequeueBuffer()</code> 和 <code>queueBuffer()</code>。这两个函数对应了 JNI 层的实现，接下来就分别看下其实现过程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/android_view_Surface.cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">nativeLockCanvas</span><span class="params">(JNIEnv* env, jclass clazz, jlong nativeObject, jobject canvasObj, jobject dirtyRectObj)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">status_t</span> err = surface-&gt;<span class="built_in">lock</span>(&amp;buffer, dirtyRectPtr);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">nativeUnlockCanvasAndPost</span><span class="params">(JNIEnv* env, jclass clazz, jlong nativeObject, jobject canvasObj)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">status_t</span> err = surface-&gt;<span class="built_in">unlockAndPost</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应 Native 层 Surface 中的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/Surface.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Surface::lock</span><span class="params">(ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">status_t</span> err = <span class="built_in">dequeueBuffer</span>(&amp;out, &amp;fenceFd);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Surface::dequeueBuffer</span><span class="params">(<span class="type">android_native_buffer_t</span>** buffer, <span class="type">int</span>* fenceFd)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">status_t</span> result = mGraphicBufferProducer-&gt;<span class="built_in">dequeueBuffer</span>(&amp;buf, &amp;fence, dqInput.width, dqInput.height, dqInput.format, dqInput.usage, &amp;mBufferAge, dqInput.getTimestamps ? &amp;frameTimestamps : <span class="literal">nullptr</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Surface::unlockAndPost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    err = <span class="built_in">queueBuffer</span>(mLockedBuffer.<span class="built_in">get</span>(), fd);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Surface::queueBuffer</span><span class="params">(<span class="type">android_native_buffer_t</span>* buffer, <span class="type">int</span> fenceFd)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">status_t</span> err = mGraphicBufferProducer-&gt;<span class="built_in">queueBuffer</span>(i, input, &amp;output);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 Java 层中 Surface 的 lock 和 unlock 方法分别对应了 Native 层中 mGraphicBufferProducer 的 dequeueBuffer 和 queueBuffer。前面我们详细介绍过 dequeueBuffer 在获取一个 Slot 后，如果 Slot 没有分配 GraphicBuffer，会在这时给它分配 GraphicBuffer，并会返回一个带有 <code>BUFFER_NEEDS_REALLOCATION</code> 标记的 flag，应用侧看到这个 flag 后会通过 requestBuffer 和 importBuffer 把 GraphicBuffer 映射到自已的进程空间。至此应用拿到了它绘制界面所需的画布。</p><h4 id="小结-2"><a class="markdownIt-Anchor" href="#小结-2"></a> 小结</h4><p>最后用一张图来概括一下上述流程：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/8725430d07763f3b47513da4c9432f7d.webp" alt=""></p><p>在这个过程中涉及到三个进程：APP、system_server 和 SurfaceFlinger。从应用执行 <code>performTraversals()</code> 中调用的 <code>relayoutWindow()</code> 这个函数开始，它跨进程调用到了 system_server 进程中的 WMS 模块，这个模块的 <code>relayoutWindow()</code> 经过一系列过程又创建了一个 SurfaceContorl 对象，并且在其创建过程中跨进程调用 SF 让它创建了一个 Layer 出来。之后 SurfaceControl 对象会跨进程通过参数回传给应用，应用根据 SurfaceControl 创建出应用侧的 Surface 对象，而 Surface 对象通过一些 API 封装向上层提供了拿画布（dequeueBuffer）和提交画布（queueBuffer）的操作接口。这样应用就完成了对画布的申请操作。</p><h3 id="帧数据的绘制过程"><a class="markdownIt-Anchor" href="#帧数据的绘制过程"></a> 帧数据的绘制过程</h3><p>现在我们已经知道了应用是如何拿到画布的，接下来我们看下应用是如何在绘画完一帧后来提交数据的。</p><p>上节中应用的主线程在 <code>performTraversals()</code> 函数中获取到了操作帧缓冲区的 Surface 对象，这个 Surface 对象会通过 RenderProxy 传递给 RenderThread。一些关健代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/view/ViewRootImpl.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    hwInitialized = mAttachInfo.mThreadedRenderer.initialize(mSurface);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数中初始化时会把 Surface 对象传过去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/view/ThreadedRenderer.java</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">initialize</span><span class="params">(Surface surface)</span> <span class="keyword">throws</span> OutOfResourcesException &#123;</span><br><span class="line">    ...</span><br><span class="line">    setSurface(surface);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终会调用到 JNI 层的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/libs/hwui/jni/android_graphics_HardwareRenderer.cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">android_view_ThreadedRenderer_setSurface</span><span class="params">(JNIEnv* env, jobject clazz,</span></span></span><br><span class="line"><span class="params"><span class="function">        jlong proxyPtr, jobject jsurface, jboolean discardBuffer)</span> </span>&#123;</span><br><span class="line">    RenderProxy* proxy = <span class="built_in">reinterpret_cast</span>&lt;RenderProxy*&gt;(proxyPtr);</span><br><span class="line">    ...</span><br><span class="line">    proxy-&gt;<span class="built_in">setSurface</span>(window, enableTimeout);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/libs/hwui/renderthread/RenderProxy.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderProxy::setSurface</span><span class="params">(ANativeWindow* window, <span class="type">bool</span> enableTimeout)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mRenderThread.<span class="built_in">queue</span>().<span class="built_in">post</span>([<span class="keyword">this</span>, win = window, enableTimeout]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        mContext-&gt;<span class="built_in">setSurface</span>(win, enableTimeout); <span class="comment">// mContext是CanvasContext*类型</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CanvasContext::setSurface</span><span class="params">(ANativeWindow* window, <span class="type">bool</span> enableTimeout)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mNativeSurface = std::<span class="built_in">make_unique</span>&lt;ReliableSurface&gt;(window);</span><br><span class="line">    mNativeSurface-&gt;<span class="built_in">init</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>setSurface()</code> 最终是通过 RenderProxy 对象向 RenderThread 的消息队列中 post 了一个消息，在这个消息处理的过程中又会调用 CanvasContext 的 <code>setSurface()</code> 方法。上述过程如图所示：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/1b88289ed75ddbf1d39025c8132c3322.webp" alt=""></p><p>接下来应用主线程收到 vsync 信号后开始绘图流程，它会遍历 ViewTree 对所有 View完成 measure、layout 和 draw 的工作。我们知道 Android 的应用界面是由很多 View 按树状结构组织起来的，以微信主界面为例，但无论界面多么复杂它都有一个根 View 叫 DecorView。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/b81c5d4abe6f4e0627438219d1bca1f2.webp" alt=""></p><p>我们这里不讨论 UI 线程的 measure 和 layout 部分，只看下 draw。</p><p>App 每次绘画都是收到一个 vsync 信号才会开始的（这里暂不讨论 SurfaceView 自主上帧的情况）。应用通过 Choreographer 感知 vsync 信号, 在 ViewRootImpl 中向 Choreographer 注册一个 callback，每当有 vsync 信号来时会执行 mTraversalRunnable：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/view/ViewRootImpl.java</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">TraversalRunnable</span> <span class="variable">mTraversalRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TraversalRunnable</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">scheduleTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    mChoreographer.postCallback(</span><br><span class="line">        Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="literal">null</span>); <span class="comment">// 注册vsync的回调</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        doTraversal(); <span class="comment">// 每次vsync到来时调用该函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看一下 Vsync 信号到来时 <code>doTraversal()</code> 函数都做了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/view/ViewRootImpl.java</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doTraversal</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    performTraversals();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!performDraw() &amp;&amp; mSyncBufferCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">performDraw</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">canUseAsync</span> <span class="operator">=</span> draw(fullRedrawNeeded, usingAsyncReport &amp;&amp; mSyncBuffer);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">draw</span><span class="params">(<span class="type">boolean</span> fullRedrawNeeded, <span class="type">boolean</span> forceDraw)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 这里传入的mView是DecorView</span></span><br><span class="line">    mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, <span class="built_in">this</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>draw()</code> 又进一步调用到了 ThreadedRenderer 中的 <code>draw()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/view/ThreadedRenderer.java</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(View view, AttachInfo attachInfo, DrawCallbacks callbacks)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    updateRootDisplayList(view, callbacks);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateRootDisplayList</span><span class="params">(View view, DrawCallbacks callbacks)</span> &#123;</span><br><span class="line">    <span class="comment">// 可以在systrace中看到这个字符串</span></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">&quot;Record View#draw()&quot;</span>);</span><br><span class="line">    updateViewTreeDisplayList(view); <span class="comment">// 更新ViewTree</span></span><br><span class="line">    ...</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateViewTreeDisplayList</span><span class="params">(View view)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    view.updateDisplayListIfDirty();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会调用到 DecorView 中的更新方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/view/View.java</span></span><br><span class="line"><span class="keyword">public</span> RenderNode <span class="title function_">updateDisplayListIfDirty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这里开始记录Displaylist</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">RecordingCanvas</span> <span class="variable">canvas</span> <span class="operator">=</span> renderNode.beginRecording(width, height);</span><br><span class="line">    ...</span><br><span class="line">    draw(canvas);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 RecordingCanvas 扮演了一个绘图指令记录员的角色，它会根据 <code>draw()</code> 中绘制的指令将这个 View 以 DisplayList 的形式记录下来。</p><p>那么上面的 RenderNode 又是什么呢？</p><p>Web 中有 DOM Tree 和 Render Tree 的概念，Android 里的 View 和 RenderNode 是类似的概念。View 代表的是实体在空间结构上的存在，而 RenderNode 代表它在界面呈现上的存在。这样的设计可以让存在和呈现分离，便于实现同一存在在不同状态下的呈现不同。</p><p>在 Android 的设计中 View 会对应一个 RenderNode，RenderNode 里的一个重要数据结构是 DisplayList，每个 DisplayList 都会包含一系列 DisplayListData。这些 DisplayList 也会同样以树形结构组织在一起。</p><p>当 UI 线程完成它的绘制工作以后，它的产物是一堆 DisplayListData。可以将其理解为是一堆绘图指令的集合，每一个 DisplayListData 都是在描绘这个 View 长什么样子，所以一棵 View 树的样子是由它对应的 DisplayListData 构成的树来描述的：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/9dddda45539d60f9fdebcdd208ebc3d3.webp" alt=""></p><p>我们看下 DisplayListData 到底长什么样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/libs/hwui/RecordingCanvas.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DisplayListData</span> <span class="keyword">final</span> &#123;</span><br><span class="line"> ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">drawPath</span><span class="params">(<span class="type">const</span> SkPath&amp;, <span class="type">const</span> SkPaint&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">drawRect</span><span class="params">(<span class="type">const</span> SkRect&amp;, <span class="type">const</span> SkPaint&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">drawArc</span><span class="params">(<span class="type">const</span> SkRect&amp;, SkScalar, SkScalar, <span class="type">bool</span>, <span class="type">const</span> SkPaint&amp;)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">push</span><span class="params">(<span class="type">size_t</span>, Args&amp;&amp;...)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    SkAutoTMalloc&lt;<span class="type">uint8_t</span>&gt; fBytes;</span><br><span class="line">    <span class="type">size_t</span> fUsed = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中：以 draw 打头的函数是最基本的绘图指令，比如画一条线、一个矩形、一段圆弧等等；<code>push()</code> 模板函数我们稍后会分析；fBytes 是一块存储区，它会根据需要扩大存储区的大小。</p><p>这里以绘制一个矩形为例看下其实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/libs/hwui/RecordingCanvas.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DisplayListData::drawRect</span><span class="params">(<span class="type">const</span> SkRect&amp; rect, <span class="type">const</span> SkPaint&amp; paint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">push</span>&lt;DrawRect&gt;(<span class="number">0</span>, rect, paint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 push 了一个 DrawRect 的相关参数，那 DrawRect 又是什么呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/libs/hwui/RecordingCanvas.cpp</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DrawRect</span> <span class="keyword">final</span> : Op &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Op</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> type : <span class="number">8</span>;</span><br><span class="line">    <span class="type">uint32_t</span> skip : <span class="number">24</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以发现，DrawRect 代表的是一段内存布局，这段内存的第一个字节存储了它是哪种类型，后面部分存储了画这个 Rect 所需要的参数信息。</p><p>再来看下 <code>push()</code> 方法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/libs/hwui/RecordingCanvas.cpp</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">DisplayListData::push</span><span class="params">(<span class="type">size_t</span> pod, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">auto</span> op = (T*)(fBytes.<span class="built_in">get</span>() + fUsed);</span><br><span class="line">    fUsed += skip;</span><br><span class="line">    <span class="keyword">new</span> (op) T&#123;std::forward&lt;Args&gt;(args)...&#125;;</span><br><span class="line">    op-&gt;type = (<span class="type">uint32_t</span>)T::kType;</span><br><span class="line">    op-&gt;skip = skip;</span><br><span class="line">    <span class="keyword">return</span> op + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>push()</code> 方法就是在 fBytes 后面放入这个 DrawRect 的内存布局。所以回到 <code>DisplayListData::drawRect()</code> 方法，它其实就是把绘制这个 Rect 的方法和参数存入了 fBytes 这块内存中，因此最后 fBytes 中就存放了一条条的绘制指令。</p><p>经过上面的介绍，我们知道了 UI 线程并没有将应用设计的 View 转换成像素点数据，而是将每个 View 的绘图指令存入了内存中，我们通常称这些绘图指令为 <strong>DisplayList</strong>。下面让我们跳出这些细节，再次回到宏观的角度。</p><p>当所有 View 的 DisplayList 建立完成后，代码会来到 <code>RenderProxy::syncAndDrawFrame()</code> 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/libs/hwui/renderthread/RenderProxy.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RenderProxy::syncAndDrawFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDrawFrameTask.<span class="built_in">drawFrame</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/libs/hwui/renderthread/DrawFrameTask.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DrawFrameTask::drawFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">postAndWait</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawFrameTask::postAndWait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mRenderThread-&gt;<span class="built_in">queue</span>().<span class="built_in">post</span>([<span class="keyword">this</span>]() &#123; <span class="built_in">run</span>(); &#125;);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，UI 线程的工作已经结束，它丢了一个叫 DrawFrameTask 的任务到 RenderThread 线程中，之后画面绘制的工作 <code>run()</code> 就转移到了 RenderThread 线程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/libs/hwui/renderthread/DrawFrameTask.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawFrameTask::run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    dequeueBufferDuration = context-&gt;<span class="built_in">draw</span>(); <span class="comment">// context是CanvasContext*类型</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/libs/hwui/renderthread/CanvasContext.cpp</span></span><br><span class="line"><span class="function"><span class="type">nsecs_t</span> <span class="title">CanvasContext::draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Frame frame = mRenderPipeline-&gt;<span class="built_in">getFrame</span>(); <span class="comment">// 会调用到Surface的dequeueBuffer()</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 这里的mRenderPipeline是std::unique_ptr&lt;IRenderPipeline&gt;类型</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> drawResult = mRenderPipeline-&gt;<span class="built_in">draw</span>(frame, windowDirty, dirty, mLightGeometry, &amp;mLayerUpdateQueue, mContentDrawBounds, mOpaque, mLightInfo, mRenderNodes, &amp;(<span class="built_in">profiler</span>()));</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">waitOnFences</span>();</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">bool</span> didSwap = mRenderPipeline-&gt;<span class="built_in">swapBuffers</span>(frame, drawResult.success, windowDirty, mCurrentFrameInfo, &amp;requireSwap);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数中完成了三个重要的动作：</p><ul><li>通过 <code>getFrame()</code> 调到了 Surface 的 <code>dequeueBuffer()</code> 向 SurfaceFlinger 申请了画布。</li><li>通过 <code>mRenderPipeline-&gt;draw()</code> 将画面画到申请到的画布上。</li><li>通过 <code>mRenderPipeline-&gt;swapBuffers()</code> 把画布提交到 SurfaceFlinger 去显示。</li></ul><p>我们看一下在 <code>mRenderPipeline-&gt;draw()</code> 里是如何将 DisplayList 翻译成画布上的像素点颜色的呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/libs/hwui/pipelinw/skia/SkiaPipeline.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SkiaPipeline</span> : <span class="keyword">public</span> renderthread::IRenderPipeline &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/libs/hwui/pipelinw/skia/SkiaOpenGLPipeline.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SkiaOpenGLPipeline</span> : <span class="keyword">public</span> SkiaPipeline, <span class="keyword">public</span> IGpuContextCallback &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/libs/hwui/pipelinw/skia/SkiaOpenGLPipeline.cpp</span></span><br><span class="line"><span class="function">IRenderPipeline::DrawResult <span class="title">SkiaOpenGLPipeline::draw</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> Frame&amp; frame, <span class="type">const</span> SkRect&amp; screenDirty, <span class="type">const</span> SkRect&amp; dirty,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> LightGeometry&amp; lightGeometry, LayerUpdateQueue* layerUpdateQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> Rect&amp; contentDrawBounds, <span class="type">bool</span> opaque, <span class="type">const</span> LightInfo&amp; lightInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::vector&lt;sp&lt;RenderNode&gt;&gt;&amp; renderNodes, FrameInfoVisualizer* profiler)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">renderFrame</span>(*layerUpdateQueue, dirty, renderNodes, opaque, contentDrawBounds, surface, SkMatrix::<span class="built_in">I</span>());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/libs/hwui/pipelinw/skia/SkiaPipeline.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SkiaPipeline::renderFrame</span><span class="params">(<span class="type">const</span> LayerUpdateQueue&amp; layers, <span class="type">const</span> SkRect&amp; clip,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> std::vector&lt;sp&lt;RenderNode&gt;&gt;&amp; nodes, <span class="type">bool</span> opaque,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> Rect&amp; contentDrawBounds, sk_sp&lt;SkSurface&gt; surface,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> SkMatrix&amp; preTransform)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    SkCanvas* canvas = <span class="built_in">tryCapture</span>(surface.<span class="built_in">get</span>(), nodes[<span class="number">0</span>].<span class="built_in">get</span>(), layers);</span><br><span class="line">    <span class="built_in">renderFrameImpl</span>(clip, nodes, opaque, contentDrawBounds, canvas, preTransform);</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">renderOverdraw</span>(clip, nodes, contentDrawBounds, surface, preTransform);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的 <code>renderFrameImpl()</code> 中会把在 UI 线程中记录的 DisplayList 绘制到 SkSurface 中，然后通过 SkCanvas 将其转化为 gl 指令，最后 <code>renderOverdraw()</code> 会将这些指令翻译成画布上的像素点颜色。</p><p>最后总结一下 APP 通过 View 绘制出第一帧的总流程，如图：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/6122c4d282043186f9a020f4fbcd0b9c.webp" alt=""></p><p>首先是 UI 线程进行 Measure、Layout，然后开始 Draw。在 Draw 的过程中会建立 DisplayList 树，将每个 View 应该怎么画记录下来，再通过 RenderProxy 把后续任务下达给 RenderThread。</p><p>RenderThread 主要完成三个动作：首先通过 Surface 接口向 SF 申请 Buffer；然后通过 SkiaOpenGLPipline 的 <code>draw()</code> 方法把 DisplayList 翻译成 GPU 指令， 并指挥 GPU 把指令变成像素点数据；最后通过 <code>swapBuffers()</code> 把数据提交给 SF，完成一帧数据的绘制和提交。</p><h3 id="帧数据的提交过程"><a class="markdownIt-Anchor" href="#帧数据的提交过程"></a> 帧数据的提交过程</h3><p>接下来看一下应用 queueBuffer 之后 SurfaceFlinger 是如何处理，又是如何提交到 HWC Service 去合成的。</p><p>在 Vsync-sf 信号到来后，SurfaceFlinger 主线程会先后执行 <code>commit()</code> 和 <code>composite()</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SurfaceFlinger::commit</span><span class="params">(<span class="type">nsecs_t</span> frameTime, <span class="type">int64_t</span> vsyncId, <span class="type">nsecs_t</span> expectedVsyncTime)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mustComposite |= <span class="built_in">latchBuffers</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SurfaceFlinger::latchBuffers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (layer-&gt;<span class="built_in">latchBuffer</span>(visibleRegions, latchTime, expectedPresentTime))</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/BufferLayer.cpp</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferLayer::latchBuffer</span><span class="params">(<span class="type">bool</span>&amp; recomputeVisibleRegions, <span class="type">nsecs_t</span> latchTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">nsecs_t</span> expectedPresentTime)</span> </span>&#123;</span><br><span class="line"> ...</span><br><span class="line">    <span class="type">status_t</span> err = <span class="built_in">updateTexImage</span>(recomputeVisibleRegions, latchTime, expectedPresentTime);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/BufferQueueLayer.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BufferQueueLayer::updateTexImage</span><span class="params">(<span class="type">bool</span>&amp; recomputeVisibleRegions, <span class="type">nsecs_t</span> latchTime, <span class="type">nsecs_t</span> expectedPresentTime)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">status_t</span> updateResult = mConsumer-&gt;<span class="built_in">updateTexImage</span>(&amp;r, expectedPresentTime, &amp;autoRefresh, &amp;queuedBuffer, maxFrameNumberToAcquire);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/BufferLayerConsumer.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BufferLayerConsumer::updateTexImage</span><span class="params">(BufferRejecter* rejecter, <span class="type">nsecs_t</span> expectedPresentTime, <span class="type">bool</span>* autoRefresh, <span class="type">bool</span>* queuedBuffer, <span class="type">uint64_t</span> maxFrameNumber)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">status_t</span> err = <span class="built_in">acquireBufferLocked</span>(&amp;item, expectedPresentTime, maxFrameNumber);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/native/libs/gui/ConsumerBase.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">ConsumerBase::acquireBufferLocked</span><span class="params">(BufferItem *item, <span class="type">nsecs_t</span> presentWhen, <span class="type">uint64_t</span> maxFrameNumber)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">status_t</span> err = mConsumer-&gt;<span class="built_in">acquireBuffer</span>(item, presentWhen, maxFrameNumber);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>commit()</code> 函数的处理中，SurfaceFlinger 主要检查每个 Layer 是否有新提交的 Buffer，如果有则调用 <code>latchBuffer()</code> 将每个 BufferQueue 中的 Slot 通过 <code>acquireBuffer()</code> 拿走。</p><p>拿走的 Buffer 会被交由 HWC Service 处理，这部分是在 <code>composite()</code> 中进行的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::composite</span><span class="params">(<span class="type">nsecs_t</span> frameTime, <span class="type">int64_t</span> vsyncId)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mCompositionEngine-&gt;<span class="built_in">present</span>(refreshArgs);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/CompositionEngine/src/CompositionEngine.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CompositionEngine::present</span><span class="params">(CompositionRefreshArgs&amp; args)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; output : args.outputs) &#123;</span><br><span class="line">        output-&gt;<span class="built_in">present</span>(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/CompositionEngine/src/Output.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Output::present</span><span class="params">(<span class="type">const</span> compositionengine::CompositionRefreshArgs&amp; refreshArgs)</span> </span>&#123;</span><br><span class="line"> ...</span><br><span class="line">    <span class="built_in">postFramebuffer</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Output::postFramebuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">auto</span> frame = <span class="built_in">presentAndGetFrameFences</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">HWComposer::presentAndGetReleaseFences</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        HalDisplayId displayId, std::chrono::steady_clock::time_point earliestPresentTime, <span class="type">const</span> std::shared_ptr&lt;FenceTime&gt;&amp; previousPresentFence)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 送去HWC Service合成</span></span><br><span class="line">    <span class="keyword">auto</span> error = hwcDisplay-&gt;<span class="built_in">present</span>(&amp;displayData.lastPresentFence);</span><br><span class="line">    ...</span><br><span class="line">    std::unordered_map&lt;HWC2::Layer*, sp&lt;Fence&gt;&gt; releaseFences;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后就进入 HWC Service 的处理流程，这部分的处理流程和芯片厂商 HAL 层实现紧密相关，这里不再介绍。</p><h3 id="小结-3"><a class="markdownIt-Anchor" href="#小结-3"></a> 小结</h3><p>我们沿着代码逻辑介绍了应用是如何申请到画布、如何使用 Android 的 View 系统绘图、绘图完成后如何提交 Buffer 以及 Surfaceflinger 如何处理。但本章所述的逻辑均是指通 Android 的 View 系统绘图的过程，也可以称其为 <strong>hwui 绘图</strong>。</p><p>从上面代码流程可以知道，hwui 的绘图流程是被 vsync 信号触发的，开始于 vsync 信号到达 UI 线程调用 <code>performTraversals()</code> 函数，hwui 的画面更新是被 vsync 信号驱动的。</p><p>在 Android 系统中也有提供不依赖 vsync 信号的自主上帧接口，比如 App 可以使用 SurfaceView 这个特殊的 View 来申请一个独立于 Activity 的画布。接下来我们通过几个示例来看下这些接口是如何使用的。</p><h2 id="应用是如何绘图的"><a class="markdownIt-Anchor" href="#应用是如何绘图的"></a> 应用是如何绘图的</h2><p>目前很多游戏类应用都是借由 SurfaceView 申请到画布，然后自主上帧的，并不依赖 Vsync 信号，所以我们通过几个示例来看下应用侧是如何绘图和上帧的。由于 Java 层很多接口是对 Native 层接口的 JNI 封装，这里我们只看一些 Native 层接口的用法。</p><p>以下代码去除了一些异常处理代码，只保留了重要部分，如需执行可自行补充完整。</p><h3 id="无图形库支持下的绘图"><a class="markdownIt-Anchor" href="#无图形库支持下的绘图"></a> 无图形库支持下的绘图</h3><p>下面的示例中演示的是如何使用 Native 层接口向 SF 申请一块画布，然后不使用任何图形库直接修改画布上的像素值，最后提交给 SF 进行显示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">sp&lt;ProcessState&gt; <span class="title">proc</span><span class="params">(ProcessState::self())</span></span>;</span><br><span class="line">    <span class="comment">// 在应用和SF沟通过程中要使用到Binder, 所以这里要先初始化Binder线程池</span></span><br><span class="line">    ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">startThreadPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SurfaceComposerClient是SF在应用侧的代表，SF的接口通过它来提供</span></span><br><span class="line">    sp&lt;SurfaceComposerClient&gt; client = <span class="keyword">new</span> <span class="built_in">SurfaceComposerClient</span>();</span><br><span class="line">    client-&gt;<span class="built_in">initCheck</span>();</span><br><span class="line">    <span class="comment">// 先通过createSurface()申请一块画布，参数包含为画布起的名字、大小、位深信息</span></span><br><span class="line">    sp&lt;SurfaceControl&gt; surfaceControl = client-&gt;<span class="built_in">createSurface</span>(</span><br><span class="line">        <span class="built_in">String8</span>(<span class="string">&quot;Console Surface&quot;</span>),<span class="number">800</span>, <span class="number">600</span>, PIXEL_FORMAT_RGBA_8888);</span><br><span class="line"></span><br><span class="line">    SurfaceComposerClient::Transaction t;</span><br><span class="line">    t.<span class="built_in">setLayer</span>(surfaceControl, <span class="number">0x40000000</span>).<span class="built_in">apply</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过getSurface()从surfaceControl中获取到Surface对象</span></span><br><span class="line">    sp&lt;Surface&gt; surface = surfaceControl-&gt;<span class="built_in">getSurface</span>();</span><br><span class="line">    </span><br><span class="line">    ANativeWindow_Buffer buffer;</span><br><span class="line">    <span class="comment">// 通过lock()调用到dequeueBuffer()获取到一个BufferQueue可用的Slot</span></span><br><span class="line">    <span class="type">status_t</span> err = surface-&gt;<span class="built_in">lock</span>(&amp;buffer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* addr = buffer.bits;</span><br><span class="line">    <span class="type">ssize_t</span> len = buffer.stride * <span class="number">4</span> * buffer.height;</span><br><span class="line">    <span class="comment">// 绘图。由于没有使用任何图形库，所以这里把内存填成255画一个纯色画面</span></span><br><span class="line">    <span class="built_in">memset</span>(addr, <span class="number">255</span>, len);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里会调用到queueBuffer()把我们绘制好的画面提交给SF</span></span><br><span class="line">    surface-&gt;<span class="built_in">unlockAndPost</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sleep...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">5</span> * <span class="number">1000</span> * <span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">    surface.<span class="built_in">clear</span>();</span><br><span class="line">    surfaceControl.<span class="built_in">clear</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;complete. CTRL+C to finish.\n&quot;</span>);</span><br><span class="line">    IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">joinThreadPool</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该示例中的几个关键步骤是：</p><ul><li>创建一个 SurfaceComposerClient，它是应用与 SF 沟通的桥梁。</li><li>通过 SurfaceComposerClient 的 <code>createLayer()</code> 方法创建出 SurfaceControl，再通过其 <code>getSurface()</code> 方法获取到 Surface 对象，这是我们操作 BufferQueue 的接口。</li><li>有了 Surface 对象，就可以调用它的 <code>lock()</code> 方法来 dequeueBuffer，调用 <code>unlockAndPost()</code> 来 queueBuffer 了。如此循环，就可以对画布进行连续绘制和提交数据了。</li></ul><h3 id="有图形库支持下的绘图"><a class="markdownIt-Anchor" href="#有图形库支持下的绘图"></a> 有图形库支持下的绘图</h3><p>在上面的示例中我们并没有去画复杂的图案，只是使用内存填充的方式画了一个纯色画面。在本节中我们将尝试使用 Skia 图形库在给定的画布上让 CPU 去画一些复杂的图案，比如画一张图片上去。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> android;</span><br><span class="line"><span class="comment">// 把图片转成Bitmap</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">status_t</span> <span class="title">initBitmap</span><span class="params">(SkBitmap* bitmap, <span class="type">const</span> <span class="type">char</span>* fileName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fileName == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    sk_sp&lt;SkData&gt; data = SkData::<span class="built_in">MakeFromFileName</span>(fileName);</span><br><span class="line">    sk_sp&lt;SkImage&gt; image = SkImage::<span class="built_in">MakeFromEncoded</span>(data);</span><br><span class="line">    <span class="type">bool</span> result = image-&gt;<span class="built_in">asLegacyBitmap</span>(bitmap, SkImage::kRO_LegacyBitmapMode);</span><br><span class="line">    <span class="keyword">if</span>(!result )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;decode picture fail!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">sp&lt;ProcessState&gt; <span class="title">proc</span><span class="params">(ProcessState::self())</span></span>;</span><br><span class="line">    ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">startThreadPool</span>(); <span class="comment">// 开启Binder线程池</span></span><br><span class="line"></span><br><span class="line">    sp&lt;SurfaceComposerClient&gt; client = <span class="keyword">new</span> <span class="built_in">SurfaceComposerClient</span>();</span><br><span class="line">    client-&gt;<span class="built_in">initCheck</span>();</span><br><span class="line">    sp&lt;SurfaceControl&gt; surfaceControl = client-&gt;<span class="built_in">createSurface</span>(</span><br><span class="line">        <span class="built_in">String8</span>(<span class="string">&quot;Consoleplayer Surface&quot;</span>),<span class="number">800</span>, <span class="number">600</span>, PIXEL_FORMAT_RGBA_8888);</span><br><span class="line"></span><br><span class="line">    SurfaceComposerClient::Transaction t;</span><br><span class="line">    t.<span class="built_in">setLayer</span>(surfaceControl, <span class="number">0x40000000</span>).<span class="built_in">apply</span>();</span><br><span class="line"></span><br><span class="line">    sp&lt;Surface&gt; surface = surfaceControl-&gt;<span class="built_in">getSurface</span>();</span><br><span class="line"> </span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; graphicBufferProducer = </span><br><span class="line">           surface-&gt;<span class="built_in">getIGraphicBufferProducer</span>();</span><br><span class="line">    ANativeWindow_Buffer buffer;</span><br><span class="line">    <span class="type">status_t</span> err = surface-&gt;<span class="built_in">lock</span>(&amp;buffer, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">ssize_t</span> bpr = buffer.stride * <span class="built_in">bytesPerPixel</span>(buffer.format);</span><br><span class="line">    SkColorType config = <span class="built_in">convertPixelFormat</span>(buffer.format);</span><br><span class="line">    SkBitmap* bitmapDevice = <span class="keyword">new</span> SkBitmap;</span><br><span class="line">    bitmapDevice-&gt;<span class="built_in">setInfo</span>(SkImageInfo::<span class="built_in">Make</span>(buffer.width, buffer.height, </span><br><span class="line">                          config, kPremul_SkAlphaType), bpr);</span><br><span class="line">    <span class="keyword">if</span> (buffer.width &gt; <span class="number">0</span> &amp;&amp; buffer.height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里把帧缓冲区buffer的地址设给了bitmapDevice</span></span><br><span class="line">        <span class="comment">// 这时向bitmapDevice绘制就是在向buffer绘制</span></span><br><span class="line">        bitmapDevice-&gt;<span class="built_in">setPixels</span>(buffer.bits);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bitmapDevice-&gt;<span class="built_in">setPixels</span>(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;to create canvas..\n&quot;</span>);</span><br><span class="line">    SkCanvas* nativeCanvas = <span class="keyword">new</span> <span class="built_in">SkCanvas</span>(*bitmapDevice);</span><br><span class="line">    SkRect sr;</span><br><span class="line">    SkIRect* updateRect = <span class="keyword">new</span> SkIRect;</span><br><span class="line">    sr.<span class="built_in">set</span>(*updateRect);</span><br><span class="line">    nativeCanvas-&gt;<span class="built_in">clipRect</span>(sr);</span><br><span class="line">    nativeCanvas-&gt;<span class="built_in">clear</span>(SK_ColorBLACK);</span><br><span class="line">    SkPaint paint;</span><br><span class="line">    paint.<span class="built_in">setAlpha</span>(<span class="number">255</span>);</span><br><span class="line">    <span class="type">const</span> SkRect dst = SkRect::<span class="built_in">MakeXYWH</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line">    SkBitmap* bitmap = <span class="keyword">new</span> SkBitmap;</span><br><span class="line">    <span class="built_in">initBitmap</span>(bitmap, <span class="string">&quot;/sdcard/picture.png&quot;</span>); <span class="comment">// 从文件中读一个Bitmap出来</span></span><br><span class="line">    <span class="type">const</span> SkIRect src1 = SkIRect::<span class="built_in">MakeXYWH</span>(<span class="number">0</span>, <span class="number">0</span>, bitmap-&gt;<span class="built_in">width</span>(), bitmap-&gt;<span class="built_in">height</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;draw ....\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 调用SkCanvas的drawBitmapRect把图片画到bitmapDevice</span></span><br><span class="line">    <span class="comment">// 也就是画到了从Surface申请到的帧缓冲区buffer中</span></span><br><span class="line">    nativeCanvas-&gt;<span class="built_in">drawBitmapRect</span>((*bitmap), src1, dst, &amp;paint);</span><br><span class="line">    </span><br><span class="line">    surface-&gt;<span class="built_in">unlockAndPost</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sleep...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">10</span> * <span class="number">1000</span> * <span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">    surface.<span class="built_in">clear</span>();</span><br><span class="line">    surfaceControl.<span class="built_in">clear</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test complete. CTRL+C to finish.\n&quot;</span>);</span><br><span class="line">    IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">joinThreadPool</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该示例中获取帧缓冲区 buffer 的方式和上一个例子是一样的，不同的是我们把申请到的 buffer 的地址空间给了 Skia 库，然后通过 Skia 提供的接口把一张图片画到了 buffer 中。由此可以看出我们想使用图形库来操作帧缓冲区的关键是要把帧缓冲区 buffer 的地址对接到图形库提供的接口上。</p><p>在 Android 平台上，我们通常不会直接使用 CPU 去绘图，而是调用 OpenGL 或其他图形库去指挥 GPU 绘图。那么使用 OpenGL 库又是如何完成绘图的呢？</p><h3 id="使用openglegl的绘图"><a class="markdownIt-Anchor" href="#使用openglegl的绘图"></a> 使用OpenGL&amp;EGL的绘图</h3><p>由第二个例子可知，要想使用图形库来向帧缓冲区 buffer 绘图，关建是要把对应的 buffer 给到图形库。但 OpenGL 是一套与平台无关的 API 接口，跟 Surface 接口的任务是由 EGL 完成的，所以帧缓冲区 buffer 要和 EGL 库去对接。</p><p>EGL 库会提供一个 EGLSurface 对象，它是对 Surface 的封装，提供了两个重要的接口：dequeue 和 queue，分别对应 Surface 的 dequeueBuffer 和 queueBuffer。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> android;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">sp&lt;ProcessState&gt; <span class="title">proc</span><span class="params">(ProcessState::self())</span></span>;</span><br><span class="line">    ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">startThreadPool</span>();</span><br><span class="line"></span><br><span class="line">    sp&lt;SurfaceComposerClient&gt; client = <span class="keyword">new</span> <span class="built_in">SurfaceComposerClient</span>();</span><br><span class="line">    client-&gt;<span class="built_in">initCheck</span>();</span><br><span class="line">    sp&lt;SurfaceControl&gt; surfaceControl = client-&gt;<span class="built_in">createSurface</span>(</span><br><span class="line">        <span class="built_in">String8</span>(<span class="string">&quot;Consoleplayer Surface&quot;</span>),<span class="number">800</span>, <span class="number">600</span>, PIXEL_FORMAT_RGBA_8888);</span><br><span class="line"></span><br><span class="line">    SurfaceComposerClient::Transaction t;</span><br><span class="line">    t.<span class="built_in">setLayer</span>(surfaceControl, <span class="number">0x40000000</span>).<span class="built_in">apply</span>();</span><br><span class="line"></span><br><span class="line">    sp&lt;Surface&gt; surface = surfaceControl-&gt;<span class="built_in">getSurface</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化EGL属性</span></span><br><span class="line">    <span class="type">const</span> EGLint attribs[] = &#123;</span><br><span class="line">        EGL_RED_SIZE,   <span class="number">8</span>,</span><br><span class="line">        EGL_GREEN_SIZE, <span class="number">8</span>,</span><br><span class="line">        EGL_BLUE_SIZE,  <span class="number">8</span>,</span><br><span class="line">        EGL_DEPTH_SIZE, <span class="number">0</span>,</span><br><span class="line">        EGL_NONE</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化EGL库</span></span><br><span class="line">    EGLint numConfigs;</span><br><span class="line">    EGLConfig config;</span><br><span class="line">    EGLDisplay display = <span class="built_in">eglGetDisplay</span>(EGL_DEFAULT_DISPLAY);</span><br><span class="line">    <span class="built_in">eglInitialize</span>(display, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">eglChooseConfig</span>(display, attribs, &amp;config, <span class="number">1</span>, &amp;numConfigs);</span><br><span class="line">    <span class="comment">// 创建eglSurface</span></span><br><span class="line">    EGLSurface eglSurface;</span><br><span class="line">    eglSurface = <span class="built_in">eglCreateWindowSurface</span>(display, config, surface.<span class="built_in">get</span>(), <span class="literal">NULL</span>);</span><br><span class="line">    EGLContext context;</span><br><span class="line">    context = <span class="built_in">eglCreateContext</span>(display, config, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    EGLint w, h;</span><br><span class="line">    <span class="built_in">eglQuerySurface</span>(display, eglSurface, EGL_WIDTH, &amp;w);</span><br><span class="line">    <span class="built_in">eglQuerySurface</span>(display, eglSurface, EGL_HEIGHT, &amp;h);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里会调用dequeue以获取帧缓冲区buffer</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">eglMakeCurrent</span>(display, eglSurface, eglSurface, context) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glShadeModel</span>(GL_FLAT);</span><br><span class="line">    <span class="built_in">glDisable</span>(GL_DITHER);</span><br><span class="line">    <span class="built_in">glDisable</span>(GL_SCISSOR_TEST);</span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>); <span class="comment">// 这里用OpenGL库来绘制一个纯红的画面</span></span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里会调用到Surface的queueBuffer方法提交画好的帧缓冲区数据</span></span><br><span class="line">    <span class="built_in">eglSwapBuffers</span>(display, eglSurface);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sleep...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">10</span> * <span class="number">1000</span> * <span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">    surface.<span class="built_in">clear</span>();</span><br><span class="line">    surfaceControl.<span class="built_in">clear</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test complete. CTRL+C to finish.\n&quot;</span>);</span><br><span class="line">    IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">joinThreadPool</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟前面一样，需要先获取到 Surface，只是这里我们不再直接获取 buffer，而是把 Surface 对象给到 EGL 库，由 EGL 去使用它。我们使用 OpenGL 的 API 来间接操作帧缓冲区 buffer，这些操作包括申请新的 BufferQueue Slot 和提交绘制好的 BufferQueue slot。</p><h2 id="应用画面更新总结"><a class="markdownIt-Anchor" href="#应用画面更新总结"></a> 应用画面更新总结</h2><p>通过上述介绍，APP 的画面要显示到屏幕上大致上要经过如下步骤：</p><p>首先 App 向 SF 申请画布（通过 <code>dequeueBuffer()</code> 接口）。SF 内部有一个 BufferQueue 的管理实体，它会分配一个 GraphicBuffer 给到 APP，App 拿到 Buffer 后调用图形库在这块 Buffer 上绘画。</p><p>APP 绘画完成后向 SF 提交绘制完成的 Buffer（通过 <code>queueBuffer()</code> 接口)。当然这时候只是在 CPU 侧绘制完成，GPU 可能还在该 Buffer 上作画，因此这时向 SF 提交的数据还会带上一个 acquireFence，使得后续使用者能够知道该 Buffer 什么时候使用完毕了。</p><p>SF 收到应用提交的 Buffer 后在下一个 Vsync-sf 信号到来时做处理。首先遍历所有的 Layer，找到哪些 Layer 有上帧，通过 <code>acquireBuffer()</code> 把 Buffer 拿出来，再通知给 HWC Service 去合成，最后调用 HWC Service 的 <code>presentDisplay()</code> 接口来告知 HWC Service 其工作已完成。</p><p>HWC Service 收到合成任务后开始合成数据，调用 DRM 接口去将这帧画面显示到屏幕上。</p><p>至此，一帧画面的更新过程就完成了。</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://younghblog.gitee.io">Youngh</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://younghblog.gitee.io/posts/1916506233.html">https://younghblog.gitee.io/posts/1916506233.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://younghblog.gitee.io" target="_blank">YounghBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://img.gejiba.com/images/02444853758d96ea1ce979fcd95b7973.md.webp" data-sites="weibo,wechat,qq"></div><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn1.tianli0.top/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn1.tianli0.top/gh/exploreMeta/cdn/img/donate/wechat.webp" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn1.tianli0.top/gh/exploreMeta/cdn/img/donate/wechat.webp" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn1.tianli0.top/gh/exploreMeta/cdn/img/donate/alipay.webp" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn1.tianli0.top/gh/exploreMeta/cdn/img/donate/alipay.webp" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/2031896266.html"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/3d23f7fc9501aa22402a02666b09e892.md.webp" onerror='onerror=null,src="https://img.gejiba.com/images/4f60b4e053a96873d937752732c06a09.gif"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Binder机制</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/3cb1dc95c490420f129fb73888c41e12.md.webp" onerror='this.onerror=null,this.src="https://img.gejiba.com/images/4f60b4e053a96873d937752732c06a09.gif"' alt="avatar"></div><div class="author-info__name">Youngh</div><div class="author-info__description">Stay hungry, stay foolish</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://gitee.com/younghblog"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="tencent://AddContact/?fromId=50&amp;fromSubId=1&amp;subcmd=all&amp;uin=1413483899" target="_blank"><i class="fa-brands fa-qq"></i></a><a class="social-icon" href="mailto:1413483899@qq.com" target="_blank"><i class="fa-solid fa-envelope"></i></a><a class="social-icon" href="/rss2.xml" target="_blank"><i class="fa-solid fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>O.O</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">预备知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E7%9A%84%E5%B8%A7%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">2.</span> <span class="toc-text">用户空间的帧数据流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bufferqueue"><span class="toc-number">3.</span> <span class="toc-text">BufferQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bufferstate%E7%9A%84%E5%88%87%E6%8D%A2"><span class="toc-number">3.1.</span> <span class="toc-text">BufferState的切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bufferslot"><span class="toc-number">3.2.</span> <span class="toc-text">BufferSlot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bufferqueue%E6%9E%84%E9%80%A0"><span class="toc-number">3.3.</span> <span class="toc-text">BufferQueue构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E8%8E%B7%E5%8F%96graphicbuffer"><span class="toc-number">3.4.</span> <span class="toc-text">应用获取GraphicBuffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#buffer%E7%AE%A1%E7%90%86"><span class="toc-number">3.5.</span> <span class="toc-text">Buffer管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.6.</span> <span class="toc-text">代码接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">3.7.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fence"><span class="toc-number">4.</span> <span class="toc-text">Fence</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89fence"><span class="toc-number">4.1.</span> <span class="toc-text">为什么要有Fence</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8Ebufferqueue%E7%9A%84%E5%8D%8F%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">与BufferQueue的协作方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81"><span class="toc-number">4.2.1.</span> <span class="toc-text">相关代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%BB%E9%9D%A2%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">画面更新流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%BB%E5%B8%83%E7%9A%84%E7%94%B3%E8%AF%B7"><span class="toc-number">5.1.</span> <span class="toc-text">画布的申请</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#createsurfacelocked"><span class="toc-number">5.1.1.</span> <span class="toc-text">createSurfaceLocked()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getsurfacecontrol"><span class="toc-number">5.1.2.</span> <span class="toc-text">getSurfaceControl()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-number">5.1.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%98%E5%88%B6%E8%BF%87%E7%A8%8B"><span class="toc-number">5.2.</span> <span class="toc-text">帧数据的绘制过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8F%90%E4%BA%A4%E8%BF%87%E7%A8%8B"><span class="toc-number">5.3.</span> <span class="toc-text">帧数据的提交过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-3"><span class="toc-number">5.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E6%98%AF%E5%A6%82%E4%BD%95%E7%BB%98%E5%9B%BE%E7%9A%84"><span class="toc-number">6.</span> <span class="toc-text">应用是如何绘图的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%9B%BE%E5%BD%A2%E5%BA%93%E6%94%AF%E6%8C%81%E4%B8%8B%E7%9A%84%E7%BB%98%E5%9B%BE"><span class="toc-number">6.1.</span> <span class="toc-text">无图形库支持下的绘图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%9B%BE%E5%BD%A2%E5%BA%93%E6%94%AF%E6%8C%81%E4%B8%8B%E7%9A%84%E7%BB%98%E5%9B%BE"><span class="toc-number">6.2.</span> <span class="toc-text">有图形库支持下的绘图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8openglegl%E7%9A%84%E7%BB%98%E5%9B%BE"><span class="toc-number">6.3.</span> <span class="toc-text">使用OpenGL&amp;EGL的绘图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%94%BB%E9%9D%A2%E6%9B%B4%E6%96%B0%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">应用画面更新总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/1916506233.html" title="Android画面显示流程"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/02444853758d96ea1ce979fcd95b7973.md.webp" onerror='this.onerror=null,this.src="https://img.gejiba.com/images/4f60b4e053a96873d937752732c06a09.gif"' alt="Android画面显示流程"></a><div class="content"><a class="title" href="/posts/1916506233.html" title="Android画面显示流程">Android画面显示流程</a><time datetime="2022-10-08T15:44:58.000Z" title="发表于 2022-10-08 23:44:58">2022-10-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2031896266.html" title="Binder机制"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/3d23f7fc9501aa22402a02666b09e892.md.webp" onerror='this.onerror=null,this.src="https://img.gejiba.com/images/4f60b4e053a96873d937752732c06a09.gif"' alt="Binder机制"></a><div class="content"><a class="title" href="/posts/2031896266.html" title="Binder机制">Binder机制</a><time datetime="2022-09-25T01:08:18.000Z" title="发表于 2022-09-25 09:08:18">2022-09-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2872386792.html" title="JNI学习"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/788496e432e69da44ecda3baa70659f5.md.webp" onerror='this.onerror=null,this.src="https://img.gejiba.com/images/4f60b4e053a96873d937752732c06a09.gif"' alt="JNI学习"></a><div class="content"><a class="title" href="/posts/2872386792.html" title="JNI学习">JNI学习</a><time datetime="2022-09-21T15:15:22.000Z" title="发表于 2022-09-21 23:15:22">2022-09-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3659942439.html" title="Android渲染的整体架构"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/eb8d19563d07ccc303ce96f0da4a25af.md.webp" onerror='this.onerror=null,this.src="https://img.gejiba.com/images/4f60b4e053a96873d937752732c06a09.gif"' alt="Android渲染的整体架构"></a><div class="content"><a class="title" href="/posts/3659942439.html" title="Android渲染的整体架构">Android渲染的整体架构</a><time datetime="2022-09-04T13:11:29.000Z" title="发表于 2022-09-04 21:11:29">2022-09-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1441608745.html" title="「高效能人士的七个习惯」读书笔记"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/b60a19efb0970a66b87460015b04961c.md.webp" onerror='this.onerror=null,this.src="https://img.gejiba.com/images/4f60b4e053a96873d937752732c06a09.gif"' alt="「高效能人士的七个习惯」读书笔记"></a><div class="content"><a class="title" href="/posts/1441608745.html" title="「高效能人士的七个习惯」读书笔记">「高效能人士的七个习惯」读书笔记</a><time datetime="2022-07-08T12:39:21.000Z" title="发表于 2022-07-08 20:39:21">2022-07-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022&nbsp;&nbsp;&nbsp;<i style="color:#ff6a6a;animation:announ_animation .8s linear infinite" class="fas fa-heart"></i>&nbsp;&nbsp;&nbsp;By Youngh</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="https://www.antmoe.com/js/utils.js"></script><script src="https://www.antmoe.com/js/main.js"></script><script src="https://cdn1.tianli0.top/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://cdn.staticfile.org/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="https://www.antmoe.com/js/search/local-search.js" defer></script><div class="js-pjax"><script>function loadValine(){function n(){new Valine(Object.assign({el:"#vcomment",appId:"fUqvuCwXzFgVcGgakVuftjjg-gzGzoHsz",appKey:"44H71E23JXOW8dMVSkYGsmAG",avatar:"monsterid",serverURLs:"",emojiMaps:"",path:window.location.pathname,visitor:!1},null))}"function"==typeof Valine?n():getScript("https://cdn1.tianli0.top/npm/valine/dist/Valine.min.js").then(n)}function loadOtherComment(){loadValine()}btf.loadComment(document.getElementById("vcomment"),loadValine)</script></div><script src="https://cdn1.tianli0.top/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script id="click-heart" src="https://cdn1.tianli0.top/npm/butterfly-extsrc@1/dist/click-heart.min.js" async mobile="false"></script><script src="https://cdn.casecori.top/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.tocScrollFn&&window.removeEventListener("scroll",window.tocScrollFn),window.scrollCollect&&window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),document.getElementById("rightside").style.cssText="opacity: ''; transform: ''",window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script");var o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script></div></body></html>