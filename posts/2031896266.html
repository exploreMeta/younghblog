<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Binder机制 | YounghBlog</title><meta name="author" content="Youngh"><meta name="copyright" content="Youngh"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Binder 是 Android 提供的跨进程通信机制。Android 系统是基于 Linux 内核的，Linux 已经拥有 FIFO、管道、信号，到后来的信号量、消息队列、共享内存，再到 eventfd、mmap 内存映射、Socket 等等，但是 Android 却采用了 Binder 这种不同上述几种类型的特有机制，原因有很多，比如性能优化、安全、可扩展性等等。  Binder的优势  性能"><meta property="og:type" content="article"><meta property="og:title" content="Binder机制"><meta property="og:url" content="https://younghblog.gitee.io/posts/2031896266.html"><meta property="og:site_name" content="YounghBlog"><meta property="og:description" content="Binder 是 Android 提供的跨进程通信机制。Android 系统是基于 Linux 内核的，Linux 已经拥有 FIFO、管道、信号，到后来的信号量、消息队列、共享内存，再到 eventfd、mmap 内存映射、Socket 等等，但是 Android 却采用了 Binder 这种不同上述几种类型的特有机制，原因有很多，比如性能优化、安全、可扩展性等等。  Binder的优势  性能"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img.gejiba.com/images/3d23f7fc9501aa22402a02666b09e892.md.webp"><meta property="article:published_time" content="2022-09-25T01:08:18.000Z"><meta property="article:modified_time" content="2022-09-25T01:31:52.081Z"><meta property="article:author" content="Youngh"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img.gejiba.com/images/3d23f7fc9501aa22402a02666b09e892.md.webp"><link rel="shortcut icon" href="https://cdn1.tianli0.top/gh/exploreMeta/cdn/img/logo/favicon.ico"><link rel="canonical" href="https://younghblog.gitee.io/posts/2031896266"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="stylesheet" href="https://jokerdig.com/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.0.0/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:300},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn1.tianli0.top/npm/flickr-justified-gallery@2/dist/fjGallery.min.js",css:"https://cdn1.tianli0.top/npm/flickr-justified-gallery@2/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Binder机制",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-09-25 09:31:52"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a*=864e5,t={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(t)))},get:function(e){var t=localStorage.getItem(e);if(t){if(t=JSON.parse(t),!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=e=>new Promise((t,a)=>{const o=document.createElement("script");o.src=e,o.async=!0,o.onerror=a,o.onload=o.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(o.onload=o.onreadystatechange=null,t())},document.head.appendChild(o)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")},"dark"===(e=saveToLocal.get("theme"))?activateDarkMode():"light"===e&&activateLightMode(),void 0!==(e=saveToLocal.get("aside-status"))&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside")),/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/exploreMeta/cdn/css/index.min.css"><link rel="stylesheet" href="https://jokerdig.com/css/index.css"><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/exploreMeta/cdn/css/haa.css"><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/rss2.xml" title="YounghBlog" type="application/rss+xml"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/3cb1dc95c490420f129fb73888c41e12.md.webp" onerror='onerror=null,src="https://img.gejiba.com/images/4f60b4e053a96873d937752732c06a09.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://img.gejiba.com/images/3d23f7fc9501aa22402a02666b09e892.md.webp)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">YounghBlog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Binder机制</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-25T01:08:18.000Z" title="发表于 2022-09-25 09:08:18">2022-09-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-25T01:31:52.081Z" title="更新于 2022-09-25 09:31:52">2022-09-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Android%E5%9F%BA%E7%A1%80/">Android基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>Binder 是 Android 提供的跨进程通信机制。Android 系统是基于 Linux 内核的，Linux 已经拥有 FIFO、管道、信号，到后来的信号量、消息队列、共享内存，再到 eventfd、mmap 内存映射、Socket 等等，但是 Android 却采用了 Binder 这种不同上述几种类型的特有机制，原因有很多，比如性能优化、安全、可扩展性等等。</p><h2 id="binder的优势"><a class="markdownIt-Anchor" href="#binder的优势"></a> Binder的优势</h2><h3 id="性能优化"><a class="markdownIt-Anchor" href="#性能优化"></a> 性能优化</h3><p>在传统的Linux IPC方式中：</p><ul><li><p>socket 作为一款通用接口，其传输效率低、开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。</p></li><li><p>消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。</p></li><li><p>共享内存虽然无需拷贝，但控制复杂，难以使用。</p></li></ul><p>例如，Client 要将一块内存数据传递给 Server，一般的做法是，Client 将这块数据从它的进程空间拷贝到内核空间中，然后内核再将这个数据从内核空间拷贝到 Server 的进程空间，这样，Server 就可以访问这个数据了。但是在这种方法中，执行了两次内存拷贝操作。</p><p>为了性能考虑，Binder 在设计时，采用了 mmap 内存映射这种方式来进行数据的传输。只需要把 Client 进程空间的数据拷贝一次到内核空间，然后 Server 与内核共享这个数据就可以了，整个过程只需要执行一次内存拷贝，提高了效率。同时这样更有C/S架构的模型，方便管理。</p><h3 id="安全性"><a class="markdownIt-Anchor" href="#安全性"></a> 安全性</h3><p>Android 作为一个开放式、拥有众多开发者的的平台，应用程序的来源广泛，确保智能终端的安全是非常重要的。终端用户不希望从网上下载的程序在不知情的情况下偷窥隐私数据、连接无线网络、长期操作底层设备导致电池很快耗尽等等。传统IPC没有任何安全措施，完全依赖上层协议来确保。</p><p>首先传统 IPC 的接收方无法获得对方进程可靠的 UID/PID（用户ID/进程ID），从而无法鉴别对方身份。Android 为每个安装好的应用程序分配了自己的 UID，故进程的 UID 是鉴别进程身份的重要标志。使用传统 IPC 只能由用户在数据包里填入 UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标记只能由 IPC 机制本身在内核中添加。</p><p>其次传统 IPC 访问接入点是开放的，无法建立私有通道。比如命名管道的名称、system V 的键值、socket 的 ip 地址或文件名都是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。</p><p>基于以上原因，Android 需要建立一套新的 IPC 机制来满足系统对通信方式的安全性，这就是 Binder。Binder 为发送方添加 UID/PID 身份，这样在进程间通信时，可以通过进程 ID 进行相应的权限控制，既支持实名 Binder 也支持匿名 Binder，安全性高。</p><h3 id="可扩展和低耦合"><a class="markdownIt-Anchor" href="#可扩展和低耦合"></a> 可扩展和低耦合</h3><p>Binder 的可扩展和低耦合体现在两个方面的架构上：一是它的 C/S 架构设计，Clinet 和 Server 都容易扩展，想要扩展通信，只需要增加 Client 或者 Server 就可以了，而不用去管中间的通信流程。二是基于驱动的架构设计，只需要新增一个虚拟设备，就可以很容易的实现扩展 Binder 通信的范围。</p><h2 id="binder的通信方式"><a class="markdownIt-Anchor" href="#binder的通信方式"></a> Binder的通信方式</h2><p>与其它 IPC 不同，Binder 使用了面向对象的思想：Binder 是一个实体位于 Server 中的对象，该对象提供了一套方法用以实现对服务的请求，就像类的成员函数。遍布于 Client 中的入口可以看成指向这个 Binder 对象的指针，一旦获得了这个指针就可以调用该对象的方法访问 Server。在 Client 看来，通过 Binder 指针调用其提供的方法和通过指针调用其它任何本地对象的方法并无区别，尽管前者的实体位于远端 Server 中，而后者实体位于本地内存中。</p><p><strong>指针</strong>是 Native 的术语，换成 Java 的说法是<strong>引用</strong>，即 Client 通过 Binder 的引用访问 Server。</p><p>如果借用 Windows 系统开发的一个术语<strong>句柄</strong>也可以用来表述 Binder 在 Client 中的存在方式。</p><p>从通信的角度看，Client 中的 Binder 也可以看作是 Server Binder 的<strong>代理</strong>，在本地代表远端 Server 为 Client 提供服务。</p><blockquote><p>面向对象思想的引入将进程间通信转化为通过对某个 Binder 对象的引用调用该对象的方法，其独特之处在于 Binder 对象是一个可以跨进程引用的对象，它的实体位于一个进程中，而它的引用却遍布于系统的各个进程之中。</p><p>最诱人的是，这个引用和 Java 里引用一样既可以是强类型，也可以是弱类型，而且可以从一个进程传给其它进程，让大家都能访问同一 Server，就像将一个对象或引用赋值给另一个引用一样。</p><p>Binder 模糊了进程边界，淡化了进程间通信过程，整个系统仿佛运行于同一个面向对象的程序之中。形形色色的 Binder 对象以及星罗棋布的引用仿佛粘合各个应用程序的胶水，这也是 Binder 在英文里的原意。</p></blockquote><p>当然面向对象只是针对应用程序而言，对于 Binder 驱动和内核其它模块来说需要使用 C 语言实现，没有类和对象的概念。Binder 驱动为面向对象的进程间通信提供底层支持。</p><h2 id="binder通信模型"><a class="markdownIt-Anchor" href="#binder通信模型"></a> Binder通信模型</h2><p>从英文字面意思来看，Binder 是粘合剂。那么它把什么东西粘合在一起呢？在 Android 系统的 Binder 机制中，由一系列组件组成，分别是 Client、Server、Service Manager 和 Binder 驱动程序，其中 Client、Server 和 Service Manager 运行在用户空间，Binder 驱动程序运行内核空间。Binder 就是一种把这四个组件粘合在一起的粘合剂了。其中，核心组件便是 Binder 驱动程序了，Service Manager 提供了辅助管理的功能，Client 和 Server 正是在 Binder 驱动和 ServiceManager 提供的基础设施上进行通信。这四个角色的关系和互联网类似：Server 是服务器，Client 是客户终端，Service Manager 是域名服务器（DNS），Binder 驱动是路由器。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/4019127953f3663aef32e0b5de3b20c4.webp" alt="image-20220924224900315"></p><ul><li><p>Client、Server 和 ServiceManager 存在于用户空间中，Binder 驱动在内核空间中。</p></li><li><p>Binder 驱动提供设备文件 <code>/dev/binder</code> 与用户空间进行交互。</p></li><li><p>Client、Server 和 ServiceManager 通过系统调用 <code>open()</code> 和 <code>ioctl()</code> 等操作与 Binder 驱动进行通信。</p></li><li><p>ServiceManager 是一个守护进程，用来管理 Server，并向 Client 提供查询 Server 接口的能力。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/a305e1812fbf394de7429b547b41fe37.webp" alt="img"></p></li></ul><blockquote><p><code>open()</code> 用来打开设备文件；<code>ioctl()</code> 用于对设备文件实现读、写等一些扩展功能。</p></blockquote><h3 id="binder驱动"><a class="markdownIt-Anchor" href="#binder驱动"></a> Binder驱动</h3><p>Binder 驱动设备是真正分配内存空间用来存放通信数据的部分。Binder 是虚拟设备的驱动，因此不是对物理设备的操作，而是功能逻辑操作：它工作于内核态，提供 <code>open()</code>、<code>mmap()</code>、<code>poll()</code>、<code>ioctl()</code> 等标准文件操作，以字符驱动设备中的misc设备注册在设备目录 <code>/dev</code> 下，用户可以通过 <code>/dev/binder</code> 访问到它。</p><p>驱动负责进程之间 Binder 通信的建立、Binder 在进程之间的传递、Binder 引用计数管理、数据包在进程之间的传递和交互等一系列底层支持。驱动和应用程序之间定义了一套接口协议，主要功能由 <code>ioctl()</code> 接口实现。</p><p>Binder IPC 正是基于 mmap 来实现的。Client 要向 Server 发送数据时：</p><ul><li>Client 进程通过 <code>copy_from_user()</code> 将数据从用户空间拷贝到内核空间；</li><li>Server 进程通过 mmap 将内核空间的内存地址映射到其用户空间；</li><li>只要 Client 将数据拷贝到内核空间，那么 Server 进程就可以直接读取到内核空间的数据，无需再次拷贝。</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/982d38b5a067fc6f395d1f7e9fe391de.webp" alt="image-20220924225149023"></p><h3 id="servicemanager和实名binder"><a class="markdownIt-Anchor" href="#servicemanager和实名binder"></a> ServiceManager和实名Binder</h3><p>Server 创建了 Binder 实体，为其取一个字符形式的可读易记的名字（张三），将这个 Binder 连同名字以数据包的形式发送给 ServiceManager，通知其注册一个名叫张三的 Binder，并且位于某个 Server 中。驱动为这个 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字及新建的引用打包传递给 ServiceManager。ServiceManager 收到数据包后，从中取出名字和引用填入一张查找表中。</p><p>与 DNS 类似，ServiceManager 的作用就是将字符形式的 Binder 名字（张三）转化成 Client 中对该 Binder 的引用，使得 Client 能够通过 Binder 名字获得对 Server 中 Binder 实体的引用。注册了名字的 Binder 叫<strong>实名 Binder</strong>。</p><p>这里存在的问题就是：ServiceManager 是一个进程，Server 是另一个进程，Server 向 ServiceManager 注册 Binder 必然会涉及进程间通信。当前实现的是进程间通信却要用到进程间通信，这就出现了鸡生蛋蛋生鸡的问题。</p><p>Binder 的解决比较巧妙：预先创造一只鸡用来生蛋：ServiceManager 和其它进程同样采用 Binder 通信，ServiceManager 是 Server 端，有自己的 Binder 对象（预先造好的鸡），其它进程都是 Client，需要通过这个 Binder 的引用来实现 Binder 的注册、查询和获取。</p><p>ServiceManager 提供的 Binder 比较特殊，它没有名字也不需要注册，当一个进程使用 <code>BINDER_SET_CONTEXT_MGR</code> 命令将自己注册成 ServiceManager 时，Binder 驱动会自动为它创建 Binder 实体（预先造好的鸡）；其次这个 Binder 的引用在所有 Client 中都固定为 0 而无须通过其它手段获得。也就是说，一个 Server 若要向 ServiceManager 注册自己的 Binder 就必需通过 0（即 NULL 指针）这个引用号与 ServiceManager 的 Binder 通信。注意这里说的 Client 是相对 ServiceManager 而言的，一个应用程序可能是个提供服务的 Server，但对 ServiceManager 来说它仍然是个 Client。</p><h3 id="client获得实名binder的引用"><a class="markdownIt-Anchor" href="#client获得实名binder的引用"></a> Client获得实名Binder的引用</h3><p>Server 向 ServiceManager 注册了 Binder 实体及其名字后，Client 就可以通过名字获得该 Binder 的引用了。Client 也利用保留的 0 号引用向 ServiceManager 请求访问某个 Binder：我申请获得名字叫张三的 Binder 的引用。ServiceManager 收到这个连接请求，从请求数据包里获得 Binder 的名字，在查找表里找到该名字对应的条目，从条目中取出 Binder 对应 Server 地址，作为回复发送给发起请求的 Client。</p><h3 id="匿名binder"><a class="markdownIt-Anchor" href="#匿名binder"></a> 匿名Binder</h3><p>并不是所有 Binder 都需要注册到 ServiceManager 中广而告之的。Server 端可以通过已经建立的 Binder 连接将创建的 Binder 实体传给 Client，当然这条已经建立的 Binder 连接必须通过实名 Binder 实现。由于这个 Binder 实体没有向 ServiceManager 注册名字，所以是个匿名 Binder。Client 将会收到这个匿名 Binder 的引用，通过这个引用向位于 Server 中的实体发送请求。匿名 Binder 为通信双方建立一条私密通道，只要 Server 没有把匿名 Binder 发给别的进程，别的进程就无法通过穷举或猜测等任何方式获得该 Binder 的引用，向该 Binder 发送请求。</p><h2 id="binder机制跨进程原理"><a class="markdownIt-Anchor" href="#binder机制跨进程原理"></a> Binder机制跨进程原理</h2><p>我们已经知道了 Binder 通信过程中的四个角色: Client、Server、ServiceManager 和 Driver，但还不清楚 Client 到底是如何与 Server 完成通信的。</p><p>虽然 Binder 用到了面向对象的思想，但并不限制应用程序一定要使用面向对象的语言，无论 C 还是 C++ 都可以很容易的使用Binder来通信。Binder 本质上只是一种底层通信方式，和具体服务没有关系。为了提供具体服务，Server 必须提供一套接口函数以便 Client 通过远程访问使用各种服务。这时通常采用 Proxy 设计模式：将接口函数定义在一个抽象类中，Server 和 Client 都会以该抽象类为基类实现所有接口，所不同的是 Server 端是真正的功能实现，而 Client 端是对这些函数远程调用请求的包装。</p><p>Client、Server、ServiceManager 位于用户空间的不同进程，不可进行进程间交互，所以它们都通过是 Binder 驱动进行交互的，所以真正的交互过程为：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/a9df5661d5916527714c6dcabaf0a824.webp" alt="img"></p><p>下面再详细说一下 Client 进程和 Server 进程是如何通过 Binder 驱动进行交互的。</p><ol><li>Server 进程启动之后，会进入中断等待状态，等待 Client 的请求。</li><li>当 Client 需要和 Server 通信时，会将请求发送给 Binder 驱动。</li><li>Binder 驱动收到请求之后，会唤醒 Server 进程。</li><li>同时，Binder 驱动会返回消息给 Client，告诉 Client：它发送给 Binder 驱动的请求，Binder 驱动已经接收到了。</li><li>Client 将请求发送成功后，就进入等待状态，等待 Server 的回复。</li><li>Binder 驱动唤醒 Server 后，就将请求转发给 Server 进程。</li><li>Server 进程解析出请求的内容，并将回复内容发送给 Binder 驱动。</li><li>Binder 驱动收到回复之后，唤醒 Client 进程。</li><li>同时，Binder 驱动会返回消息给 Server，告诉 Server：它发送给 Binder 驱动的回复，Binder 驱动已经收到。</li><li>Server 将回复发送成功后，就再次进入等待状态，继续等待 Client 的请求。</li><li>最终，Binder 驱动将回复转发给 Client。</li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/b19d47ea42337f28d23e24114a388e73.webp" alt="img"></p><h2 id="环境初始化"><a class="markdownIt-Anchor" href="#环境初始化"></a> 环境初始化</h2><p>Binder 机制要运行起来，必须先进行环境的初始化工作。</p><h3 id="binder驱动初始化"><a class="markdownIt-Anchor" href="#binder驱动初始化"></a> Binder驱动初始化</h3><p>这个过程是在 kernel 的 <code>binder.c</code> 中完成的，这里就不展开了。经历完这个步骤之后，Client 和 Server 才能使用 Binder 实现跨进程通信。</p><h3 id="servicemanager服务初始化"><a class="markdownIt-Anchor" href="#servicemanager服务初始化"></a> ServiceManager服务初始化</h3><p>开机启动时由 init 进程 解析 <code>init.rc</code> 启动 <code>servicemanager.rc</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frameworks/native/cmds/servicemanager/servicemanager.rc</span></span><br><span class="line">service servicemanager /system/bin/servicemanager</span><br><span class="line">    ...</span><br><span class="line">    onrestart class_restart --only-enabled main</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>该文件的启动会调用当前目录下的 main 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/cmds/servicemanager/main.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 打开/dev/binder设备，并通过mmap将该设备的内存空间映射到ServiceManager进程中</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* driver = argc == <span class="number">2</span> ? argv[<span class="number">1</span>] : <span class="string">&quot;/dev/binder&quot;</span>;</span><br><span class="line">    sp&lt;ProcessState&gt; ps = ProcessState::<span class="built_in">initWithDriver</span>(driver);</span><br><span class="line">    ...</span><br><span class="line"> <span class="comment">// 创建ServiceManager对象，然后将其注册到ServiceManager服务中</span></span><br><span class="line">    sp&lt;ServiceManager&gt; manager = sp&lt;ServiceManager&gt;::<span class="built_in">make</span>(std::<span class="built_in">make_unique</span>&lt;Access&gt;());</span><br><span class="line">    <span class="keyword">if</span> (!manager-&gt;<span class="built_in">addService</span>(<span class="string">&quot;manager&quot;</span>, manager, <span class="literal">false</span> <span class="comment">/*allowIsolated*/</span>,</span><br><span class="line">                             IServiceManager::DUMP_FLAG_PRIORITY_DEFAULT).<span class="built_in">isOk</span>()) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Could not self register servicemanager&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">setTheContextObject</span>(manager);</span><br><span class="line">    <span class="comment">// 将ServiceManager设置为ContextManager</span></span><br><span class="line">    ps-&gt;<span class="built_in">becomeContextManager</span>();</span><br><span class="line"></span><br><span class="line">    sp&lt;Looper&gt; looper = Looper::<span class="built_in">prepare</span>(<span class="literal">false</span> <span class="comment">/*allowNonCallbacks*/</span>);</span><br><span class="line">    BinderCallback::<span class="built_in">setupTo</span>(looper);</span><br><span class="line">    ClientCallbackCallback::<span class="built_in">setupTo</span>(looper, manager);</span><br><span class="line"> <span class="comment">// ServiceManager服务进入循环，等待接收数据来处理</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        looper-&gt;<span class="built_in">pollAll</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Binder 驱动已经初始化好了，因此该函数会直接打开 Binder 设备，并通过 <code>mmap()</code> 将 Binder 的内存空间映射到 ServiceManager 进程中。这里还将 ServiceManager 设置为了 ContextManager，然后进入循环等待接收数据。</p><p>第 6 行会触发 ProcessState 对象的创建，先看下其构造函数：</p><h4 id="processstate构造"><a class="markdownIt-Anchor" href="#processstate构造"></a> ProcessState构造</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/ProcessState.cpp</span></span><br><span class="line">ProcessState::<span class="built_in">ProcessState</span>(<span class="type">const</span> <span class="type">char</span>* driver)</span><br><span class="line">      : <span class="built_in">mDriverName</span>(<span class="built_in">String8</span>(driver)),</span><br><span class="line">        ...,</span><br><span class="line">        <span class="built_in">mCallRestriction</span>(CallRestriction::NONE) &#123;</span><br><span class="line">    base::Result&lt;<span class="type">int</span>&gt; opened = <span class="built_in">open_driver</span>(driver);</span><br><span class="line">    ...</span><br><span class="line">    mVMStart = <span class="built_in">mmap</span>(<span class="literal">nullptr</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, opened.<span class="built_in">value</span>(), <span class="number">0</span>);</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到构造函数中调用了 <code>open_driver()</code> 和 <code>mmap()</code> 这两个函数。<code>open_driver()</code> 的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/ProcessState.cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> base::Result&lt;<span class="type">int</span>&gt; <span class="title">open_driver</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* driver)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(driver, O_RDWR | O_CLOEXEC);</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">status_t</span> result = <span class="built_in">ioctl</span>(fd, BINDER_VERSION, &amp;vers);</span><br><span class="line">    ...</span><br><span class="line">    result = <span class="built_in">ioctl</span>(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数通过 <code>open()</code> 打开 Binder 设备文件，并通过 <code>ioctl()</code> 向 Binder 驱动查询或设置了一些信息，比如 <code>BINDER_VERSION</code>、<code>BINDER_SET_MAX_THREADS</code> 等操作。<code>ioctl()</code> 是用户空间与 Binder 内核空间交互的主要接口，其中一些重要的命令如下：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">BINDER_WRITE_READ</td><td style="text-align:left">该命令由用户空间向 Binder 驱动写入或者读取数据，里面包含写和读两个部分。当 write_size 不为 0 时，表示要将 write_buffer 里面的数据写入 Binder 驱动；当 read_size 不为 0 时，表示要从 Binder 驱动中读取数据到 read_buffer 中</td></tr><tr><td style="text-align:left">BINDER_SET_MAX_THREADS</td><td style="text-align:left">设置 Server 端线程池中支持的最大线程数，保存在 Binder 驱动的 binder_proc 结构体中。由于 Client 端是并发向 Server 发送请求的，所以 Server 端必须有线程池来处理并发请求。Binder 驱动中会记录 Client 端请求的线程数，若超过最大线程数，则不再处理 Client 端发来的请求</td></tr><tr><td style="text-align:left">BINDER_SET_CONTEXT_MGR</td><td style="text-align:left">该命令将当前进程设置为 ContextManager，最终会保存到 Binder 驱动的 binder_context 结构体中的变量 binder_context_mgr_node 中。由于系统中有且只能有一个 Context Manager，当 ServiceManager 服务在开机时启动并通过此命令将自己设置为 ContextManager 时，就可以保证 ServiceManager 是唯一且正确的 ContextManager</td></tr><tr><td style="text-align:left">BINDER_THREAD_EXIT</td><td style="text-align:left">Client 通知 Binder 驱动当前线程退出时发送此命令。如果 Client 端线程执行结束了，就会由线程 IPCThreadState 发送此命令来通知 Binder 驱动释放对应线程</td></tr><tr><td style="text-align:left">BINDER_VERSION</td><td style="text-align:left">获取 Binder 驱动的版本号。从用户空间打开 Binder 驱动时，会先获取该驱动的版本号，如果和用户空间中 Binder 驱动协议的版本号不一致，则驱动无法打开</td></tr></tbody></table><p><code>open()</code> 与 <code>mmap()</code> 都是 kernel 中的函数，这里就不展开分析了。</p><h4 id="becomecontextmanager"><a class="markdownIt-Anchor" href="#becomecontextmanager"></a> becomeContextManager()</h4><p>再回到 <a href="#ServiceManager%E6%9C%8D%E5%8A%A1%E5%88%9D%E5%A7%8B%E5%8C%96"><code>main()</code></a> 函数，第 17 行通过调用 ProcessState 的 <code>becomeContextManager()</code> 将 ServiceManager 设置为 ContextManager，下面就来看下这个函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/ProcessState.cpp</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ProcessState::becomeContextManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> unused = <span class="number">0</span>;</span><br><span class="line">    result = <span class="built_in">ioctl</span>(mDriverFD, BINDER_SET_CONTEXT_MGR, &amp;unused);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数通过 <code>ioctl()</code> 进行设置，具体细节这里不再展开。</p><h4 id="bindercallback"><a class="markdownIt-Anchor" href="#bindercallback"></a> BinderCallback</h4><p>在 <a href="#ServiceManager%E6%9C%8D%E5%8A%A1%E5%88%9D%E5%A7%8B%E5%8C%96"><code>main()</code></a> 函数中继续往下走，第 19 行创建了 Looper 对象，然后在第 20 行将该对象传入了 BinderCallback 的 <code>setupTo()</code> 中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;Looper&gt; looper = Looper::<span class="built_in">prepare</span>(<span class="literal">false</span> <span class="comment">/*allowNonCallbacks*/</span>);</span><br><span class="line">BinderCallback::<span class="built_in">setupTo</span>(looper);</span><br></pre></td></tr></table></figure><p>先来看一下 BinderCallback 的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/cmds/servicemanager/main.cpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinderCallback</span> : <span class="keyword">public</span> LooperCallback &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> sp&lt;BinderCallback&gt; <span class="title">setupTo</span><span class="params">(<span class="type">const</span> sp&lt;Looper&gt;&amp; looper)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">int</span> ret = looper-&gt;<span class="built_in">addFd</span>(binder_fd,</span><br><span class="line">                                Looper::POLL_CALLBACK,</span><br><span class="line">                                Looper::EVENT_INPUT,</span><br><span class="line">                                cb,</span><br><span class="line">                                <span class="literal">nullptr</span> <span class="comment">/*data*/</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> cb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">handleEvent</span><span class="params">(<span class="type">int</span> <span class="comment">/* fd */</span>, <span class="type">int</span> <span class="comment">/* events */</span>, <span class="type">void</span>* <span class="comment">/* data */</span>)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">handlePolledCommands</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// Continue receiving callbacks.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>setupTo()</code> 会将 Binder 的文件描述符 binder_fd 添加到 Looper 中，从而 Looper 可以监听 Binder 的消息，有消息到来时会触发 Looper 的 <code>POLL_CALLBACK</code>，进而会触发 <code>handleEvent()</code> 函数。</p><h2 id="解析binder框架"><a class="markdownIt-Anchor" href="#解析binder框架"></a> 解析Binder框架</h2><p>经过环境初始化后，Binder 驱动已经就绪，ServiceServer 服务也启动起来了，正在等待 Client 的请求。同时，ServiceManager 在 Binder 驱动中对应有一个 binder_proc 对象，以及一个 binder_node 结构体。</p><h3 id="框架中的主要结构体"><a class="markdownIt-Anchor" href="#框架中的主要结构体"></a> 框架中的主要结构体</h3><p>那么，用户进程是怎样跟 Binder 驱动进行沟通的？具体又是哪些类或者对象在其中起作用呢？</p><p>用户进程中跟 Binder 驱动离得最近的其实是 Native 层的 ProcessState 和 IPCThreadState。</p><ul><li>ProcessState 代表用户进程中的对象，每个用户进程有且只有一个 ProcessState 对象，属于单例。</li><li>IPCThreadState 代表用户进程中操作 Binder 的线程对象，主要通过 <code>transact()</code> 函数进行系统调用以实现与 Binder 驱动的沟通。其中系统调用主要使用的是 <code>ioctl()</code>，它承担了读和写的任务。</li></ul><p>当 ProcessState 对象创建时，会通过系统调用 <code>open()</code> 打开 Binder 驱动，并且在 Binder 驱动中创建对应的 <code>binder_proc</code> 结构体对象。如果有多个用户进程，在 Binder 驱动中就会存在多个 binder_proc 结构体对象，这些 binder_proc 对象保存在 binder_procs 链表中。</p><p>由于 Binder 驱动中可以并发处理用户进程的请求，所以每一个 binder_proc 对象中都有多个线程来处理请求业务。这些线程结构体为 binder_thread，它们以红黑树的形式保存在 threads 对象中。</p><p>每个 binder_proc 中的 todo 列表代表将要做的工作，同样地，每一个 binder_thread 结构体中也有一个 todo 列表。</p><p>不论是 ServiceManager 服务还是 Client 进程，它们跟 Binder 驱动交互都是使用的这些对象。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/7d9898015516ee104153ac83e18cc640.webp" alt="img"></p><h3 id="框架中传输的数据"><a class="markdownIt-Anchor" href="#框架中传输的数据"></a> 框架中传输的数据</h3><p>前面提到，<code>ioctl()</code> 既承担了写任务又承担了读任务，这主要依赖于传入它的参数 binder_write_read：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sys/bionic/libc/kernel/uapi/linux/android/binder.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binder_write_read</span> &#123;</span><br><span class="line"> <span class="type">binder_size_t</span> write_size;</span><br><span class="line"> <span class="type">binder_size_t</span> write_consumed;</span><br><span class="line"> <span class="type">binder_uintptr_t</span> write_buffer;</span><br><span class="line"> <span class="type">binder_size_t</span> read_size;</span><br><span class="line"> <span class="type">binder_size_t</span> read_consumed;</span><br><span class="line">    <span class="type">binder_uintptr_t</span> read_buffer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果 Client 要向 Binder 驱动发送数据，那么 Client 就会填充 binder_write_read 中的 write_size 和 write_buffer。当通过 <code>ioctl()</code> 调用到 Binder 驱动中时，Binder 驱动会先通过 <code>copy_from_user()</code> 将 Client 的 binder_write_read 数据拷贝到 Binder 驱动中的 binder_write_read，然后进行判断：如果其中的 write_size 大于 0，就说明 Client 要向 Binder 驱动发送数据，这时 Binder 驱动就会从 write_buffer 中将数据读出来进行处理，完成一次数据传递。</p><p>接下来再补充 Binder 中的一些重要概念。</p><h4 id="binder实体"><a class="markdownIt-Anchor" href="#binder实体"></a> Binder实体</h4><p>Binder 实体是各个 Server 和 ServiceManager 在内核中的表现形式，对应内核中的 binder_node。它的作用是在内核中保存 Server 和 ServiceManager 的信息，比如 Server 对象在用户空间的地址。</p><h4 id="binder引用"><a class="markdownIt-Anchor" href="#binder引用"></a> Binder引用</h4><p>Binder 引用是是 Client 在内核中的表现形式，对应内核中的 binder_ref，是对 Binder 实体的引用，通过它可以在内核中找到对应的 Binder 实体。</p><p>binder_node 和 binder_ref 都是内核中的数据结构，每个 Server 在内核中表现为一个 Binder 实体，而每一个 Client 则表现为一个 Binder 引用。这样，每个 Binder 引用都对应一个 Binder 实体，而每个 Binder 实体可以对应多个 Binder 引用。</p><h4 id="binder代理远程服务"><a class="markdownIt-Anchor" href="#binder代理远程服务"></a> Binder代理（远程服务）</h4><p>Binder 代理，也可叫做远程服务。Server 都是以服务的形式注册到 ServiceManager 中进行管理的。如果将 Server 看作本地服务的话，那么它在 Client 中的代理就是远程服务。通过该远程服务 Client 就能和 Server 进行通信。</p><p>Binder 框架中各对象之间的关系如下：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/5bc62371edd39e975d25ce270b353204.webp" alt="img"></p><h3 id="server在servicemanager中的存储"><a class="markdownIt-Anchor" href="#server在servicemanager中的存储"></a> Server在ServiceManager中的存储</h3><p>接下来看一下 Server 是如何在 ServiceManager 中存储的，以及 Client 是如何拿到 Server 进行调用的。</p><p>Server 通过 ServiceManager 的 <code>addService()</code> 保存到其列表中。ServiceManager 里面存储了很多服务，这些服务通过一个叫做 ServiceMap 的集合来保存：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/cmds/servicemanager/ServiceManager.h</span></span><br><span class="line"><span class="keyword">using</span> ServiceMap = std::map&lt;std::string, Service&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    sp&lt;IBinder&gt; binder; <span class="comment">// not null</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 std::string 表示服务的名字，Service 是服务本身，这样在 map 中就将服务名字和对应的服务映射起来了。</p><p>在 Service 结构体中，我们重点关注一下 binder。它是一个 IBinder 接口类型，那我们 Service 中的 binder 都是 IBinder 的实现吗？</p><p>接下来就以 ActivityManagerService 为例来看一下（注意：ManagerService 是 Service，ServiceManager 才是 Manager）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActivityManagerService</span> <span class="keyword">extends</span> <span class="title class_">IActivityManager</span>.Stub implements ... &#123;...&#125;</span><br></pre></td></tr></table></figure><p>ActivityManagerService 继承自 <code>IActivityManager.Stub</code>，而系统中没有 IActivityManager 的 Java 文件，只有 <code>IActivityManager.aidl</code>，因此需要通过系统编译来生成 <code>IActivityManager.java</code>。看下最终生成的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IActivityManager</span> <span class="keyword">extends</span> <span class="title class_">android</span>.os.IInterface&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Stub</span> <span class="keyword">extends</span> <span class="title class_">android</span>.os.Binder <span class="keyword">implements</span> <span class="title class_">android</span>.app.IActivityManager&#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>IActivityManager.Stub</code> 这个内部类继承自 <code>android.os.Binder</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/os/Binder.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Binder</span> <span class="keyword">implements</span> <span class="title class_">IBinder</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/core/java/android/os/IBinder.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IBinder</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p><code>android.os.Binder</code> 又实现了 <code>android.os.IBinder</code> 接口。继承关系如下：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/1fa71e39b3cef33b9f494d96cae880bd.webp" alt="image-20220924225739466"></p><p>其实，整个 Binder 架构在 Java、JNI、Native 层都有设计，如果按照 Client 和 Server 划分：</p><p>&lt; img src=&quot;…/…/Image/webp-166393380683522.webp&quot; alt=“img” style=“zoom:55%;” /&gt;</p><ul><li>在 Java 层，Client 要访问 Server，持有的是 BinderProxy 代理，在 Server 端是Binder。</li><li>在 Native 层，Client 端是 BpBinder 代理，在 Server 端是 BBinder。</li><li>Java 层和 Native 层之间通过 JNI 进行衔接。</li></ul><h3 id="对象传递方式"><a class="markdownIt-Anchor" href="#对象传递方式"></a> 对象传递方式</h3><p>我们知道，同进程内对象间的传递一般是传递引用，引用本质上是一个内存地址，但是对于跨进程通信，引用传递就不能使用了。因为虚拟内存的存在，不同的进程都有自己独立的内存空间，所以进程间传递地址值是无效的。这里就是涉及序列化与反序列化了。在 Android 中，最常用的就是 Parcel 了。在 Binder 进行跨进程通信时，通常会将数据打包到 Parcel 对象中，然后通过 Binder 驱动进行传递。</p><p>Parcel 的字面意思是打包，对于基本数据类型，如 string、int 等，可以直接写入到 Parcel 中，但实际传输过程并不会将这些基本数据类型传递过去，仍然是值传递。对于复杂的数据类型，则需要序列化和反序列化。例如，我们用一个传真机发送一个纸盒子到远方，先是将三维纸盒子展开成二维平面纸盒子，再通过传真机传真到远端，远端再将二维平面的纸盒子还原成一个三维的纸盒子，如下图所示：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/de763593a38156944d5ddc70a41ca1b1.png" alt="img"></p><p>具体实现的话，flatten 过程就是 Parcel 的 <code>writeStrongBinder()</code> 实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/Parcel.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::writeStrongBinder</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">flattenBinder</span>(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相应地，在远端需要有 unflatten 过程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/Parcel.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::readNullableStrongBinder</span><span class="params">(sp&lt;IBinder&gt;* val)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unflattenBinder</span>(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象打包好之后，在用户空间和内核空间之间传输，主要使用如下两个系统调用：</p><ul><li><code>copy_from_user()</code>：将数据包从用户空间复制到内核空间。</li><li><code>copy_to_user()</code>：将数据包从内核空间复制到用户空间。</li></ul><h2 id="ams注册到servicemanager"><a class="markdownIt-Anchor" href="#ams注册到servicemanager"></a> AMS注册到ServiceManager</h2><p>ServiceManager 服务启动后将自己设置为 ContextManager，即 Service 的大管家，这样后续启动的服务就可以通过 ServiceManager 来管理。每当 Client 需要使用 Server 的功能时，首先需要通过 ServiceManager 获取到这个 Server 服务，然后才能使用该 Server 的相关功能。</p><p>这里就以 ActivityManagerService（AMS） 这个 Service 为例，看下它是如何注册到 ServiceManager 中的，以及 Client 是如何调用它的。</p><p>AMS 是开机启动的系统服务，因此在开机阶段就已经将自己创建好，并设置到了 ServiceManager 中。</p><p>SystemServer 中的 <code>run()</code> 方法会启动系统的一些服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/java/com/android/server/SystemServer.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SystemServer</span> <span class="keyword">implements</span> <span class="title class_">Dumpable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SystemServer</span>().run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        startBootstrapServices(t);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startBootstrapServices</span><span class="params">(<span class="meta">@NonNull</span> TimingsTraceAndSlog t)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        mActivityManagerService = ActivityManagerService.Lifecycle.startService(</span><br><span class="line">                mSystemServiceManager, atm);</span><br><span class="line">        mActivityManagerService.setSystemProcess();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>startBootstrapServices()</code> 方法中首先创建了 AMS 实例，该实例最终的创建是在 <code>SystemServiceManager</code> 中进行的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActivityManagerService</span> <span class="keyword">extends</span> <span class="title class_">IActivityManager</span>.Stub &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Lifecycle</span> <span class="keyword">extends</span> <span class="title class_">SystemService</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> ActivityManagerService <span class="title function_">startService</span><span class="params">(</span></span><br><span class="line"><span class="params">                SystemServiceManager ssm, ActivityTaskManagerService atm)</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> ssm.startService(ActivityManagerService.Lifecycle.class).getService();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/SystemServiceManager.java</span></span><br><span class="line"><span class="keyword">public</span> SystemService <span class="title function_">startService</span><span class="params">(String className)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;SystemService&gt; serviceClass = loadClassFromLoader(className,</span><br><span class="line">            <span class="built_in">this</span>.getClass().getClassLoader());</span><br><span class="line">    <span class="keyword">return</span> startService(serviceClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">SystemService</span>&gt; T <span class="title function_">startService</span><span class="params">(Class&lt;T&gt; serviceClass)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    service = constructor.newInstance(mContext);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AMS 最终是通过 <code>newInstance()</code> 创建的。创建了 AMS 之后，接着调用了其 <a href="#AMS%E6%B3%A8%E5%86%8C%E5%88%B0ServiceManager"><code>setSystemProcess()</code></a> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSystemProcess</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    ServiceManager.addService(Context.ACTIVITY_SERVICE, <span class="built_in">this</span>, <span class="comment">/* allowIsolated= */</span> <span class="literal">true</span>,</span><br><span class="line">            DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PRIORITY_NORMAL | DUMP_FLAG_PROTO);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该方法中，将 ActivityManagerService 自身实例通过 <code>addService()</code> 注册到了 ServiceManager 中。</p><h2 id="两个进程间的通信"><a class="markdownIt-Anchor" href="#两个进程间的通信"></a> 两个进程间的通信</h2><p>在 Client 端，真正发起通信的是 <code>BinderProxy.transact()</code>，而 Server 端接收消息的是 <code>Binder.onTransact()</code>，因此我们从 <code>BinderProxy.transact()</code> 方法开始分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/os/BinderProxy.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">BinderProxy</span> <span class="keyword">implements</span> <span class="title class_">IBinder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">transact</span><span class="params">(<span class="type">int</span> code, Parcel data, Parcel reply, <span class="type">int</span> flags)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> transactNative(code, data, reply, flags);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 JNI 方法 <code>transactNative()</code> 进入 Native 层：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/android_util_Binder.cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> jboolean <span class="title">android_os_BinderProxy_transact</span><span class="params">(JNIEnv* env, jobject obj,</span></span></span><br><span class="line"><span class="params"><span class="function">        jint code, jobject dataObj, jobject replyObj, jint flags)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 从BinderProxyNativeData中获取IBinder指针（BpBinder）</span></span><br><span class="line">    IBinder* target = <span class="built_in">getBPNativeData</span>(env, obj)-&gt;mObject.<span class="built_in">get</span>();</span><br><span class="line">    <span class="type">status_t</span> err = target-&gt;<span class="built_in">transact</span>(code, *data, reply, flags);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了 BpBinder 的 <code>transact()</code> 方法，进去看一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/BpBinder.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BpBinder::transact</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data, Parcel* reply, <span class="type">uint32_t</span> flags)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    status = IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">transact</span>(<span class="built_in">binderHandle</span>(), code, data, reply, flags);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">BpBinder::binderHandle</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">get</span>&lt;BinderHandle&gt;(mHandle).handle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/native/libs/binder/IPCThreadState.cpp</span></span><br><span class="line"><span class="function">IPCThreadState* <span class="title">IPCThreadState::self</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存在则返回</span></span><br><span class="line">    <span class="keyword">if</span> (gHaveTLS.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">restart:</span><br><span class="line">        <span class="type">const</span> <span class="type">pthread_key_t</span> k = gTLS;</span><br><span class="line">        IPCThreadState* st = (IPCThreadState*)<span class="built_in">pthread_getspecific</span>(k);</span><br><span class="line">        <span class="keyword">if</span> (st) <span class="keyword">return</span> st;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IPCThreadState;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 不存在则创建</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;gTLSMutex);</span><br><span class="line">    <span class="keyword">if</span> (!gHaveTLS.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">        <span class="type">int</span> key_create_value = <span class="built_in">pthread_key_create</span>(&amp;gTLS, threadDestructor);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;gTLSMutex);</span><br><span class="line">    <span class="keyword">goto</span> restart;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了 IPCThreadState 的 <code>transact()</code> 方法，其中传入的 <code>binderHandle()</code> 是接收端 BBinder 的句柄。</p><p><code>IPCThreadState::self()</code> 用来获取当前线程的 IPCThreadState 单例，不存在则创建。我们先看一下 IPCThreadState 的构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/IPCThreadState.cpp</span></span><br><span class="line">IPCThreadState::<span class="built_in">IPCThreadState</span>()</span><br><span class="line">      : <span class="built_in">mProcess</span>(ProcessState::<span class="built_in">self</span>()),</span><br><span class="line">        ...,</span><br><span class="line">        <span class="built_in">mCallRestriction</span>(mProcess-&gt;mCallRestriction) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProcessState 是一个进程内的单例对象，同样地 <code>ProcessState::self()</code> 获取该对象，不存在则创建。实际上此处的 ProcessState 单例已经存在了，每个 App 进程在被 Zygote 进程 fork 出以后会调用到 <code>app_main.cpp</code> 中的 <code>onZygoteInit()</code> 函数，在这里会创建该进程的 ProcessState 并开启 Binder 线程池。下面我们从 <code>onZygoteInit()</code> 看下 Binder 的初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/cmds/app_process/app_main.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onZygoteInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建ProcessState单例</span></span><br><span class="line">    sp&lt;ProcessState&gt; proc = ProcessState::<span class="built_in">self</span>();</span><br><span class="line">    <span class="comment">// 启动Binder线程池</span></span><br><span class="line">    proc-&gt;<span class="built_in">startThreadPool</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建processstate"><a class="markdownIt-Anchor" href="#创建processstate"></a> 创建ProcessState</h4><p>这里通过单例模式创建了一个 ProcessState 对象，直接看下其构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/ProcessState.cpp</span></span><br><span class="line">ProcessState::<span class="built_in">ProcessState</span>(<span class="type">const</span> <span class="type">char</span>* driver)</span><br><span class="line">      : <span class="built_in">mDriverName</span>(<span class="built_in">String8</span>(driver)),</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">mCallRestriction</span>(CallRestriction::NONE) &#123;</span><br><span class="line">    ...</span><br><span class="line">    base::Result&lt;<span class="type">int</span>&gt; opened = <span class="built_in">open_driver</span>(driver);</span><br><span class="line">    mVMStart = <span class="built_in">mmap</span>(<span class="literal">nullptr</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE,</span><br><span class="line">                        opened.<span class="built_in">value</span>(), <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用 <code>open_driver()</code> 打开 Binder 驱动，然后通过 mmap 系统调用开启 Binder 驱动中用于接收数据的内存映射。</p><h4 id="开启binder线程池"><a class="markdownIt-Anchor" href="#开启binder线程池"></a> 开启Binder线程池</h4><p>由于每次完整的 Binder 通讯都需要循环读写驱动，在此过程中会阻塞当前线程，所以开启多个线程处理多任务是必然的选择。</p><p>ProcessState 创建时会开启一个新线程作为 Binder 主线程无限循环读 Binder 驱动，每当读到一个来自其他进程的通讯请求时，当前线程处理该请求，然后再创建一个线程作为 Binder 普通线程继续循环处理后续请求（不能超过 Binder 进程中的最大线程数），提高响应速度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/ProcessState.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ProcessState::startThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">spawnPooledThread</span>(<span class="literal">true</span>); <span class="comment">// 创建一个新线程</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ProcessState::spawnPooledThread</span><span class="params">(<span class="type">bool</span> isMain)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    sp&lt;Thread&gt; t = sp&lt;PoolThread&gt;::<span class="built_in">make</span>(isMain);</span><br><span class="line">    t-&gt;<span class="built_in">run</span>(name.<span class="built_in">string</span>()); <span class="comment">// 最终会调用到PoolThread::threadLoop()</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此时运行在新线程中，将新线程注册为Binder主线程</span></span><br><span class="line">    IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">joinThreadPool</span>(mIsMain);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PoolThread::run()</code> 经过一系列调用最后会调用到 <code>PoolThread::threadLoop()</code>。看下其中的 <code>joinThreadPool()</code> 方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/cmds/app_process/app_main.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onZygoteInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建ProcessState单例</span></span><br><span class="line">    sp&lt;ProcessState&gt; proc = ProcessState::<span class="built_in">self</span>();</span><br><span class="line">    <span class="comment">// 启动Binder线程池</span></span><br><span class="line">    proc-&gt;<span class="built_in">startThreadPool</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无限循环调用 <code>getAndExecuteCommand()</code> 来读取并处理命令，这里会进入 <code>BR_SPAWN_LOOPER</code> 分支：</p><h6 id="锚点1"><a class="markdownIt-Anchor" href="#锚点1"></a> 锚点1</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/IPCThreadState.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::getAndExecuteCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"> <span class="comment">// 与Driver通信</span></span><br><span class="line">    result = <span class="built_in">talkWithDriver</span>();</span><br><span class="line">    <span class="keyword">if</span> (result &gt;= NO_ERROR) &#123;</span><br><span class="line">        ...</span><br><span class="line">        cmd = mIn.<span class="built_in">readInt32</span>();</span><br><span class="line">        result = <span class="built_in">executeCommand</span>(cmd); <span class="comment">// 执行命令</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;BBinder&gt; the_context_object;</span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::executeCommand</span><span class="params">(<span class="type">int32_t</span> cmd)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> ((<span class="type">uint32_t</span>)cmd) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> BR_SPAWN_LOOPER:</span><br><span class="line">        <span class="comment">// 创建一个新线程，开启对Driver的循环监听</span></span><br><span class="line">        <span class="comment">// 这里isMain为false，所以会被注册为普通Binder线程</span></span><br><span class="line">        mProcess-&gt;<span class="built_in">spawnPooledThread</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BR_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">            binder_transaction_data&amp; tr = tr_secctx.transaction_data;</span><br><span class="line">            <span class="comment">// binder_transaction_data.cookie转为BBinder指针</span></span><br><span class="line">            <span class="comment">// 并调用BBinder的transact()方法将数据回传给Java层</span></span><br><span class="line">            error = <span class="built_in">reinterpret_cast</span>&lt;BBinder*&gt;(tr.cookie)-&gt;<span class="built_in">transact</span>(tr.code, buffer,</span><br><span class="line">                                                                    &amp;reply, tr.flags);</span><br><span class="line">            <span class="comment">// 向客户端发送reply</span></span><br><span class="line">            <span class="built_in">sendReply</span>(reply, (tr.flags &amp; kForwardReplyFlags));</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"> ...</span><br><span class="line">    &#125;</span><br><span class="line"> ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#%E9%94%9A%E7%82%B92">返回</a></p><p>分析了Binder的初始化，我们接着看 <code>IPCThreadState.transact()</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/IPCThreadState.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::transact</span><span class="params">(<span class="type">int32_t</span> handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  Parcel* reply, <span class="type">uint32_t</span> flags)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 对将要发送的数据进行封装</span></span><br><span class="line">    err = <span class="built_in">writeTransactionData</span>(BC_TRANSACTION, flags, handle, code, data, <span class="literal">nullptr</span>);</span><br><span class="line">    ...</span><br><span class="line">    err = <span class="built_in">waitForResponse</span>(reply); <span class="comment">// 向接收端发送数据并等待响应</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来看下 <code>writeTransactionData()</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/IPCThreadState.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::writeTransactionData</span><span class="params">(<span class="type">int32_t</span> cmd, <span class="type">uint32_t</span> binderFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int32_t</span> handle, <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data, <span class="type">status_t</span>* statusBuffer)</span> </span>&#123;</span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">    tr.target.ptr = <span class="number">0</span>;</span><br><span class="line">    tr.target.handle = handle; <span class="comment">// 服务端BBinder对应的句柄</span></span><br><span class="line">    tr.code = code;</span><br><span class="line">    tr.data.ptr.buffer = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(statusBuffer);</span><br><span class="line">    tr.data.ptr.offsets = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    mOut.<span class="built_in">writeInt32</span>(cmd); <span class="comment">// cmd是传入的BC_TRANSACTION</span></span><br><span class="line">    mOut.<span class="built_in">write</span>(&amp;tr, <span class="built_in">sizeof</span>(tr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将 Parcel、handle 等数据封装为 binder_transaction_data 结构体，然后将 <code>BC_TRANSACTION</code> 和此结构体写入 mOut（Parcel 类型），mOut 用于写入内核。再来看下 <code>waitForResponse()</code>：</p><h6 id="锚点3"><a class="markdownIt-Anchor" href="#锚点3"></a> 锚点3</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/IPCThreadState.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="type">status_t</span> *acquireResult)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> cmd;</span><br><span class="line">    <span class="type">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用talkWithDriver()</span></span><br><span class="line">        <span class="keyword">if</span> ((err=<span class="built_in">talkWithDriver</span>()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        err = mIn.<span class="built_in">errorCheck</span>();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.<span class="built_in">dataAvail</span>() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        cmd = (<span class="type">uint32_t</span>)mIn.<span class="built_in">readInt32</span>();</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            <span class="comment">// 这里reply为true，表示需要等待接收端的响应BR_TRANSACTION（即还没有等到）</span></span><br><span class="line">            <span class="comment">// 因此会走break跳出switch，但跳不出while(1)循环</span></span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BR_REPLY:</span><br><span class="line">            &#123;</span><br><span class="line">                binder_transaction_data tr;</span><br><span class="line">                err = mIn.<span class="built_in">read</span>(&amp;tr, <span class="built_in">sizeof</span>(tr));</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">finish:</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (acquireResult) *acquireResult = err;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;<span class="built_in">setError</span>(err);</span><br><span class="line">        mLastError = err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>talkWithDriver()</code> 函数真正与 Driver 进行通信：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/IPCThreadState.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::talkWithDriver</span><span class="params">(<span class="type">bool</span> doReceive)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 将mIn、mOut中的数据封装到binder_write_read结构体</span></span><br><span class="line">    binder_write_read bwr;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> outAvail = (!doReceive || needRead) ? mOut.<span class="built_in">dataSize</span>() : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (<span class="type">uintptr_t</span>)mOut.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        bwr.read_size = mIn.<span class="built_in">dataCapacity</span>();</span><br><span class="line">        bwr.read_buffer = (<span class="type">uintptr_t</span>)mIn.<span class="built_in">data</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 通过ioctl调用Driver层的读写函数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ioctl</span>(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Driver 层处理完返回，<code>talkWithDriver()</code> 处理完此次通讯也返回，回到 <code>IPCThreadState::waitForResponse()</code>，读取处理 mIn 中 Driver 写入的 <code>BR_TRANSACTION_COMPLETE</code> 对应的数据。</p><p>处理完 <code>BR_TRANSACTION_COMPLETE</code> 后，由于需要等待接收端的 reply，所以会继续循环 <code>talkWithDriver()</code>，等待 reply。</p><h6 id="锚点2"><a class="markdownIt-Anchor" href="#锚点2"></a> 锚点2</h6><p>当 Driver 层处理完返回时，会回到 <a href="#%E9%94%9A%E7%82%B91"><code>IPCThreadState::getAndExecuteCommand()</code></a>，接着 <code>talkWithDriver()</code> 往下执行，读取 mIn 中来自 Driver 的数据，调用 <a href="#%E9%94%9A%E7%82%B91"><code>executeCommand()</code></a> 进行处理。</p><p>此时会进入 <code>BR_TRANSACTION</code> 这个分支，调用 <code>BBinder.transact()</code> 将数据回传给 Java 层，最后调用 <code>sendReply()</code> 向客户端发送 reply。</p><p>这里的 BBinder 实际上是 JavaBBinder，前者是后者的父类。</p><blockquote><p>Java 层 Binder 初始化过程中会调用到 Native 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/os/Binder.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Binder</span><span class="params">(<span class="meta">@Nullable</span> String descriptor)</span> &#123;</span><br><span class="line">mObject = getNativeBBinderHolder();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下其相应的 Native 方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/android_util_Binder.cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">android_os_Binder_getNativeBBinderHolder</span><span class="params">(JNIEnv* env, jobject clazz)</span> </span>&#123;</span><br><span class="line">JavaBBinderHolder* jbh = <span class="keyword">new</span> <span class="built_in">JavaBBinderHolder</span>();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JavaBBinderHolder</span> &#123; <span class="comment">// 其中包含了JavaBBinder类型的成员变量</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">wp&lt;JavaBBinder&gt; mBinder;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JavaBBinder</span> : <span class="keyword">public</span> BBinder &#123;&#125;; <span class="comment">// JavaBBinder继承自BBinder</span></span><br></pre></td></tr></table></figure><p>所以最终效果就是，Java 层初始化 Binder 时，会在 Native 层创建相应的 JavaBBinder 对象。</p></blockquote><p>由于 JavaBBinder 中没有实现了 <code>transact()</code> 方法，所以会调用其父类 BBinder 中的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/Binder.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BBinder::transact</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data, Parcel* reply, <span class="type">uint32_t</span> flags)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            err = <span class="built_in">onTransact</span>(code, data, reply, flags);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> ...</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JavaBBinder 中实现了 <code>onTransact()</code> 方法，所以这里实际会调用到 JavaBBinder 中的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/android_util_Binder.cpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JavaBBinder</span> : <span class="keyword">public</span> BBinder &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">status_t</span> <span class="title">onTransact</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data, Parcel* reply, <span class="type">uint32_t</span> flags = <span class="number">0</span>)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        JNIEnv* env = <span class="built_in">javavm_to_jnienv</span>(mVM);</span><br><span class="line">        <span class="comment">// 反射调用到Java层的execTransact()这个boolean方法</span></span><br><span class="line">        jboolean res = env-&gt;<span class="built_in">CallBooleanMethod</span>(mObject, gBinderOffsets.mExecTransact,</span><br><span class="line">            code, <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(&amp;data), <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(reply), flags);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> res != JNI_FALSE ? NO_ERROR : UNKNOWN_TRANSACTION;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>回到 Java 层，看下 Binder 的 <code>execTransact()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/os/Binder.java</span></span><br><span class="line"><span class="comment">// Entry point from android_util_Binder.cpp&#x27;s onTransact.</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">execTransact</span><span class="params">(<span class="type">int</span> code, <span class="type">long</span> dataObj, <span class="type">long</span> replyObj,</span></span><br><span class="line"><span class="params">                             <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> execTransactInternal(code, dataObj, replyObj, flags, callingUid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">execTransactInternal</span><span class="params">(<span class="type">int</span> code, <span class="type">long</span> dataObj, <span class="type">long</span> replyObj, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                                     <span class="type">int</span> callingUid)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    res = onTransact(code, data, reply, flags);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了 Binder 的 <code>onTransact()</code> 方法，这实际上最后又会调用到 AIDL 层的相应方法。</p><p>现在客户端还在等待响应，回到 <a href="#%E9%94%9A%E7%82%B91"><code>IPCThreadState::sendReply()</code></a>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/IPCThreadState.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::sendReply</span><span class="params">(<span class="type">const</span> Parcel&amp; reply, <span class="type">uint32_t</span> flags)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 写入BC_REPLY，一路传送到Driver层进行处理</span></span><br><span class="line">    err = <span class="built_in">writeTransactionData</span>(BC_REPLY, flags, <span class="number">-1</span>, <span class="number">0</span>, reply, &amp;statusBuffer);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">waitForResponse</span>(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后来个函数调用的简化图：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/f55a9189c2220d323b0f2c5640f990ae.webp" alt="image-20220924230904431"></p><p>至此，整个通讯过程结束。</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://younghblog.gitee.io">Youngh</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://younghblog.gitee.io/posts/2031896266.html">https://younghblog.gitee.io/posts/2031896266.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://younghblog.gitee.io" target="_blank">YounghBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://img.gejiba.com/images/3d23f7fc9501aa22402a02666b09e892.md.webp" data-sites="weibo,wechat,qq"></div><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn1.tianli0.top/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn1.tianli0.top/gh/exploreMeta/cdn/img/donate/wechat.webp" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn1.tianli0.top/gh/exploreMeta/cdn/img/donate/wechat.webp" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn1.tianli0.top/gh/exploreMeta/cdn/img/donate/alipay.webp" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn1.tianli0.top/gh/exploreMeta/cdn/img/donate/alipay.webp" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/1916506233.html"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/02444853758d96ea1ce979fcd95b7973.md.webp" onerror='onerror=null,src="https://img.gejiba.com/images/4f60b4e053a96873d937752732c06a09.gif"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android画面显示流程</div></div></a></div><div class="next-post pull-right"><a href="/posts/2872386792.html"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/788496e432e69da44ecda3baa70659f5.md.webp" onerror='onerror=null,src="https://img.gejiba.com/images/4f60b4e053a96873d937752732c06a09.gif"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JNI学习</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/3cb1dc95c490420f129fb73888c41e12.md.webp" onerror='this.onerror=null,this.src="https://img.gejiba.com/images/4f60b4e053a96873d937752732c06a09.gif"' alt="avatar"></div><div class="author-info__name">Youngh</div><div class="author-info__description">Stay hungry, stay foolish</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://gitee.com/younghblog"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="tencent://AddContact/?fromId=50&amp;fromSubId=1&amp;subcmd=all&amp;uin=1413483899" target="_blank"><i class="fa-brands fa-qq"></i></a><a class="social-icon" href="mailto:1413483899@qq.com" target="_blank"><i class="fa-solid fa-envelope"></i></a><a class="social-icon" href="/rss2.xml" target="_blank"><i class="fa-solid fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>O.O</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#binder%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">1.</span> <span class="toc-text">Binder的优势</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.1.</span> <span class="toc-text">性能优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text">安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E6%89%A9%E5%B1%95%E5%92%8C%E4%BD%8E%E8%80%A6%E5%90%88"><span class="toc-number">1.3.</span> <span class="toc-text">可扩展和低耦合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#binder%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">Binder的通信方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#binder%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">Binder通信模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#binder%E9%A9%B1%E5%8A%A8"><span class="toc-number">3.1.</span> <span class="toc-text">Binder驱动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#servicemanager%E5%92%8C%E5%AE%9E%E5%90%8Dbinder"><span class="toc-number">3.2.</span> <span class="toc-text">ServiceManager和实名Binder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#client%E8%8E%B7%E5%BE%97%E5%AE%9E%E5%90%8Dbinder%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">3.3.</span> <span class="toc-text">Client获得实名Binder的引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8Dbinder"><span class="toc-number">3.4.</span> <span class="toc-text">匿名Binder</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#binder%E6%9C%BA%E5%88%B6%E8%B7%A8%E8%BF%9B%E7%A8%8B%E5%8E%9F%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">Binder机制跨进程原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">5.</span> <span class="toc-text">环境初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#binder%E9%A9%B1%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">5.1.</span> <span class="toc-text">Binder驱动初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#servicemanager%E6%9C%8D%E5%8A%A1%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">5.2.</span> <span class="toc-text">ServiceManager服务初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#processstate%E6%9E%84%E9%80%A0"><span class="toc-number">5.2.1.</span> <span class="toc-text">ProcessState构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#becomecontextmanager"><span class="toc-number">5.2.2.</span> <span class="toc-text">becomeContextManager()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bindercallback"><span class="toc-number">5.2.3.</span> <span class="toc-text">BinderCallback</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90binder%E6%A1%86%E6%9E%B6"><span class="toc-number">6.</span> <span class="toc-text">解析Binder框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">6.1.</span> <span class="toc-text">框架中的主要结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%BC%A0%E8%BE%93%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">6.2.</span> <span class="toc-text">框架中传输的数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#binder%E5%AE%9E%E4%BD%93"><span class="toc-number">6.2.1.</span> <span class="toc-text">Binder实体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#binder%E5%BC%95%E7%94%A8"><span class="toc-number">6.2.2.</span> <span class="toc-text">Binder引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#binder%E4%BB%A3%E7%90%86%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1"><span class="toc-number">6.2.3.</span> <span class="toc-text">Binder代理（远程服务）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#server%E5%9C%A8servicemanager%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">6.3.</span> <span class="toc-text">Server在ServiceManager中的存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F"><span class="toc-number">6.4.</span> <span class="toc-text">对象传递方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ams%E6%B3%A8%E5%86%8C%E5%88%B0servicemanager"><span class="toc-number">7.</span> <span class="toc-text">AMS注册到ServiceManager</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">8.</span> <span class="toc-text">两个进程间的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAprocessstate"><span class="toc-number">8.0.1.</span> <span class="toc-text">创建ProcessState</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%90%AFbinder%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">8.0.2.</span> <span class="toc-text">开启Binder线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%94%9A%E7%82%B91"><span class="toc-number">8.0.2.0.1.</span> <span class="toc-text">锚点1</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%94%9A%E7%82%B93"><span class="toc-number">8.0.2.0.2.</span> <span class="toc-text">锚点3</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%94%9A%E7%82%B92"><span class="toc-number">8.0.2.0.3.</span> <span class="toc-text">锚点2</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/1916506233.html" title="Android画面显示流程"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/02444853758d96ea1ce979fcd95b7973.md.webp" onerror='this.onerror=null,this.src="https://img.gejiba.com/images/4f60b4e053a96873d937752732c06a09.gif"' alt="Android画面显示流程"></a><div class="content"><a class="title" href="/posts/1916506233.html" title="Android画面显示流程">Android画面显示流程</a><time datetime="2022-10-08T15:44:58.000Z" title="发表于 2022-10-08 23:44:58">2022-10-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2031896266.html" title="Binder机制"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/3d23f7fc9501aa22402a02666b09e892.md.webp" onerror='this.onerror=null,this.src="https://img.gejiba.com/images/4f60b4e053a96873d937752732c06a09.gif"' alt="Binder机制"></a><div class="content"><a class="title" href="/posts/2031896266.html" title="Binder机制">Binder机制</a><time datetime="2022-09-25T01:08:18.000Z" title="发表于 2022-09-25 09:08:18">2022-09-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2872386792.html" title="JNI学习"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/788496e432e69da44ecda3baa70659f5.md.webp" onerror='this.onerror=null,this.src="https://img.gejiba.com/images/4f60b4e053a96873d937752732c06a09.gif"' alt="JNI学习"></a><div class="content"><a class="title" href="/posts/2872386792.html" title="JNI学习">JNI学习</a><time datetime="2022-09-21T15:15:22.000Z" title="发表于 2022-09-21 23:15:22">2022-09-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3659942439.html" title="Android渲染的整体架构"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/eb8d19563d07ccc303ce96f0da4a25af.md.webp" onerror='this.onerror=null,this.src="https://img.gejiba.com/images/4f60b4e053a96873d937752732c06a09.gif"' alt="Android渲染的整体架构"></a><div class="content"><a class="title" href="/posts/3659942439.html" title="Android渲染的整体架构">Android渲染的整体架构</a><time datetime="2022-09-04T13:11:29.000Z" title="发表于 2022-09-04 21:11:29">2022-09-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1441608745.html" title="「高效能人士的七个习惯」读书笔记"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/b60a19efb0970a66b87460015b04961c.md.webp" onerror='this.onerror=null,this.src="https://img.gejiba.com/images/4f60b4e053a96873d937752732c06a09.gif"' alt="「高效能人士的七个习惯」读书笔记"></a><div class="content"><a class="title" href="/posts/1441608745.html" title="「高效能人士的七个习惯」读书笔记">「高效能人士的七个习惯」读书笔记</a><time datetime="2022-07-08T12:39:21.000Z" title="发表于 2022-07-08 20:39:21">2022-07-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022&nbsp;&nbsp;&nbsp;<i style="color:#ff6a6a;animation:announ_animation .8s linear infinite" class="fas fa-heart"></i>&nbsp;&nbsp;&nbsp;By Youngh</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="https://www.antmoe.com/js/utils.js"></script><script src="https://www.antmoe.com/js/main.js"></script><script src="https://cdn1.tianli0.top/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://cdn.staticfile.org/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="https://www.antmoe.com/js/search/local-search.js" defer></script><div class="js-pjax"><script>function loadValine(){function n(){new Valine(Object.assign({el:"#vcomment",appId:"fUqvuCwXzFgVcGgakVuftjjg-gzGzoHsz",appKey:"44H71E23JXOW8dMVSkYGsmAG",avatar:"monsterid",serverURLs:"",emojiMaps:"",path:window.location.pathname,visitor:!1},null))}"function"==typeof Valine?n():getScript("https://cdn1.tianli0.top/npm/valine/dist/Valine.min.js").then(n)}function loadOtherComment(){loadValine()}btf.loadComment(document.getElementById("vcomment"),loadValine)</script></div><script src="https://cdn1.tianli0.top/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script id="click-heart" src="https://cdn1.tianli0.top/npm/butterfly-extsrc@1/dist/click-heart.min.js" async mobile="false"></script><script src="https://cdn.casecori.top/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.tocScrollFn&&window.removeEventListener("scroll",window.tocScrollFn),window.scrollCollect&&window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),document.getElementById("rightside").style.cssText="opacity: ''; transform: ''",window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script");var o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script></div></body></html>