<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>看懂简单的汇编代码 | YounghBlog</title><meta name="keywords" content="汇编,栈帧,数据对齐"><meta name="author" content="Youngh"><meta name="copyright" content="Youngh"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文介绍的是 AT&amp;T 格式的汇编代码。先上表格：  表格记录了不同寄存器的功能。汇编指令通常都有一个或多个操作数，有的指令没有操作数，这些操作数有三种类型：立即数 $Imm、寄存器 ra 和内存引用 (ra)。 常见的操作指令有：    指令 描述     mov    S, D 把数据从S传送到D   push    S 栈顶指针下移，S入栈   pop    D 栈顶内容赋值给D，栈"><meta property="og:type" content="article"><meta property="og:title" content="看懂简单的汇编代码"><meta property="og:url" content="https://younghblog.gitee.io/posts/3467593604.html"><meta property="og:site_name" content="YounghBlog"><meta property="og:description" content="本文介绍的是 AT&amp;T 格式的汇编代码。先上表格：  表格记录了不同寄存器的功能。汇编指令通常都有一个或多个操作数，有的指令没有操作数，这些操作数有三种类型：立即数 $Imm、寄存器 ra 和内存引用 (ra)。 常见的操作指令有：    指令 描述     mov    S, D 把数据从S传送到D   push    S 栈顶指针下移，S入栈   pop    D 栈顶内容赋值给D，栈"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img.gejiba.com/images/ec6056bb4a6e390d15c6bda5a67d6af3.md.webp"><meta property="article:published_time" content="2022-05-07T07:55:00.000Z"><meta property="article:modified_time" content="2022-07-05T09:37:03.300Z"><meta property="article:author" content="Youngh"><meta property="article:tag" content="汇编"><meta property="article:tag" content="栈帧"><meta property="article:tag" content="数据对齐"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img.gejiba.com/images/ec6056bb4a6e390d15c6bda5a67d6af3.md.webp"><link rel="shortcut icon" href="https://cdn1.tianli0.top/gh/exploreMeta/cdn/img/logo/favicon.ico"><link rel="canonical" href="https://younghblog.gitee.io/posts/3467593604"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="stylesheet" href="https://www.antmoe.com/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.0.0/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:300},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn1.tianli0.top/npm/flickr-justified-gallery@2/dist/fjGallery.min.js",css:"https://cdn1.tianli0.top/npm/flickr-justified-gallery@2/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"看懂简单的汇编代码",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-07-05 17:37:03"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){if(0!==a){a*=864e5,t={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(t))}},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=e=>new Promise((t,a)=>{const o=document.createElement("script");o.src=e,o.async=!0,o.onerror=a,o.onload=o.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(o.onload=o.onreadystatechange=null,t())},document.head.appendChild(o)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")},"dark"===(e=saveToLocal.get("theme"))?activateDarkMode():"light"===e&&activateLightMode(),void 0!==(e=saveToLocal.get("aside-status"))&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside")),/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="https://gahotx.cn/css/index.css"><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/exploreMeta/cdn/css/index.min.css"><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/exploreMeta/cdn/css/haa.css"><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/rss2.xml" title="YounghBlog" type="application/rss+xml"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/3cb1dc95c490420f129fb73888c41e12.md.webp" onerror='onerror=null,src="https://img.gejiba.com/images/4f60b4e053a96873d937752732c06a09.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://img.gejiba.com/images/ec6056bb4a6e390d15c6bda5a67d6af3.md.webp)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">YounghBlog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">看懂简单的汇编代码</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-07T07:55:00.000Z" title="发表于 2022-05-07 15:55:00">2022-05-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-07-05T09:37:03.300Z" title="更新于 2022-07-05 17:37:03">2022-07-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-CSAPP/">读书笔记 - CSAPP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>16分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>本文介绍的是 AT&amp;T 格式的汇编代码。先上表格：</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/2ec02466ed8dac1bfe60bab88be7fa76.webp" alt="整数寄存器" style="zoom:80%"><p>表格记录了不同寄存器的功能。汇编指令通常都有一个或多个操作数，有的指令没有操作数，这些操作数有三种类型：立即数 <span class="p red">$<em>Imm</em></span>、寄存器 <span class="p red"><em>r<sub>a</sub></em></span> 和内存引用 <span class="p red">(<em>r<sub>a</sub></em>)</span>。</p><p>常见的操作指令有：</p><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">mov S, D</td><td style="text-align:center">把数据从S传送到D</td></tr><tr><td style="text-align:center">push S</td><td style="text-align:center">栈顶指针下移，S入栈</td></tr><tr><td style="text-align:center">pop D</td><td style="text-align:center">栈顶内容赋值给D，栈顶指针上移</td></tr><tr><td style="text-align:center">lea S, D</td><td style="text-align:center">将S的地址（&amp;S）赋值给D</td></tr><tr><td style="text-align:center">inc/dec/neg/not D</td><td style="text-align:center">将D<code>加1/减1/取负/取反</code>后赋值给D</td></tr><tr><td style="text-align:center">add/sub/imul/xor/or/and S, D</td><td style="text-align:center">将D<code>加/减/乘/异或/或/与</code>S后赋值给D</td></tr><tr><td style="text-align:center">sal/shl/sar/shr k, D</td><td style="text-align:center">将D<code>算术/逻辑左移</code>/<code>算术/逻辑右移</code>k位后赋值给D</td></tr><tr><td style="text-align:center">leaq S, D</td><td style="text-align:center">将S的地址赋值给D或者对S算术运算后赋值给D</td></tr><tr><td style="text-align:center">cmp/test S1, S2</td><td style="text-align:center">根据<code>S2-S1或S2&amp;S1</code>的结果设置条件码</td></tr><tr><td style="text-align:center">cltq</td><td style="text-align:center">将 %eax 符号扩展到 %rax</td></tr><tr><td style="text-align:center">call/ret</td><td style="text-align:center">函数调用/函数返回</td></tr><tr><td style="text-align:center">enter/leave</td><td style="text-align:center">堆积/撤销一个栈</td></tr></tbody></table><p>接下来通过几个示例来进一步理解。</p><h2 id="mov-指令"><a class="markdownIt-Anchor" href="#mov-指令"></a> mov 指令</h2><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">exchange</span><span class="params">(<span class="type">long</span> *xp, <span class="type">long</span> y)</span> &#123;</span><br><span class="line">    <span class="type">long</span> x = *xp;</span><br><span class="line">    *xp = y;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一个参数 xp 保存在 %rdi 中，第二个参数 y 保存在 %rsi 中，返回值保存在 %rax 中</span></span><br><span class="line"><span class="comment"># *xp 是对 xp 的解引用，即读取内存中地址 xp 处所存放的值，因此表示为 (%rdi)</span></span><br><span class="line"><span class="attr">exchange:</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">(%rdi),</span> <span class="string">%rax</span>	<span class="comment"># 将 *xp 作为返回值</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">%rsi,</span> <span class="string">(%rdi)</span>	<span class="comment"># 将 y 赋值给 *xp</span></span><br><span class="line">	<span class="string">ret</span>			<span class="comment"># return</span></span><br></pre></td></tr></table></figure><h2 id="lea-指令"><a class="markdownIt-Anchor" href="#lea-指令"></a> lea 指令</h2><p>lea（load effective address）表示加载有效地址，虽然形式上是内存引用，但实际上并没有引用内存，而是将一个内存地址直接赋值给目的操作数；mov 则是将地址处的数据赋值给目的操作数。例如：</p><p><code>leaq 8(%rbx), %rax</code> 表示将 <code>%rbx+8</code> 这个地址直接赋值给 <code>%rax</code>，而不是把该地址处所对应的数据赋值给 <code>%rax</code>。mov 指令则恰恰相反：</p><p><code>movq 8(%rbx), %rax</code> 表示将 <code>%rbx+8</code> 这个地址处所对应的数据赋值给 <code>%rax</code>。</p><p>lea 的用法比较灵活，除了加载有效地址，还可以进行算术运算。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">scale</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span> &#123;</span><br><span class="line">    <span class="type">long</span> t = x + <span class="number">4</span> * y + <span class="number">12</span> * z;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x in %rdi, y in %rsi, z in %rdx</span></span><br><span class="line"><span class="attr">scale:</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="string">(%rdi,</span> <span class="string">%rsi,</span> <span class="number">4</span><span class="string">),</span> <span class="string">%rax</span>	<span class="comment"># 将 x + 4y 放入 %rax</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="string">(%rdx,</span> <span class="string">%rdx,</span> <span class="number">2</span><span class="string">),</span> <span class="string">%rdx</span>	<span class="comment"># z = z + 2z = 3z</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="string">(%rax,</span> <span class="string">%rdx,</span> <span class="number">4</span><span class="string">),</span> <span class="string">%rax</span>	<span class="comment"># 将 (x + 4y) + 3z * 4 作为返回值</span></span><br><span class="line">	<span class="string">ret</span></span><br></pre></td></tr></table></figure><p>对于后两条 <code>leaq</code> 指令，之所以没有直接合并成 <code>leaq (%rax, %rdx, 12), %rax</code>，是因为对于变址寻址中的比例因子只能取 1、2、4、8，因此需要对 12 分解。</p><p>比例因子的取值与源代码中定义的数组类型相关，编译器会据此来确定比例因子的数值。比如对于 char 类型的数组，其比例因子是 1；short 类型的比例因子是 2；int 类型是 4；double 类型是 8 等等。</p><blockquote><p>判断 lea 是加载地址还是算术运算，可以根据所操作的寄存器的功能。如果是保存参数的普通寄存器一般表示算术运算，而其他特殊的寄存器则表示加载有效地址（个人观察，有待查证）。</p></blockquote><h2 id="算术指令"><a class="markdownIt-Anchor" href="#算术指令"></a> 算术指令</h2><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">arith</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span> &#123;</span><br><span class="line">    <span class="type">long</span> t1 = x ^ y;</span><br><span class="line">    <span class="type">long</span> t2 = z * <span class="number">48</span>;</span><br><span class="line">    <span class="type">long</span> t3 = t1 &amp; <span class="number">0x0F0F0F0F</span>;</span><br><span class="line">    <span class="type">long</span> t4 = t2 - t3;</span><br><span class="line">    <span class="keyword">return</span> t4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x in %rdi, y in %rsi, z in %rdx</span></span><br><span class="line"><span class="attr">arith:</span></span><br><span class="line">	<span class="string">xorq</span>	<span class="string">%rsi,</span> <span class="string">%rdi</span>		<span class="comment"># x = x ^ y</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="string">(%rdx,</span> <span class="string">%rdx,</span> <span class="number">2</span><span class="string">),</span> <span class="string">%rax</span>	<span class="comment"># 将 z + 2z = 3z 放入 %rax</span></span><br><span class="line">	<span class="string">salq</span>	<span class="string">$4,</span> <span class="string">%rax</span>		<span class="comment"># 将 3z 左移 4 位，即 3z * 16 = 48z 作为返回值</span></span><br><span class="line">	<span class="string">andl</span>	<span class="string">$252645135,</span> <span class="string">%edi</span>	<span class="comment"># 该立即数有 8 * 4 = 32 位，因此只取前 32 位进行与运算</span></span><br><span class="line">	<span class="string">subq</span>	<span class="string">%rdi,</span> <span class="string">%rax</span>		<span class="comment"># 将 48z - t3 的值作为返回值</span></span><br><span class="line">	<span class="string">ret</span></span><br></pre></td></tr></table></figure><p>对于源程序第 3 行代码中的乘法操作，被编译成了 leaq 和左移两条指令。编译器之所以没有直接使用乘法指令来实现，是因为乘法指令的执行时间更长，因此编译器会优先选择更高效的方式。</p><h2 id="控制指令"><a class="markdownIt-Anchor" href="#控制指令"></a> 控制指令</h2><h3 id="条件码"><a class="markdownIt-Anchor" href="#条件码"></a> 条件码</h3><p>除了整数寄存器，CPU 还维护着一组单个比特位的条件码寄存器，可以通过检测这些寄存器来执行条件分支指令。常用的条件码：</p><table><thead><tr><th style="text-align:center">条件码</th><th style="text-align:center">全称</th><th style="text-align:center">含义</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">CF</td><td style="text-align:center">Carry Flag</td><td style="text-align:center">进位标志</td><td style="text-align:center">最高位产生了进位</td></tr><tr><td style="text-align:center">ZF</td><td style="text-align:center">Zero Flag</td><td style="text-align:center">零标志位</td><td style="text-align:center">操作结果为零</td></tr><tr><td style="text-align:center">SF</td><td style="text-align:center">Sign Flag</td><td style="text-align:center">符号标志</td><td style="text-align:center">操作结果为负</td></tr><tr><td style="text-align:center">OF</td><td style="text-align:center">Overflow Flag</td><td style="text-align:center">溢出标志</td><td style="text-align:center">操作结果溢出</td></tr></tbody></table><p>算术和逻辑运算指令会改变条件码寄存器的内容（<code>leaq</code> 不会），还有两类指令专门用来设置条件码而不改变其它任何寄存器：<code>cmp</code> 和 <code>test</code>。</p><p><code>cmp S1, S2</code> 会根据 <code>S2 - S1</code> 的结果来设置条件码；</p><p><code>test S1, S2</code> 会根据 <code>S2 &amp; S1</code> 的结果来设置条件码。</p><p><code>test</code> 指令的典型用法是两个操作数相同，用来判断该操作数是正数，零，还是负数。对于这样的指令，如 <code>testq %rax,%rax</code>，它与 <code>cmpq $0, %rax</code> 是等价的。</p><p>接下来通过示例看一下对条件码的访问。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">comp</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a in %rdi, b in %rsi</span></span><br><span class="line"><span class="attr">comp:</span></span><br><span class="line">	<span class="string">cmpq</span>	<span class="string">%rsi,</span> <span class="string">%rdi</span>	<span class="comment"># 根据 a - b 的结果设置条件码寄存器</span></span><br><span class="line">	<span class="string">setl</span>	<span class="string">%al</span>		<span class="comment"># 如果 a &lt; b，将 al 寄存器设置为 1；否则设置为 0</span></span><br><span class="line">	<span class="string">movzbl</span>	<span class="string">%al,</span> <span class="string">%eax</span>	<span class="comment"># movz 表示零扩展，将 al 寄存器从 byte 扩展到 long word</span></span><br><span class="line">	<span class="string">ret</span></span><br></pre></td></tr></table></figure><h3 id="循环"><a class="markdownIt-Anchor" href="#循环"></a> 循环</h3><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fact_do</span><span class="params">(<span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        result *= n;</span><br><span class="line">        n = n - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span>(n &gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># n in %rdi</span></span><br><span class="line"><span class="attr">fact_do:</span></span><br><span class="line">	<span class="string">movl</span>	<span class="string">$1,</span> <span class="string">%eax</span>	<span class="comment"># 将 1 放入 %eax</span></span><br><span class="line"><span class="string">.L2:</span></span><br><span class="line">	<span class="string">imulq</span>	<span class="string">%rdi,</span> <span class="string">%rax</span>	<span class="comment"># 将 %rax 中的值更新为自身乘以 n</span></span><br><span class="line">	<span class="string">subq</span>	<span class="string">$1,</span> <span class="string">%rdi</span>	<span class="comment"># n = n - 1</span></span><br><span class="line">	<span class="string">cmpq</span>	<span class="string">$1,</span> <span class="string">%rdi</span>	<span class="comment"># 根据 n - 1 的结果设置条件码寄存器</span></span><br><span class="line">	<span class="string">jg</span>		<span class="string">.L2</span>	<span class="comment"># 如果 n &gt; 1 则跳转到 .L2 处执行</span></span><br><span class="line">	<span class="string">rep;</span> <span class="string">ret</span>		<span class="comment"># rep 是空操作，可以直接无视它</span></span><br></pre></td></tr></table></figure><p><code>imul</code> 表示有符号整数乘法，<code>mul</code> 则表示无符号整数乘法。</p><h2 id="push-与-pop-指令"><a class="markdownIt-Anchor" href="#push-与-pop-指令"></a> push 与 pop 指令</h2><p><code>pushq S</code>，等价于以下两条操作指令：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">subq</span>	<span class="string">$8,</span> <span class="string">%rsp</span></span><br><span class="line"><span class="string">movq</span>	<span class="string">S,</span> <span class="string">(%rsp)</span></span><br></pre></td></tr></table></figure><p>因此两次 push 之后 %rsp 依然指向栈顶。</p><p>相应地，<code>popq D</code> 也等价于两条指令：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">movq</span>	<span class="string">(%rsp),</span> <span class="string">D</span></span><br><span class="line"><span class="string">addq</span>	<span class="string">$8,</span> <span class="string">%rsp</span></span><br></pre></td></tr></table></figure><p>如图所示：</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/944e92c68fc061803e0017ae75b7e13e.webp" alt="pushpop" style="zoom:80%"><h2 id="call-与-ret-指令"><a class="markdownIt-Anchor" href="#call-与-ret-指令"></a> call 与 ret 指令</h2><p><code>call</code> 和 <code>ret</code> 指令类似于 <code>pushq</code> 和 <code>popq</code>。</p><p><code>call</code> 指令会将下一条指令的地址压入栈中，然后将调用的目的地址 <code>D</code> 作为下一条执行指令的地址。</p><p><code>ret</code> 指令将从栈顶弹出的地址作为下一条执行的指令的地址。由 <code>call</code> 可知，这条指令其实就是 <code>call</code> 指令后面紧跟的那条指令，表示在函数调用返回后继续往下执行。</p><p>如图所示：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/e3492a3a945ffa8638842c82d99b6f9e.webp" alt="callret"></p><h2 id="enter-与-leave-指令"><a class="markdownIt-Anchor" href="#enter-与-leave-指令"></a> enter 与 leave 指令</h2><p><code>enter</code> 指令在原有的栈上堆积了一个栈，等价于以下两条操作指令：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">pushq</span>	<span class="string">%rbp</span></span><br><span class="line"><span class="string">movq</span>	<span class="string">%rsp,</span> <span class="string">%rbp</span></span><br></pre></td></tr></table></figure><p><code>leave</code> 指令则是撤销这个新堆积的栈，等价于以下两条指令：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">movq</span>	<span class="string">%rbp,</span> <span class="string">%rsp</span></span><br><span class="line"><span class="string">popq</span>	<span class="string">%rbp</span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/1a55414f1ab12c87dd1345e47778e8e3.webp" alt="enter&amp;leave"></p><h2 id="函数调用"><a class="markdownIt-Anchor" href="#函数调用"></a> 函数调用</h2><h3 id="函数栈帧"><a class="markdownIt-Anchor" href="#函数栈帧"></a> 函数栈帧</h3><p>当函数需要的存储空间超出寄存器所能存放的大小时，就会在栈上分配空间，这块存储空间称为该函数的 <strong>栈帧</strong>。例如，在本文最开始给出的表格中可以发现，对于前 6 个参数，每一个都有相对应的寄存器进行保存，而从第 7 个参数开始，则被保存到了栈里面。另外，还有两种常见的情况需要为函数分配栈帧，一种是对一个局部变量使用取地址符，因此必须能为它产生一个地址；另一种是当局部变量是数组或结构体。</p><p>当函数 P 调用函数 Q 时，其栈帧结构如下：</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/e89ffa3aefa3462d8eb41ee9777ead4c.webp" alt="P调用Q的栈帧结构" style="zoom:16%"><p>当前正在执行的函数的栈帧总是保存在栈顶，当 P 调用 Q 时，call 指令会把返回地址压入栈中，该地址指明了当 Q 返回时，要从 P 的哪个位置继续执行。下面看一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">proc</span><span class="params">(<span class="type">long</span>  a1, <span class="type">long</span>  *a1p,</span></span><br><span class="line"><span class="params">          <span class="type">int</span>   a2, <span class="type">int</span>   *a2p,</span></span><br><span class="line"><span class="params">          <span class="type">short</span> a3, <span class="type">short</span> *a3p,</span></span><br><span class="line"><span class="params">          <span class="type">char</span>  a4, <span class="type">char</span>  *a4p)</span> &#123;</span><br><span class="line">    *a1p += a1;</span><br><span class="line">    *a2p += a2;</span><br><span class="line">    *a3p += a3;</span><br><span class="line">    *a4p += a4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">call_proc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span>  x1 = <span class="number">1</span>; <span class="type">int</span>  x2 = <span class="number">2</span>;</span><br><span class="line">    <span class="type">short</span> x3 = <span class="number">3</span>; <span class="type">char</span> x4 = <span class="number">4</span>;</span><br><span class="line">    proc(x1, &amp;x1, x2, &amp;x2, x3, &amp;x3, x4, &amp;x4);</span><br><span class="line">    <span class="keyword">return</span> (x1 + x2) * (x3 - x4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>proc 的汇编代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a1 in %rdi, a1p in %rsi</span></span><br><span class="line"><span class="comment"># a2 in %edx, a2p in %rcx</span></span><br><span class="line"><span class="comment"># a3 in %r8w, a3p in %r9</span></span><br><span class="line"><span class="comment"># %rsp 指向栈顶</span></span><br><span class="line"><span class="comment"># a4 in %rsp+8, a4p in %rsp+16</span></span><br><span class="line"><span class="attr">proc:</span></span><br><span class="line">	<span class="string">movq</span>	<span class="number">16</span><span class="string">(%rsp),</span> <span class="string">%rax</span>	<span class="comment"># 将 a4p 放入 %rax</span></span><br><span class="line">	<span class="string">addq</span>	<span class="string">%rdi,</span> <span class="string">(%rsi)</span>	<span class="comment"># *a1p += a1</span></span><br><span class="line">	<span class="string">addl</span>	<span class="string">%edx,</span> <span class="string">(%rcx)</span>	<span class="comment"># *a2p += a2</span></span><br><span class="line">	<span class="string">addw</span>	<span class="string">%r8w,</span> <span class="string">(%r9)</span>	<span class="comment"># *a3p += a3</span></span><br><span class="line">	<span class="string">movl</span>	<span class="number">8</span><span class="string">(%rsp),</span> <span class="string">%edx</span>	<span class="comment"># 将 a4 放入 %edx</span></span><br><span class="line">	<span class="string">addb</span>	<span class="string">%dl,</span> <span class="string">(%rax)</span>	<span class="comment"># *a4p += a4</span></span><br><span class="line">	<span class="string">ret</span></span><br></pre></td></tr></table></figure><p>有几点需要注意：</p><ul><li>虽然从第 7 个参数开始都被保存到了栈中，但是当指令需要对这些参数操作时，仍然需要先从栈读入到寄存器中。</li><li>通过栈传递参数时，所有数据都需要 8 字节对齐，所以 a4 即便只有 1 个字节，仍然为其分配了 8 个字节的存储空间。<span class="p red">注意：只有借助栈传递参数时才需要 8 字节对齐，如果只是在栈中存放局部变量，比如使用了取地址运算符的局部变量（必须存放在栈中），它们是不需要对齐的。</span></li><li>a4 是从 %rsp+8 的位置开始存放的，而不是 %rsp 指向的位置，说明返回地址占据了栈顶位置。函数 proc 的栈帧如图所示：</li></ul><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/3dc0f287b4a191a0053e3de978a4726a.webp" alt="proc 的栈帧" style="zoom:45%"><p>call_proc 的汇编代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">call_proc:</span></span><br><span class="line">	<span class="string">subq</span>	<span class="string">$32,</span> <span class="string">%rsp</span>	<span class="comment"># %rsp - 32，分配 32 字节大小的栈帧</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">$1,</span> <span class="number">24</span><span class="string">(%rsp)</span>	<span class="comment"># 将立即数 1 放到栈帧 %rsp + 24 处</span></span><br><span class="line">	<span class="string">movl</span>	<span class="string">$2,</span> <span class="number">20</span><span class="string">(%rsp)</span>	<span class="comment"># 将立即数 2 放到栈帧 %rsp + 20 处</span></span><br><span class="line">	<span class="string">movw</span>	<span class="string">$3,</span> <span class="number">18</span><span class="string">(%rsp)</span>	<span class="comment"># 将立即数 3 放到栈帧 %rsp + 18 处</span></span><br><span class="line">	<span class="string">movb</span>	<span class="string">$4,</span> <span class="number">17</span><span class="string">(%rsp)</span>	<span class="comment"># 将立即数 4 放到栈帧 %rsp + 17 处</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="number">17</span><span class="string">(%rsp),</span> <span class="string">%rax</span>	<span class="comment"># 将 &amp;x4 放入 %rax</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">%rax,</span> <span class="number">8</span><span class="string">(%rsp)</span>	<span class="comment"># 将 &amp;x4 放到栈帧 %rsp + 8 处作为第 8 个参数</span></span><br><span class="line">	<span class="string">movl</span>	<span class="string">$4,</span> <span class="string">(%rsp)</span>	<span class="comment"># 将立即数 4 放到栈帧 %rsp 处作为第 7 个参数</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="number">18</span><span class="string">(%rsp),</span> <span class="string">%r9</span>	<span class="comment"># 将 &amp;x3 作为第 6 个参数</span></span><br><span class="line">	<span class="string">movl</span>	<span class="string">$3,</span> <span class="string">%r8d</span>	<span class="comment"># 将立即数 3 作为第 5 个参数</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="number">20</span><span class="string">(%rsp),</span> <span class="string">%rcx</span>	<span class="comment"># 将 &amp;x2 作为第 4 个参数</span></span><br><span class="line">	<span class="string">movl</span>	<span class="string">$2,</span> <span class="string">%edx</span>	<span class="comment"># 将立即数 2 作为第 3 个参数</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="number">24</span><span class="string">(%rsp),</span> <span class="string">%rsi</span>	<span class="comment"># 将 &amp;x1 作为第 2 个参数</span></span><br><span class="line">	<span class="string">movl</span>	<span class="string">$1,</span> <span class="string">%edi</span>	<span class="comment"># 将立即数 1 作为第 1 个参数</span></span><br><span class="line">	<span class="comment"># 调用函数 proc</span></span><br><span class="line">	<span class="string">call</span>	<span class="string">proc</span></span><br><span class="line">	<span class="string">movslq</span>	<span class="number">20</span><span class="string">(%rsp),</span> <span class="string">%rdx</span>	<span class="comment"># 将 x2 符号扩展为四字放入 %rdx</span></span><br><span class="line">	<span class="string">addq</span>	<span class="number">24</span><span class="string">(%rsp),</span> <span class="string">%rdx</span>	<span class="comment"># 将 x2 + x1 放入 %rdx</span></span><br><span class="line">	<span class="string">movswl</span>	<span class="number">18</span><span class="string">(%rsp),</span> <span class="string">%eax</span>	<span class="comment"># 将 x3 符号扩展为双字放入 %eax</span></span><br><span class="line">	<span class="string">movsbl</span>	<span class="number">17</span><span class="string">(%rsp),</span> <span class="string">%ecx</span>	<span class="comment"># 将 x4 符号扩展为双字放入 %ecx</span></span><br><span class="line">	<span class="string">subl</span>	<span class="string">%ecx,</span> <span class="string">%eax</span>	<span class="comment"># 将 x3 - x4 放入 %eax</span></span><br><span class="line">	<span class="string">cltq</span>			<span class="comment"># 将 %eax 符号扩展到 %rax</span></span><br><span class="line">	<span class="string">imulq</span>	<span class="string">%rdx,</span> <span class="string">%rax</span>	<span class="comment"># 将 (x3 - x4) * (x2 + x1) 作为返回值</span></span><br><span class="line">	<span class="string">addq</span>	<span class="string">$32,</span> <span class="string">%rsp</span>	<span class="comment"># %rsp + 32，释放 32 字节大小的栈帧</span></span><br><span class="line">	<span class="string">ret</span></span><br></pre></td></tr></table></figure><p>函数 call_proc 的栈帧如图所示：</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/64c8434dd3f2a16518fbd172400264e8.webp" alt="call_proc 的栈帧" style="zoom:45%"><h3 id="被调用者保存寄存器"><a class="markdownIt-Anchor" href="#被调用者保存寄存器"></a> [被]调用者保存寄存器</h3><p>在程序执行的过程中，寄存器是被所有函数共享的，因此为了确保在使用过程中寄存器内的数据不被覆盖，处理器采用了一组统一的寄存器使用惯例，所有函数都必须遵守。</p><p>根据惯例，对于 16 个通用寄存器，除了 %rsp 之外，其余 15 个寄存器被划分为调用者保存和被调用者保存。其中，%rbx、%rbp、%r12~%r15 被划分为 <strong>被调用者保存寄存器</strong>，剩余的被划分为 <strong>调用者保存寄存器</strong>。下面以一个例子说明其使用方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">P</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span> &#123;</span><br><span class="line">    <span class="type">long</span> u = Q(y);</span><br><span class="line">    <span class="type">long</span> v = Q(x);</span><br><span class="line">    <span class="keyword">return</span> u + v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x in %rdi, y in %rsi</span></span><br><span class="line"><span class="attr">P:</span></span><br><span class="line">	<span class="string">pushq</span>	<span class="string">%rbp</span>		<span class="comment"># 保存 %rbp 中的值</span></span><br><span class="line">	<span class="string">pushq</span>	<span class="string">%rbx</span>		<span class="comment"># 保存 %rbx 中的值</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">%rdi,</span> <span class="string">%rbp</span>	<span class="comment"># 将 %rdi 中的值 x 保存到 %rbp 中</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">%rsi,</span> <span class="string">%rdi</span>	<span class="comment"># 将 y 放入 %rdi 作为第一个参数</span></span><br><span class="line">	<span class="string">call</span>	<span class="string">Q</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">%rax,</span> <span class="string">%rbx</span>	<span class="comment"># 将 Q 的返回结果 u 保存到 %rbx 中</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">%rbp,</span> <span class="string">%rdi</span>	<span class="comment"># 将 x 放入 %rdi 作为第一个参数</span></span><br><span class="line">	<span class="string">call</span>	<span class="string">Q</span></span><br><span class="line">	<span class="string">addq</span>	<span class="string">%rbx,</span> <span class="string">%rax</span>	<span class="comment"># 将 v + u 作为返回值</span></span><br><span class="line">	<span class="string">addq</span>	<span class="string">$8,</span> <span class="string">%rsp</span>	<span class="comment"># 释放 8 个字节的栈帧</span></span><br><span class="line">	<span class="string">popq</span>	<span class="string">%rbx</span>		<span class="comment"># 恢复 %rbx 中的值</span></span><br><span class="line">	<span class="string">popq</span>	<span class="string">%rbp</span>		<span class="comment"># 恢复 %rbp 中的值</span></span><br><span class="line">	<span class="string">ret</span></span><br></pre></td></tr></table></figure><p>在函数 P 中，x 保存在 %rdi 中，当在第 7 行调用函数 Q 时，由于 Q 有一个参数，因此也会使用 %rdi。为了防止 P 中的 %rdi 值被覆盖，需要先将其保存到一个其他无关的寄存器 %rbp 中（第 6 行），而为了防止原本 %rbp 中的内容被覆盖，在此之前还需将其中的内容压入栈中保存起来（第 3 行）。</p><p>同样的道理，当第一次调用 Q 结束时，结果会被保存在 %rax 中返回；而当第二次调用函数 Q 时，其返回结果仍然会保存在 %rax 中。为了防止第一次返回的结果被覆盖，需要先将其保存到一个其他无关的寄存器 %rbx 中（第 8 行），而为了防止原本 %rbx 中的内容被覆盖，在此之前还需将其中的内容压入栈中保存起来（第 4 行）。</p><p>在函数 P 结束之前，按照栈后进先出的顺序出栈，依次恢复 %rbx 和 %rbp 中的内容。</p><h3 id="函数递归调用"><a class="markdownIt-Anchor" href="#函数递归调用"></a> 函数递归调用</h3><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">rfact</span><span class="params">(<span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)</span><br><span class="line">        result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        result = n * rfact(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># n in %rdi</span></span><br><span class="line"><span class="attr">rfact:</span></span><br><span class="line">	<span class="string">pushq</span>	<span class="string">%rbx</span>			<span class="comment"># 保存 %rbx 中的值</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">%rdi,</span> <span class="string">%rbx</span>		<span class="comment"># 将 n 放入 %rbx</span></span><br><span class="line">	<span class="string">movl</span>	<span class="string">$1,</span> <span class="string">%eax</span>		<span class="comment"># 将 1 放入 %rax</span></span><br><span class="line">	<span class="string">cmpq</span>	<span class="string">$1,</span> <span class="string">%rdi</span>		<span class="comment"># 根据 n - 1 的值设置条件码寄存器</span></span><br><span class="line">	<span class="string">jle</span>	<span class="string">.L35</span>			<span class="comment"># 如果 n &lt;= 1，跳转到 .L35</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="number">-1</span><span class="string">(%rdi),</span> <span class="string">%rdi</span>		<span class="comment"># 将 n = n - 1 作为第一个参数</span></span><br><span class="line">	<span class="string">call</span>	<span class="string">rfact</span>			<span class="comment"># 调用函数 rfact</span></span><br><span class="line">	<span class="string">imulq</span>	<span class="string">%rbx,</span> <span class="string">%rax</span>		<span class="comment"># 将 rfact(n - 1) * n 的值放入 %rax</span></span><br><span class="line"><span class="string">.L35:</span></span><br><span class="line">	<span class="string">popq</span>	<span class="string">%rbx</span>			<span class="comment"># 恢复 %rbx 中的值</span></span><br><span class="line">	<span class="string">ret</span></span><br></pre></td></tr></table></figure><h2 id="数组和指针"><a class="markdownIt-Anchor" href="#数组和指针"></a> 数组和指针</h2><p>数组在内存中是连续存放的，每个元素所占内存的大小由数组类型决定，如图所示：</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/e3d43bd460b0c20d24ce0fd3018b4f7b.webp" alt="array" style="zoom:62%"><p>对指针进行运算时，计算结果会根据指针类型进行相应的伸缩。为方便理解，将内存抽象成一个很大的数组，假设初始时指针 p 和 q 都指向 0x100 处，现分别对两个指针进行加 1 操作，由于指针类型不同，指针 p + 1 会前进 1 个字节，而指针 q + 1 会前进 4 个字节，如图所示：</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/fb5a7e558f74a7c9c29816a82405f68a.webp" alt="padd" style="zoom:70%"><p>而数组名正是指向该数组首元素的指针，因此对于数组 <code>int arr[5]</code> 中的每一个元素，均有两种表示方式，如图所示：</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/38e1cc7b41ea67d443c837bebf6bbe95.webp" alt="parr" style="zoom:75%"><p>对于二维数组，在内存中是按照行优先的顺序存储的：</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/af9f4f55dd7d45b4c94e582e69595f8c.webp" alt="2D-array" style="zoom:70%"><h2 id="结构体和联合体"><a class="markdownIt-Anchor" href="#结构体和联合体"></a> 结构体和联合体</h2><p>CPU 是按 32/64 位的大小进行存取的，为了提高 CPU 的执行效率，计算机系统对基本数据类型的合法地址做了一些限制，要求某种类型的地址必须是某个值（2 / 4 / 8）的倍数，这就是 <strong>数据对齐</strong>。数据对齐会由编译器自动实现，但了解其实现方法还是很有必要的，可以优化代码结构，达到节省空间和提高效率（减少访存次数）的目的。</p><p>数据对齐的基本原则是：<span class="p red">任何 K 字节的基本对象的地址必须是 K 的倍数</span>。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>  i;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span>  j;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果不进行数据对齐（以 64 位机器为例），结构体 S1 在内存中的分布如图 (a) 所示。</p><p>虽然整体只占了 9 个字节，但要访问成员 j，需要访问两次内存才行，这样效率并不高。而如果进行了数据对齐，则访问所有成员都只需访问一次内存即可，如图 (b)。其中在 c 后面插入 3 个字节，是因为 j 占 4 个字节，所以它的起始地址必须是 4 的倍数。</p><p>另外，在结构体的末尾，可能也需要一些填充。比如假设结构体 S1 中没有成员 j，那所有元素都是满足对齐要求的，但是当该结构体声明为数组时（比如 <code>struct S1 arr[2]</code>），对齐原则就无法保证了，因此需要在末尾进行填充以满足结构体数组的对齐原则，如图 (c)。</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/56afaf0f2107e96c0d3562725c18e2be.webp" alt="align" style="zoom:50%"><p>与结构体不同，联合体中的所有字段共享同一存储区域，因此联合体的大小取决于其最大字段的大小。如果我们事先知道两个不同字段的使用是互斥的，那么就可以将这两个字段声明为一个联合体，从而达到节省内存空间的目的。</p><p>此外，联合体还可以用来访问不同数据类型的位模式，比如判断机器的大小端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">    &#125; temp;</span><br><span class="line">    temp.i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(temp.c == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Little Endian\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Big Endian\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 i 占 4 个字节，c 占 1 个字节，二者共享同一段内存，因此只需为 temp 分配 4 字节的空间。当为联合体中的 i 赋值后（第 6 行），为 temp 分配的四个字节都填满了，此时访问其中的 c 成员，其实就是访问这段内存的第 1 个字节，即低地址处的第 1 个字节。</p><p>对于 4 字节的整型 1，其十六进制表示为 <code>0x0000 0001</code>。若机器是小端，则低位放低地址处，高位放高地址处，地址从低到高依次为 <code>0x01 0x00 0x00 0x00</code>；若机器是大端，则低位放高地址处，高位放低地址处，地址从低到高依次为 <code>0x00 0x00 0x00 0x01</code>。</p><p>此时只需判断 c 的值是 <code>0x01</code> 还是 <code>0x00</code>，即可判断机器是小端还是大端。</p><p>再比如，可以用如下方法来获取 double 类型的二进制位表示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">double2bits</span><span class="params">(<span class="type">double</span> d)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> u;</span><br><span class="line">    &#125; temp; <span class="comment">// 以一种类型存储，以另一种类型访问</span></span><br><span class="line">    temp.d = d;</span><br><span class="line">    <span class="keyword">return</span> temp.u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>double</code> 与 <code>unsigned long</code> 所占的字节相同，因此当为 d 赋值后，d 和 u 就共同拥有了相同大小的内存空间，此时对 u 的访问即是 d 的二进制位的十进制表示。</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://younghblog.gitee.io">Youngh</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://younghblog.gitee.io/posts/3467593604.html">https://younghblog.gitee.io/posts/3467593604.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://younghblog.gitee.io" target="_blank">YounghBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B1%87%E7%BC%96/">汇编</a><a class="post-meta__tags" href="/tags/%E6%A0%88%E5%B8%A7/">栈帧</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90/">数据对齐</a></div><div class="post_share"><div class="social-share" data-image="https://img.gejiba.com/images/ec6056bb4a6e390d15c6bda5a67d6af3.md.webp" data-sites="weibo,wechat,qq"></div><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn1.tianli0.top/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn1.tianli0.top/gh/exploreMeta/cdn/img/donate/wechat.webp" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn1.tianli0.top/gh/exploreMeta/cdn/img/donate/wechat.webp" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn1.tianli0.top/gh/exploreMeta/cdn/img/donate/alipay.webp" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn1.tianli0.top/gh/exploreMeta/cdn/img/donate/alipay.webp" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/3931262747.html"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/ec6056bb4a6e390d15c6bda5a67d6af3.md.webp" onerror='onerror=null,src="https://img.gejiba.com/images/4f60b4e053a96873d937752732c06a09.gif"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">CPU流水线的各个阶段到底做了什么</div></div></a></div><div class="next-post pull-right"><a href="/posts/4223884717.html"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/ec6056bb4a6e390d15c6bda5a67d6af3.md.webp" onerror='onerror=null,src="https://img.gejiba.com/images/4f60b4e053a96873d937752732c06a09.gif"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机系统漫游</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/3cb1dc95c490420f129fb73888c41e12.md.webp" onerror='this.onerror=null,this.src="https://img.gejiba.com/images/4f60b4e053a96873d937752732c06a09.gif"' alt="avatar"></div><div class="author-info__name">Youngh</div><div class="author-info__description">Stay hungry, stay foolish</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://gitee.com/younghblog"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="tencent://AddContact/?fromId=50&amp;fromSubId=1&amp;subcmd=all&amp;uin=1413483899" target="_blank"><i class="fa-brands fa-qq"></i></a><a class="social-icon" href="mailto:1413483899@qq.com" target="_blank"><i class="fa-solid fa-envelope"></i></a><a class="social-icon" href="/rss2.xml" target="_blank"><i class="fa-solid fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>O.O</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#mov-%E6%8C%87%E4%BB%A4"><span class="toc-number">1.</span> <span class="toc-text">mov 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lea-%E6%8C%87%E4%BB%A4"><span class="toc-number">2.</span> <span class="toc-text">lea 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4"><span class="toc-number">3.</span> <span class="toc-text">算术指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4"><span class="toc-number">4.</span> <span class="toc-text">控制指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%A0%81"><span class="toc-number">4.1.</span> <span class="toc-text">条件码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.2.</span> <span class="toc-text">循环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#push-%E4%B8%8E-pop-%E6%8C%87%E4%BB%A4"><span class="toc-number">5.</span> <span class="toc-text">push 与 pop 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#call-%E4%B8%8E-ret-%E6%8C%87%E4%BB%A4"><span class="toc-number">6.</span> <span class="toc-text">call 与 ret 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#enter-%E4%B8%8E-leave-%E6%8C%87%E4%BB%A4"><span class="toc-number">7.</span> <span class="toc-text">enter 与 leave 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">8.</span> <span class="toc-text">函数调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7"><span class="toc-number">8.1.</span> <span class="toc-text">函数栈帧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A2%AB%E8%B0%83%E7%94%A8%E8%80%85%E4%BF%9D%E5%AD%98%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">8.2.</span> <span class="toc-text">[被]调用者保存寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8"><span class="toc-number">8.3.</span> <span class="toc-text">函数递归调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-number">9.</span> <span class="toc-text">数组和指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%81%94%E5%90%88%E4%BD%93"><span class="toc-number">10.</span> <span class="toc-text">结构体和联合体</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/1441608745.html" title="「高效能人士的七个习惯」读书笔记"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/b60a19efb0970a66b87460015b04961c.md.webp" onerror='this.onerror=null,this.src="https://img.gejiba.com/images/4f60b4e053a96873d937752732c06a09.gif"' alt="「高效能人士的七个习惯」读书笔记"></a><div class="content"><a class="title" href="/posts/1441608745.html" title="「高效能人士的七个习惯」读书笔记">「高效能人士的七个习惯」读书笔记</a><time datetime="2022-07-08T12:39:21.000Z" title="发表于 2022-07-08 20:39:21">2022-07-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1980352382.html" title="「关键对话」读书笔记"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/e23ded29a0c8c46be41bcbaf31ecec1f.md.webp" onerror='this.onerror=null,this.src="https://img.gejiba.com/images/4f60b4e053a96873d937752732c06a09.gif"' alt="「关键对话」读书笔记"></a><div class="content"><a class="title" href="/posts/1980352382.html" title="「关键对话」读书笔记">「关键对话」读书笔记</a><time datetime="2022-07-01T14:42:30.000Z" title="发表于 2022-07-01 22:42:30">2022-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3530858630.html" title="类图关系"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/b7b2bff1536fac218aae9798f503a825.md.webp" onerror='this.onerror=null,this.src="https://img.gejiba.com/images/4f60b4e053a96873d937752732c06a09.gif"' alt="类图关系"></a><div class="content"><a class="title" href="/posts/3530858630.html" title="类图关系">类图关系</a><time datetime="2022-06-26T07:07:31.000Z" title="发表于 2022-06-26 15:07:31">2022-06-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1155868944.html" title="库与运行库"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/ed0f3f7a012e4718162c75786caa867b.md.webp" onerror='this.onerror=null,this.src="https://img.gejiba.com/images/4f60b4e053a96873d937752732c06a09.gif"' alt="库与运行库"></a><div class="content"><a class="title" href="/posts/1155868944.html" title="库与运行库">库与运行库</a><time datetime="2022-06-22T12:35:28.000Z" title="发表于 2022-06-22 20:35:28">2022-06-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3697966026.html" title="装载与动态链接"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.gejiba.com/images/ed0f3f7a012e4718162c75786caa867b.md.webp" onerror='this.onerror=null,this.src="https://img.gejiba.com/images/4f60b4e053a96873d937752732c06a09.gif"' alt="装载与动态链接"></a><div class="content"><a class="title" href="/posts/3697966026.html" title="装载与动态链接">装载与动态链接</a><time datetime="2022-06-14T07:45:02.000Z" title="发表于 2022-06-14 15:45:02">2022-06-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022&nbsp;&nbsp;&nbsp;<i style="color:#ff6a6a;animation:announ_animation .8s linear infinite" class="fas fa-heart"></i>&nbsp;&nbsp;&nbsp;By Youngh</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="https://www.antmoe.com/js/utils.js"></script><script src="https://www.antmoe.com/js/main.js"></script><script src="https://cdn1.tianli0.top/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://cdn.staticfile.org/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="https://www.antmoe.com/js/search/local-search.js" defer></script><div class="js-pjax"><script>function loadValine(){function n(){new Valine(Object.assign({el:"#vcomment",appId:"fUqvuCwXzFgVcGgakVuftjjg-gzGzoHsz",appKey:"44H71E23JXOW8dMVSkYGsmAG",avatar:"monsterid",serverURLs:"",emojiMaps:"",path:window.location.pathname,visitor:!1},null))}"function"==typeof Valine?n():getScript("https://cdn1.tianli0.top/npm/valine/dist/Valine.min.js").then(n)}function loadOtherComment(){loadValine()}btf.loadComment(document.getElementById("vcomment"),loadValine)</script></div><script src="https://cdn1.tianli0.top/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script id="click-heart" src="https://cdn1.tianli0.top/npm/butterfly-extsrc@1/dist/click-heart.min.js" async mobile="false"></script><script src="https://cdn.casecori.top/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.tocScrollFn&&window.removeEventListener("scroll",window.tocScrollFn),window.scrollCollect&&window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),document.getElementById("rightside").style.cssText="opacity: ''; transform: ''",window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script");var o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script></div></body></html>