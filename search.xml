<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>装载与动态链接</title>
    <url>/posts/3697966026.html</url>
    <content><![CDATA[<p>在 <a href="https://younghblog.gitee.io/posts/1093737480.html">上一篇</a> 文章中，通过静态链接我们已经得到了可执行文件。为了使其运行起来，还需要将其读取到物理内存中才能被 CPU 执行。这篇文章就重点介绍一下可执行文件是如何被装载到物理内存的，以及动态链接的过程。</p>
<h2 id="装载"><a class="markdownIt-Anchor" href="#装载"></a> 装载</h2>
<p>当 ELF 可执行文件要被执行时，系统会先建立一个进程，具体过程如下：</p>
<ol>
<li>创建一个独立的虚拟地址空间。实际上只是创建虚拟地址空间与物理地址空间映射时所需的数据结构，而具体的映射关系则会推迟到发生页错误时才进行设置。</li>
<li>读取可执行文件头，建立虚拟空间与可执行文件的映射关系。这一步的目的是为了知道在发生缺页时该加载 <strong>可执行文件</strong>（又叫 <strong>映像文件</strong>）的哪个页到物理内存。</li>
<li>将指令寄存器设置成可执行文件的入口地址。该地址也记录在可执行文件头中。</li>
</ol>
<p>以上步骤执行完后实际上只是建立起了可执行文件与进程虚拟内存空间的映射关系，程序的指令和数据都还没被装入到内存。当 CPU 开始执行该程序时就会发生缺页异常，这时才会处理缺页。具体过程如下：</p>
<ol>
<li>根据上述建立的映射关系，计算出所缺页在可执行文件中的偏移。</li>
<li>在物理内存中分配一个物理页，并将所缺页从磁盘读入该物理页。</li>
<li>建立虚拟页与物理页的映射关系，然后重新执行导致缺页的指令。</li>
</ol>
<p>随着进程的执行，缺页会不断产生，操作系统也会不断地为其分配物理页来满足进程的需求，这样一个可执行文件就运行起来了。</p>
<h3 id="segment"><a class="markdownIt-Anchor" href="#segment"></a> Segment</h3>
<p>ELF 文件映射是以页为单位的，因此每个段都至少需要一个物理页，超出部分也将会单独占用一个页。一个 ELF 文件中有很多段，这必然会对内存空间造成很大的浪费。</p>
<p>那要怎样尽量减少这种浪费呢？</p>
<p>实际上操作系统并不关心 ELF 文件中各个段的具体内容，主要关心的是各个段所拥有的权限。这样一来，所有段基本上就被分成了三大类：</p>
<ul>
<li>以代码段为代表的 <strong>可读可执行</strong> 的段；</li>
<li>以数据段和 BSS 段为代表的 <strong>可读可写</strong> 的段；</li>
<li>以只读数据段为代表的 <strong>只读</strong> 段。</li>
</ul>
<p>因此可以把相同权限的段合并成一个段进行映射，从而减少页内碎片，达到节省内存空间的目的。</p>
<p>比如 <code>.text</code> 和 <code>.init</code> 分别是程序的可执行代码和初始化代码，它们具有相同的权限，那么装载时就可以将其作为一个 <strong>Segment</strong> 一起映射，即映射后虚拟内存空间中只有一个相应的 <strong>VMA</strong>（Virtual Memory Area）而不是两个。其中的 <code>.text</code> 和 <code>.init</code> 则称为 <strong>Section</strong>。</p>
<img src="https://img.gejiba.com/images/790b9378fe6204600abb5b28570b321e.webp" alt="1" style="zoom:50%;" />
<p>系统正是按 Segment 而不是 Section 来映射可执行文件的。正如描述 Section 属性的结构叫段表，描述 Segment 属性的结构叫 <strong>程序头</strong>（Program Header），它描述了 ELF 文件该如何被映射到进程的虚拟空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">    &gt; File Name: SectionMapping.c</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用静态链接的方式将其编译成可执行文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -static SectionMapping.c -o SectionMapping.elf -m32</span><br></pre></td></tr></table></figure>
<p>查看其程序头：</p>
<img src="https://img.gejiba.com/images/70d3f96c0712597db299adb2a7c57893.webp" alt="ph" style="zoom:55%;" />
<p>这里我们只关心 LOAD 类型，因为只有该类型的 Segment 是需要被映射的，其他类型只是用来辅助装载的。根据 Flg 类型，可执行文件会被映射到 4 个 VMA。</p>
<p>由于段地址以页为单位进行对齐，因此将 Section 合并成 Segment 进行装载时，虽然在一定程度上缓解了内存空间的浪费问题，但不得不承认，该问题仍然存在。例如：</p>
<img src="https://img.gejiba.com/images/6a495c4a3cb0908c6eed1c1f2e086df3.webp" alt="2" style="zoom:50%;" />
<p>因此有些 UNIX 系统采用了一个很取巧的办法——段合并。</p>
<h3 id="段合并"><a class="markdownIt-Anchor" href="#段合并"></a> 段合并</h3>
<p>所谓段合并，就是让那些各个段接壤部分共享一个物理页面，然后将该物流页面分别映射两次。如图：</p>
<img src="https://img.gejiba.com/images/42eb86f4e71e10dccbd55575f7345a6d.webp" alt="3" style="zoom:50%;" />
<p>可执行文件可以被加载到物理内存中的任意位置，因此页之间可以不连续。</p>
<p>段合并针对的是物理内存，虚拟空间中仍然按照 Segment 进行映射，即每个 Segment 都至少需要一个页，超出部分也将会单独占用一个页。</p>
<p>其实 UNIX 会将 ELF 文件头也看做一个段进行映射，因此从某种角度来看，段合并的过程为：</p>
<p>整个 ELF 文件从文件最开始到某个点结束（所有 LOAD 类型的段），逻辑上被分成以 4096 字节为单位的若干个块，每个块都会被装载到物理内存。对于那些包含两个段的块，将会被映射两次。</p>
<h3 id="堆和栈"><a class="markdownIt-Anchor" href="#堆和栈"></a> 堆和栈</h3>
<p>进程在执行时，还需要用到堆和栈，它们在进程的虚拟空间中也是以 VMA 的形式存在的。我们可以看一下 <code>SectionMapping.elf</code> 运行起来后的虚拟空间分布：</p>
<img src="https://img.gejiba.com/images/16084b25fb033a53a6aaf71ec88672b2.webp" alt="map" style="zoom:60%;" />
<p>其中，第一列是 VMA 的地址范围；第二列是 VMA 的权限，<code>p</code> 表示私有，<code>s</code> 表示共享；第三列表示 VMA 对应的 Segment 在映像文件中的偏移；第四列表示映像文件所在设备的主设备号和次设备号；第五列表示映像文件的节点号；最后一列是映像文件的路径。</p>
<p>可以看到，前五个 Segment 是映射到可执行文件的，而剩余几个段的主设备号、次设备号、文件节点号都是 0，表示它们没有映射到文件中，这种 VMA 叫做 <strong>匿名虚拟内存区域</strong>（Anonymous Virtual Memory Area）。这里堆和栈均只有读写权限，这与书中的描述有些出入，这应该是优化之后的结果。</p>
<h3 id="进程栈初始化"><a class="markdownIt-Anchor" href="#进程栈初始化"></a> 进程栈初始化</h3>
<p>进程刚开始启动时需要知道一些运行环境，最基本的就是系统环境变量和程序的运行参数，这些信息通常会被提前保存到 Stack VMA。</p>
<p>假设系统中有两个环境变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HOME=/home/user</span><br><span class="line">PATH=/usr/bin</span><br></pre></td></tr></table></figure>
<p>运行该程序的命令为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">prog 123</span><br></pre></td></tr></table></figure>
<p>进程初始化后的堆栈如图所示：</p>
<img src="https://img.gejiba.com/images/d212c3a8b5ae2016e6abf790e7057a3e.webp" alt="ProcessStack" style="zoom:55%;" />
<p>其中，esp 指向栈顶，前 4 个字节表示命令行参数的数量，这里是 <code>prog</code> 与 <code>123</code> 共 2 个参数，紧接着就是指向这两个字符串的指针。之后是一个 0，表示命令行读取结束。再后面是指向环境变量字符串的指针，最后还是以 0 表示结束。</p>
<p>进程启动后，初始化堆栈中的参数信息部分会被传递给 main 函数，即 <code>argc</code> 和 <code>argv</code> 两个参数。</p>
<h2 id="动态链接"><a class="markdownIt-Anchor" href="#动态链接"></a> 动态链接</h2>
]]></content>
      <categories>
        <category>读书笔记 - 程序员的自我修养</category>
      </categories>
      <tags>
        <tag>动态链接</tag>
      </tags>
  </entry>
  <entry>
    <title>静态链接</title>
    <url>/posts/1093737480.html</url>
    <content><![CDATA[<p class='div-border yellow left right'><b><font color="green">粽</font> 有 千 古 ， 横 有 八 荒</b></br><b>前 途 似 海 ， 来 日 方 长</b></br>—— 今日端午，祝各位端午安康❤️</p>
<p>本文对应原书的第 2 部分，主要介绍了目标文件的格式和静态链接的详细过程。这里我以原书中的示例代码作为切入点进行介绍。</p>
<p>首先厘清几个概念，方便对文章的理解。</p>
<h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2>
<ol>
<li>
<p>编译生成的 <code>.o</code> 文件叫做可重定位目标文件，或者 <strong>目标文件</strong>，也叫 <strong>模块</strong>。</p>
</li>
<li>
<p><strong>链接器</strong> 所做的工作，无非就是把指令中对其他符号地址的引用加以修正。地址修正的过程就是 <strong>重定位</strong>，每个需要被修正的地方都是一个 <strong>重定位入口</strong>（Relocation Entry）。</p>
</li>
<li>
<p><strong>符号决议</strong>，其实就是地址绑定。只不过 <strong>决议</strong> 更倾向于静态链接，<strong>绑定</strong> 则倾向于动态链接。</p>
</li>
<li>
<p>目标文件（relocatable）就是按照可执行文件的格式存储的，只是因为还没有链接，可能有些符号或地址尚未被调整。Linux 的可执行文件格式是 <strong>ELF</strong>（Executable Linkable Format），ELF 的文件类型包括可重定位（relocatable）文件、可执行（executable）文件、共享目标（shared object）文件以及核心转储文件（core file），可通过 <code>file</code> 命令查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ file hello.o</span><br><span class="line">hello.o: hello.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped</span><br><span class="line"></span><br><span class="line">$ file hello</span><br><span class="line">hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=390f7f9d3ca8fb1e58ea8b44348b84c47e8ff45a, <span class="keyword">for</span> GNU/Linux 3.2.0, not stripped</span><br><span class="line"></span><br><span class="line">$ file /lib/libdmmp.so.0.2.0</span><br><span class="line">/lib/libdmmp.so.0.2.0: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=6f45d79f689c7bf1c7677423d33ad92a7b835fbc, stripped</span><br><span class="line"></span><br><span class="line">$ file coredump</span><br><span class="line">coredump: ELF 64-bit LSB core file, x86-64, version 1 (SYSV), SVR4-style, from <span class="string">&#x27;./hello.out&#x27;</span>, real uid: 0, effective uid: 0, real gid: 0, effective gid: 0, execfn: <span class="string">&#x27;./hello.out&#x27;</span>, platform: <span class="string">&#x27;x86_64&#x27;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>实际上，在新版本的 gcc 中，通过 <code>file</code> 查看到的可执行文件的格式是 <code>shared object</code>，这是因为编译器默认启用了 <code>-pie</code> 标志，因此只要在编译时添加编译选项 <code>-no-pie</code> 即可变成 <code>executable</code>，详情参见👉 <a href="https://blog.csdn.net/weixin_43833642/article/details/104557656">这篇博客</a>。其中 <code>-pie</code> 的作用我会在下一篇博客中介绍。</p>
</blockquote>
</li>
</ol>
<h2 id="目标文件里有什么"><a class="markdownIt-Anchor" href="#目标文件里有什么"></a> 目标文件里有什么</h2>
<p>目标文件中除了会包含编译后生成的代码和数据之外，还包括了链接时所需要的一些信息，如符号表、字符串表、调试信息等。这些信息按照不同的属性，以 <strong>段</strong>（Segment 或 <strong>Section</strong>） 的形式存储。下面以 <code>SimpleSection.o</code> 为例看一下其内部细节。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">    &gt; File Name: SimpleSection.c</span></span><br><span class="line"><span class="comment">    &gt; Author: Youngh</span></span><br><span class="line"><span class="comment">    &gt; Mail: younghblog@gmail.com</span></span><br><span class="line"><span class="comment">    &gt; Created Time: 2022-06-01 09:32:47</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_init_var = <span class="number">84</span>;</span><br><span class="line"><span class="type">int</span> g_uninit_var;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_static_init_var = <span class="number">83</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_static_uninit_var;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_init_var = <span class="number">85</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_uninit_var;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    func(static_init_var + static_uninit_var + a + b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们以 32 位模式进行编译（并未链接），以生成目标文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -c SimpleSection.c -m32</span><br></pre></td></tr></table></figure>
<p>通过 <code>objdump -h</code> 可以查看目标文件中关键段的基本信息：</p>
<img src="https://img.gejiba.com/images/ec9d561dc4b120e5145d865154af241e.webp" alt="关键段" style="zoom:60%;" />
<center>图2-1 关键段</center>
<p>打印出的信息共有 7 列，<code>Size</code> 表示段的长度；<code>VMA</code> 即 Virtual Memory Address，是段的虚拟地址，<code>LMA</code> 即 Load Memory Address，是段的装载地址，正常情况下两个值是一样的，但在某些嵌入式系统，特别是将程序放在 ROM 中的系统中值会不同；<code>File off</code> 是段所在的位置。</p>
<p>在段名一列，可以看到除了我们熟悉的 <code>.text</code>、<code>.data</code>、<code>.bss</code> 和 <code>.rodata</code> 之外，还有一些其他段。其中 <code>.comment</code> 存放的是编译器的版本信息，<code>.note.GNU-stack</code> 是堆栈提示段，剩余段暂不细究。</p>
<p>每个段的第 2 行表示段的各种属性。<code>CONTENTS</code> 表示该段在文件中存在，可以看到 <code>.bss</code> 段实际上在 ELF 文件中并不存在内容；<code>.note.GNU-stack</code> 段虽然有 <code>CONTENTS</code>，但其长度为 0，我们暂且也认为它在 ELF 文件中不存在。</p>
<p>根据上述打印出的信息，我们可以画出该目标文件的结构图：</p>
<img src="https://img.gejiba.com/images/3d04b951138994a76311dc3a02f49608.webp" alt="SSo" style="zoom:45%;" />
<center>图2-2 SimpleSection.o结构</center>
<p>接下来分别看一下各个段里的内容。</p>
<h3 id="代码段"><a class="markdownIt-Anchor" href="#代码段"></a> 代码段</h3>
<p>通过 <code>objdump -s</code> 可以查看目标文件中所有段的内容，并以十六进制的形式展示；而 <code>-d</code> 可以将所有包含指令的段反汇编。因此，执行 <code>objdump -s -d SimpleSection.o</code> 则可以同时打印这些内容。</p>
<p>由于内容过多，我将只截取与当前主题相关的信息：</p>
<img src="https://img.gejiba.com/images/31f2ef1fcf46e594e60400dc0b75ad9f.webp" alt="text" style="zoom:65%;" />
<center>图2-3 .text段</center>
<p>其中最左边一列是 <code>.text</code> 中的内容在该段中的偏移量，中间 4 列是十六进制内容，最右边一列是 <code>.text</code> 段的 ASCII 码形式。对照下面的反汇编结果，可以发现二者完全一致，因此 <code>.text</code> 段包含了 <code>func()</code> 与 <code>main()</code> 两个函数的所有指令。</p>
<h3 id="数据段和只读数据段"><a class="markdownIt-Anchor" href="#数据段和只读数据段"></a> 数据段和只读数据段</h3>
<img src="https://img.gejiba.com/images/07704393c9c5253e1e0eccfad5073f82.webp" alt="data&rodata" style="zoom:60%;" />
<center>图2-4 .data&.rodata段</center>
<p><code>.data</code> 段保存的是已初始化且值不为 0 的全局变量和静态变量，在 <code>SimpleSection.c</code> 中对应 <code>g_init_var</code>、<code>g_static_init_var</code> 与 <code>static_init_var</code> 三个变量。从上图可以看到，该段保存的内容有三个值（小端法），分别是 <code>0x00000054</code>、<code>0x00000053</code> 与 <code>0x00000055</code>，分别对应十进制的 84、83 和 85，正好对应上述三个变量。</p>
<p>在 <code>SimpleSection.c</code> 中调用 <code>printf()</code> 时用到了一个字符串常量 <code>%d\n</code>，它是只读的，因此放在 <code>.rodata</code> 段。从上图可以看到，该段保存的内容为 <code>25 64 01 00</code>，分别对应 ASCII 值 <code>% d \n \0</code>，其中 <code>\0</code> 是结束标志。</p>
<h3 id="bss-段"><a class="markdownIt-Anchor" href="#bss-段"></a> BSS 段</h3>
<p><code>.bss</code> 段存放的是未初始化和初始化为 0 的全局变量和静态变量，在 <code>SimpleSection.c</code> 中对应 <code>g_uninit_var</code>、<code>g_static_uninit_var</code> 与 <code>static_uninit_var</code> 三个 int 型变量，因此该段的大小应该为 12 个字节，但图 2-1 却显示该段大小只有 8 个字节。</p>
<p>我们可以查看一下目标文件的符号信息：</p>
<img src="https://img.gejiba.com/images/22aab797f0251672803f931d2e3fbfc6.webp" alt="symboltable" style="zoom:60%;" />
<center>图2-5 符号表内容</center>
<p>可以看到 <code>.bss</code> 段只会存放未初始化的静态变量，而未初始化的全局变量 <code>g_uninit_var</code> 则没有存放在任何段，只是一个未定义的 <code>COMMON</code> 符号。</p>
<p><code>.bss</code> 段其实并没有实际存放数据，即它并不会占用磁盘空间，只是通过记录这些未初始化静态变量的大小，达到为其预留空间的目的。更具体地讲，该段只是节省了最终存储在磁盘中的文件所占用的空间，而一旦该文件被装载到内存，就需要为其分配相应大小的内存空间，这样才能保证程序正确运行。</p>
<p><strong><span class="p red">那为什么未初始化的全局变量没有放在 <code>.bss</code> 段呢？</span></strong></p>
<p>这主要是因为未初始化的全局变量是 <strong>弱符号</strong>，在链接时该符号有可能在其他模块中所占的空间更大，那编译器就应该为该符号分配更大的空间。也就是说，在编译阶段并不能确定该符号的大小，所以 <code>.bss</code> 段并不知道应该为其分配多大的空间。当链接完成之后，任何一个弱符号的大小就确定下来了，因此会在最终的可执行文件中的 <code>.bss</code> 段为其分配空间。</p>
<p>由此可知，在最终生成的可执行文件中，未初始化或初始化为 0 的全局变量和静态变量都是存放在 <code>.bss</code> 段的，只是在链接之前，<code>.bss</code> 段只存放了未初始化或初始化为 0 的静态变量。</p>
<p>关于弱符号，我后面会做详细介绍，这里只需有个印象即可。</p>
<h2 id="elf-文件结构描述"><a class="markdownIt-Anchor" href="#elf-文件结构描述"></a> ELF 文件结构描述</h2>
<p>通过以上介绍，我们已经可以大致勾勒出 ELF 文件的轮廓，接下来我们进一步看一下该目标文件的详细内容。</p>
<p>ELF 目标文件以 <strong>ELF 文件头</strong>（ELF Header）开始，该结构描述了整个文件的基本属性。</p>
<p>紧接着就是 ELF 文件的各个段，每个段的基本信息是保存在 <strong>段表</strong>（Section Header Table）中的，段表也在该目标文件中。</p>
<p>另外还会有一些其他辅助结构，比如符号表、字符串表以及重定位表等。</p>
<h3 id="文件头"><a class="markdownIt-Anchor" href="#文件头"></a> 文件头</h3>
<p>查看 ELF 文件头：</p>
<img src="https://img.gejiba.com/images/7821e360ff1a2f910949afd1ed24053c.webp" alt="ELFHeader" style="zoom:60%;" />
<center>图3-1 ELF文件头</center>
<ul>
<li>
<p><strong>ELF 魔数</strong>。描述了 ELF 文件的平台属性。前 4 个字节是所有 ELF 文件都必须相同的标识码，其中第一个字节对应 ASCII 字符里的 DEL 控制符，后面三个字节分别对应 ELF 三个字母。其余每个字节的含义都已在图中标出。需要说明的是，ELF 文件的主版本号一般是 1，因为 ELF 自 1.2 以后就再没更新了。</p>
<img src="https://img.gejiba.com/images/31aa7c216dc6e241ae8fe37267672daf.webp" alt="Magic" style="zoom:55%;" />
<center>图3-2 魔数</center>
</li>
<li>
<p>数据存储方式：用补码（2’s complement）表示有符号数，用小端法存储。</p>
</li>
<li>
<p>Type：表示 ELF 文件类型。系统正是据此来判断 ELF 文件类型的，而不是通过文件扩展名。</p>
</li>
<li>
<p>ELF 文件头大小为 52 个字节，对应十六进制 0x34，因此其结束地址即为 0x34。</p>
</li>
<li>
<p>段表的位置在 1212 处，对应十六进制的 0x4bc。段表中有 16 个元素，每个元素的大小为 40 个字节，因此段表的大小为 16 * 40 = 640 = 0x280，于是段表的结束地址为 0x4bc + 0x280 = 0x73c。</p>
<p>我们再来查看一下目标文件的大小：</p>
<img src="https://img.gejiba.com/images/662d52cb1f04c6822004f4c9316d3414.webp" alt="ObjectSize" style="zoom:60%;" />
<center>图3-3 目标文件大小</center>
<p>目标文件的大小是 1852 个字节，对应十六进制为 0x73c，因此其虚拟地址范围为 0x000 ~ 0x73c，由此可知段表就在该目标文件的末尾。</p>
</li>
</ul>
<h3 id="段表"><a class="markdownIt-Anchor" href="#段表"></a> 段表</h3>
<p><strong>段表</strong>（Section Header Table）保存了段的基本属性，比如每个段的名字、长度、偏移、读写权限等等。换言之，<strong>ELF 文件的段结构是由段表决定的</strong>，编译器、链接器和装载器也都是依靠段表来定位和访问各个段的属性的。</p>
<p>前面我们通过 <code>objdump -h</code> 只是打印出了 ELF 文件中的关键段，下面我们通过打印段表来查看一下 ELF 文件的完整的段：</p>
<img src="https://img.gejiba.com/images/e4dd2cb1f932587d4d2c6ae7d4a67a93.webp" alt="SectionHeader" style="zoom:55%;" />
<center>图3-4 段表信息</center>
<ul>
<li>
<p>Nr：段的索引。通过其他命令查询到的段的索引与这里相对应。</p>
</li>
<li>
<p>Type：段的类型，共有如下几种类型：</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">值</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NULL</td>
<td style="text-align:center">0</td>
<td style="text-align:center">无效段</td>
</tr>
<tr>
<td style="text-align:center">PROGBITS</td>
<td style="text-align:center">1</td>
<td style="text-align:center">程序段，包括代码段和数据段</td>
</tr>
<tr>
<td style="text-align:center">SYMTAB</td>
<td style="text-align:center">2</td>
<td style="text-align:center">符号表</td>
</tr>
<tr>
<td style="text-align:center">STRTAB</td>
<td style="text-align:center">3</td>
<td style="text-align:center">字符串表</td>
</tr>
<tr>
<td style="text-align:center">RELA</td>
<td style="text-align:center">4</td>
<td style="text-align:center">重定位表</td>
</tr>
<tr>
<td style="text-align:center">HASH</td>
<td style="text-align:center">5</td>
<td style="text-align:center">符号表的哈希表</td>
</tr>
<tr>
<td style="text-align:center">DYNAMIC</td>
<td style="text-align:center">6</td>
<td style="text-align:center">动态链接信息</td>
</tr>
<tr>
<td style="text-align:center">NOTE</td>
<td style="text-align:center">7</td>
<td style="text-align:center">提示性信息</td>
</tr>
<tr>
<td style="text-align:center">NOBITS</td>
<td style="text-align:center">8</td>
<td style="text-align:center">在文件中没有内容</td>
</tr>
<tr>
<td style="text-align:center">REL</td>
<td style="text-align:center">9</td>
<td style="text-align:center">包含重定位信息</td>
</tr>
<tr>
<td style="text-align:center">SHLIB</td>
<td style="text-align:center">10</td>
<td style="text-align:center">保留</td>
</tr>
<tr>
<td style="text-align:center">DNYSYM</td>
<td style="text-align:center">11</td>
<td style="text-align:center">动态链接的符号表</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Addr：段的虚拟地址。如果该段可以被加载，则为加载后在进程虚拟地址空间中的地址，否则为 0。</p>
</li>
<li>
<p>Off：该段在文件中的偏移量。</p>
</li>
<li>
<p>ES：即 Entry Size。若该段包含了一些大小固定的项，则此值表示每个项的大小，否则为 0。</p>
</li>
<li>
<p>Flg：段的标志位。其中 A（Alloc）表示该段在进程空间中需要分配空间。</p>
</li>
<li>
<p>Al：即 Address Alignment，段地址对齐。0 和 1 表示没有对齐要求。</p>
</li>
</ul>
<h3 id="重定位表"><a class="markdownIt-Anchor" href="#重定位表"></a> 重定位表</h3>
<p>在链接时需要知道哪些指令需要被调整，指令的哪些部分需要被调整，以及怎么调整，而 <strong>重定位表</strong> 就是用来记录重定位相关信息的。</p>
<p>严格来说，重定位表实际上应该叫重定位段，因为每个要被重定位的 ELF 段都有一个对应的重定位表，比如 <code>.rel.text</code>、<code>.rel.data</code> 等，可以通过以下命令来查看目标文件中的重定位表：</p>
<img src="https://img.gejiba.com/images/5316a41dae31cc6739591afb4bc8cbea.webp" alt="rel" style="zoom:60%;" />
<center>图3-5 重定位表</center>
<p>其中 <code>OFFSET</code> 对应指令中需要调整的地址，可以结合反汇编代码进行查看：</p>
<img src="https://img.gejiba.com/images/1131223a0715763943fec8ec777b31a6.webp" alt="objdump" style="zoom:60%;" />
<center>图3-6 反汇编代码</center>
<p>以需要重定位的 <code>printf</code> 为例，其地址为 0x25，对应到反汇编代码中正好是 call 指令所调用的 printf 的地址。<code>TYPE</code> 表示重定位符号的调整方式，函数和变量的调整方式是不一样的。</p>
<h3 id="字符串表"><a class="markdownIt-Anchor" href="#字符串表"></a> 字符串表</h3>
<p>引用字符串表中的字符串只需给出一个下标，然后一直往后读，直到遇到 <code>\0</code>（0x00）停止。</p>
<p>在图 3-4 中，有两个字符串表，分别是 <code>.strtab</code> 与 <code>.shstrtab</code>，它们的索引分别是 14 和 15。其中：</p>
<ul>
<li>
<p><code>.strtab</code> 是 <strong>字符串表</strong>，用来保存普通的字符串，比如符号名：</p>
<img src="https://img.gejiba.com/images/cce93cd82ced57b9fbc97ef9c5231f2d.webp" alt="strtab" style="zoom:60%;" />
<center>图3-7 .strtab内容</center>
<p>第一列即表示字符串在该表中的下标，下同。</p>
</li>
<li>
<p><code>.shstrtab</code> 是 <strong>段表字符串表</strong>，用来保存段表中的字符串，通常是段名：</p>
<img src="https://img.gejiba.com/images/f5d75fab13c920843e0fa3df2b0c448b.webp" alt="shstrtab" style="zoom:60%;" />
<center>图3-8 .shstrtab内容</center>
</li>
</ul>
<h3 id="符号表"><a class="markdownIt-Anchor" href="#符号表"></a> 符号表</h3>
<p><strong>符号表</strong>（<code>.symtab</code>）记录了目标文件中所用到的所有符号，我们可以打印出来看一下：</p>
<img src="https://img.gejiba.com/images/efd17aa4a2c29631be034a30e124a57b.webp" alt="symtab" style="zoom:55%;" />
<center>图3-9 符号表内容</center>
<p>符号表的第一个元素，即下标为 0 的元素总是一个无效的未定义符号。接下来我们从最右边一列开始看起：</p>
<ul>
<li>Name：可以看到有些符号的名字并没有显示，这些符号都是段名，根据 Ndx 可以在图 3-4 中找到相应的段名。</li>
<li>Ndx：符号所在段，可以结合图 3-4 查看。另外 <code>UND</code> 是未定义（如 printf），表示该符号在本文件中被引用，但却在其他文件中定义；<code>ABS</code> 表示该符号包含一个绝对的值；<code>COM</code> 表示该符号是一个 COMMON 类型的符号，如未初始化的全局变量 <code>g_uninit_var</code>。</li>
<li>Vis：在 C/C++ 中未使用，我们暂时忽略它。</li>
<li>Bind：符号绑定信息。<code>LOCAL</code> 表示局部符号，仅本目标文件可见；<code>GLOBAL</code> 表示全局符号，外部可见；<code>WEAK</code> 表示弱引用。</li>
<li>Type：符号类型。<code>NOTYPE</code> 表示未知类型的符号；<code>FILE</code> 表示该符号是文件名；<code>SECTION</code> 表示该符号是一个段；<code>OBJECT</code> 表示该符号是个数据对象，例如变量、数组等；<code>FUNC</code> 表示该符号是个函数或其他可执行代码。</li>
<li>Size：符号大小。对于包含数据的符号，该值是数据类型的大小。0 表示该符号大小为 0 或未知。</li>
</ul>
<h3 id="重绘目标文件结构"><a class="markdownIt-Anchor" href="#重绘目标文件结构"></a> 重绘目标文件结构</h3>
<p>基于以上信息，我们在之前的基础上对 <code>SimpleSection.o</code> 的结构做了进一步完善（灰色段表示在本文中没有细究）：</p>
<img src="https://img.gejiba.com/images/cb5b8a4a7dc373f2c7465b5c7fb13fbf.webp" alt="SimpleSection" style="zoom:70%;" />
<center>图3-10 SimpleSection.o结构</center>
<p>可以看到在段表字符串表（.shstrtab）与段表（Section Header Table）之间存在 3 个字节的间隙，这是对齐所造成的。</p>
<h2 id="符号和引用"><a class="markdownIt-Anchor" href="#符号和引用"></a> 符号和引用</h2>
<p>我们从图 3-9 可以看到变量 <code>static_init_var</code> 与 <code>static_uninit_var</code> 变成了 <code>static_init_var.1513</code> 与 <code>static_uninit_var.1514</code>，这是 <strong>符号修饰</strong> 的结果，主要是为了防止符号冲突。</p>
<p>不同编译器采用了不同的符号修饰方法，因此不同编译器编译生成的目标文件之间无法正常链接。C++ 为了能够与 C 兼容引入了 <code>extern &quot;C&quot;</code>，从而保证该部分代码能够被当做 C 语言处理，C++ 的符号修饰机制将不会对该部分代码起作用，这样就保证了 C 库函数能够正常使用。</p>
<p>尽管有符号修饰，当多个目标文件中含有相同名字的全局符号定义时，链接过程中仍然会出现 <strong>符号重定义</strong> 的错误，这就涉及到了强弱符号的概念。</p>
<p>对于 C/C++，编译器会默认 <span class="p red">函数</span> 和 <span class="p red">初始化的全局变量</span> 为 <strong>强符号</strong>，而 <span class="p red">未初始化的全局变量</span> 为 <strong>弱符号</strong>，也可已通过 GCC 的 <code>__attribute__((weak))</code> 来定义任何一个强符号为弱符号。</p>
<p>根据强弱符号的概念，链接器的处理规则如下：</p>
<ol>
<li>规则 1：不允许强符号被多次定义，否则会报重复定义的错误；</li>
<li>规则 2：如果一个符号在某个目标文件中是强符号，在其他目标文件中是弱符号，那么会选择强符号；</li>
<li>规则 3：如果一个符号在所有目标文件中都是弱符号，那么选择其中占空间最大的那个。</li>
</ol>
<p>当一个目标文件中存在对外部目标文件中符号的引用时，链接过程中如果找不到该符号的定义，链接器就会报符号未定义错误，这种引用称为 <strong>强引用</strong>。</p>
<p>与之相对的还有 <strong>弱引用</strong>，处理弱引用时，如果该符号有定义则正常链接，如果没有也不会报错。对于未定义的弱引用，链接器会默认其为 0 或是一个特殊值，以便程序代码能够识别。</p>
<p>弱符号和弱引用对于库来说十分有用。比如库中定义的弱符号可以被用户定义的强符号覆盖，从而使用自定义版本的库函数；或者可以将某些扩展功能模块的引用定义为弱引用，这样当扩展模块与程序链接在一起时扩展功能可以正常使用，即使去掉了某些功能模块程序也可以正常链接，只是缺少了相应功能。</p>
<h2 id="静态链接"><a class="markdownIt-Anchor" href="#静态链接"></a> 静态链接</h2>
<p>静态链接采用 <strong>相似段合并</strong> 的方式，将多个目标文件中的代码段、数据段等分别进行合并，生成最终的可执行目标文件。整个链接过程分两步：</p>
<ul>
<li>第一步：空间与地址分配。扫描所有的输入目标文件，获取各个段的长度、属性和位置，并将符号表中所有的符号定义和符号引用统一放到全局的符号表中。链接器会将所有相同段合并，计算出各个段合并后的长度和位置，并与输入的目标文件建立映射关系。</li>
<li>第二部：符号解析与重定位。读取重定位信息，进行符号解析与重定位。</li>
</ul>
<p>这里以一个例子来介绍静态链接过程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">    &gt; File Name: a.c</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> shared;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *, <span class="type">int</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    swap(&amp;a, &amp;shared);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">    &gt; File Name: b.c</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> shared = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> &#123;</span><br><span class="line">    *a ^= *b ^= *a ^= *b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以 32 位模式将其编译成目标文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -c a.c b.c -m32 -fno-stack-protector</span><br></pre></td></tr></table></figure>
<p>这里之所以要去掉栈保护，是因为链接时会报 __stack_chk_fail_local 未定义错误。</p>
<p>使用 ld 链接器将二者链接起来，并且为了避免引入多余文件，将 main 指定为程序入口（默认为 _start）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ld -m elf_i386 a.o b.o -e main -o ab</span><br></pre></td></tr></table></figure>
<p>这里要加 <code>-m elf_i386</code> 是因为目标文件是 i386 架构，是 32 位的，而我机器上的 ld 默认是 i386:x86-64，是 64 位的，二者不兼容，因此需要指定链接器生成 32 位的可执行文件。</p>
<p>打印出链接前后各个段的属性（这里对输出做了简化）：</p>
<img src="https://img.gejiba.com/images/a1d1f4f2ae87701ac800fe9e6bdef6f7.webp" alt="a" style="zoom:60%;" />
<img src="https://img.gejiba.com/images/cc99cf40690aab83f2c000217aa26c6c.webp" alt="b" style="zoom:60%;" />
<img src="https://img.gejiba.com/images/f55c7828276c81f3bbfbde9d4c40041f.webp" alt="ab" style="zoom:60%;" />
<center>图4-1 链接前后</center>
<p>链接前，目标文件中所有段的虚拟地址都是 0，这是因为虚拟空间还没有分配；</p>
<p>链接后，可执行文件中的各个段都被分配到相应的虚拟地址。链接过程如下图：</p>
<img src="https://img.gejiba.com/images/dc9af7ad765e3fad30359317eee70a50.webp" alt="ld" style="zoom:60%;" />
<center>图4-2 链接过程</center>
<p>关于符号解析与重定位在上文的 <a href="#%E7%AC%A6%E5%8F%B7%E8%A1%A8">符号表</a> 与 <a href="#%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8">重定位表</a> 中有相关介绍，这里就不再赘述了。</p>
]]></content>
      <categories>
        <category>读书笔记 - 程序员的自我修养</category>
      </categories>
      <tags>
        <tag>静态链接</tag>
        <tag>ELF</tag>
      </tags>
  </entry>
  <entry>
    <title>温故而知新</title>
    <url>/posts/2281565213.html</url>
    <content><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>在整理 <a href="https://younghblog.gitee.io/categories/读书笔记-CSAPP/" target="_blank">CSAPP</a> 的这段时间，我阅读了《程序员的自我修养—链接、装载与库》这本经典书籍。书中基于 Linux 和 Windows 两大平台，介绍了系统软件的运行机制和原理，对链接、装载和库进行了深入浅出的剖析，强烈推荐❤️对系统底层感兴趣的各位小伙伴去阅读原书！</p>
<p>初次阅读，有点磕磕绊绊，所以趁现在有时间打算重新看一遍，顺便整理下笔记📝一方面加深理解，一方面便于查阅。这里我只会整理 Linux 平台下的相关笔记，Windows 暂时不打算看。</p>
<h2 id="思维导图"><a class="markdownIt-Anchor" href="#思维导图"></a> 思维导图</h2>
<p>由于线程相关概念与本书关系不大，后续内容也并没有对其做过多介绍，因此我在思维导图中对线程部分的描述会相对详细一些。</p>
<p><img src="https://img.gejiba.com/images/6f68bfa4ba88cb89dc5c0c7987bf064b.webp" alt="第一章思维导图" /></p>
]]></content>
      <categories>
        <category>读书笔记 - 程序员的自我修养</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟内存知多少</title>
    <url>/posts/1869698891.html</url>
    <content><![CDATA[<h2 id="认识虚拟内存"><a class="markdownIt-Anchor" href="#认识虚拟内存"></a> 认识虚拟内存</h2>
<p>虚拟内存是对主存和磁盘 I/O 设备的抽象，是 CPU 与物理内存之间的一个中间层。</p>
<p class='div-border white left right' style="border:1px solid #03a9f4; border-left-style: solid;border-left-width: 5px;border-right-style: solid; border-right-width: 5px;">计算机系统提供了不同层次的抽象表示，以隐藏实际实现的复杂性：</br></br><img src="https://img.gejiba.com/images/a8a67beaae798f3f562ff3c5e9048046.webp" alt="abstract" style="zoom:35%;" /></br>其中，操作系统是对硬件资源的抽象。</p>
<p>虚拟内存主要用来解决应用程序对内存需求日益增长的问题：现代物理内存的容量增长已经非常快了，但还是跟不上应用程序对主存需求的增长速度，即对于应用程序来说内存可能还是不够用，这就是虚拟内存出现的原因。</p>
<p>虚拟内存为每个进程提供了一个大的、一致的且私有的地址空间，同时提供了三个非常重要的能力：</p>
<ol>
<li>缓存机制。将主存看做磁盘的缓存，主存中只保留活动区域，并根据需要在主存和磁盘之间来回传送数据，从而使主存得到了高效的利用。</li>
<li>内存管理。为每个进程提供了一致的地址空间，从而简化了内存管理。</li>
<li>进程保护。每个进程的地址空间都是私有的，不会被其他进程破坏。</li>
</ol>
<h2 id="虚拟页"><a class="markdownIt-Anchor" href="#虚拟页"></a> 虚拟页</h2>
<p><span class="p red"><b>从概念上来说，虚拟内存是存放在磁盘上的一个地址连续的数组。</b></span>数组索引是虚拟地址，数组中的内容被缓存在主存中。</p>
<p>虚拟内存与物理内存之间以页为单位传送数据。虚拟内存中的页称为 <strong>虚拟页</strong>，物理内存中的页称为 <strong>物理页</strong>，物理页也叫 <strong>页帧</strong> 或 <strong>页框</strong>（page frame）。</p>
<p>虚拟页一共有三种状态：</p>
<ol>
<li><strong>未分配</strong>：磁盘中还没有任何数据与之相关联。</li>
<li><strong>已缓存</strong>：已分配，并且已经缓存在了物理内存中。</li>
<li><strong>未缓存</strong>：已分配，但尚未缓存在物理内存中。</li>
</ol>
<p><span class="p red"><b>从实现上来说，虚拟内存只是存放在内存中的一个数据结构。</b></span></p>
<p>进程执行前需要先装载，由于装载时已经建立了虚拟空间与可执行文件的映射关系，所以对于可执行文件中的任意虚拟页的访问，只会有缓存和未缓存两种状态。</p>
<p>未分配状态指的是磁盘中的空闲内存，可以通过内存分配函数（如 malloc）进行申请。</p>
<p>虚拟页往往很大，通常是 4KB ~ 2MB，这主要是因为主存的不命中处罚很大（主存不命中时访问磁盘的时间较长），为了补偿这些较长的访问时间，倾向于使用较大的数据块。并且由于大的不命中处罚，DRAM 缓存是全相联的，即任何虚拟页都可以放置在任何物理页中。</p>
<h2 id="页表"><a class="markdownIt-Anchor" href="#页表"></a> 页表</h2>
<p>如何判断一个虚拟页是否缓存到了 DRAM 中，以及缓存到了 DRAM 中的哪个物理页呢？除了需要依靠操作系统和 MMU 的支持外，还有一个非常重要的数据结构就是 <strong>页表</strong>。</p>
<p>每个进程都有自己的页表，页表保存在物理内存中，负责将虚拟页映射到物理页。每次 MMU 要将一个虚拟地址转换为物理地址时，都会读取页表。页表中的内容是由操作系统维护的。</p>
<p>页表中的每一项都是一个页表条目（Page Table Entry，PTE），每个虚拟页都会对应一个 PTE。这里先假设每个 PTE 只由 1 个有效位和 1 个 n 位地址字段组成。</p>
<p>有效位为 1 表示相应虚拟页被缓存到了物理内存中，而后面的地址字段就是相应物理页的地址。</p>
<p>如果有效位为 0，则表示相应虚拟页尚未缓存（地址字段指向该虚拟页在磁盘上的地址）或尚未分配（地址字段为空）。</p>
<img src="https://img.gejiba.com/images/1f533acea037920622ed8aae9cf30c54.webp" alt="页表" style="zoom:35%;" />
<p>上图展示了 8 个虚拟页和 4 个物理页所对应的页表。有 4 个虚拟页被缓存在了物理内存中，因此页表中对应项的有效位为 1，并且地址指向物理页；VP0 和 VP5 尚未分配，因此页表中对应项的有效位为 0，地址为空；VP3 和 VP6 已分配但尚未缓存，因此页表中对应项的有效位为 0，地址指向磁盘中的虚拟页。</p>
<h2 id="缺页"><a class="markdownIt-Anchor" href="#缺页"></a> 缺页</h2>
<p>对于已缓存的虚拟页可以直接命中，这种情况比较简单，这里重点看一下对于未缓存的虚拟页所导致的页不命中的情况，即缺页。</p>
<p>如图，CPU 要访问 VP3，但其并未缓存在 DRAM 中。此时 MMU 从页表中读取 PTE3，从有效位推断出 VP3 未被缓存，于是便触发了缺页异常。</p>
<img src="https://img.gejiba.com/images/5f5f928b95feb1ea1eb5aa38a898238e.webp" alt="BeforePageFault" style="zoom:35%;" />
<p>缺页异常会调用内核中相应的处理程序，从物理页中选择一个牺牲页（比如 VP4），用来存放 VP3。如果 VP4 已被修改，那么内核会将其写回磁盘。</p>
<p>接下来异常处理程序会根据 PTE 中的地址字段从磁盘中找到 VP3，将其复制到内存中的 PP3 位置，然后建立起虚拟页与物理页的映射关系并返回。此时 CPU 会重新执行导致缺页的那条指令，将虚拟地址重新发送到 MMU，此时就能够正常命中了，如图：</p>
<img src="https://img.gejiba.com/images/f4197667bc9721f172fe9fa89508984a.webp" alt="AfterPageFault" style="zoom:35%;" />
<h2 id="分配页面"><a class="markdownIt-Anchor" href="#分配页面"></a> 分配页面</h2>
<p>对于未分配的虚拟页，看一下其分配过程。</p>
<p>例如 VP5 尚未分配，当调用诸如 malloc 之类的分配函数时，会先在磁盘上分配空间，然后更新页表项 PTE5，使其指向磁盘中新创建的页，这时该虚拟页就从未分配变成了未缓存状态：</p>
<img src="https://img.gejiba.com/images/22b521b7beef951628c4e3dea87d7ce5.webp" alt="allocate" style="zoom:35%;" />
<h2 id="内存保护"><a class="markdownIt-Anchor" href="#内存保护"></a> 内存保护</h2>
<p>我们前面提到了页表中每个 PTE 由 1 个有效位和 1 个 n 位地址字段组成，事实上远不止这些。为了控制对内存系统的访问，这里再介绍 3 个额外的许可位：</p>
<ul>
<li><code>SUP</code>：表示内核（超级用户）模式。运行在内核模式的进程可以访问任何页面，而运行在用户模式的进程只能访问 <code>SUP</code> 为 0 的页面。</li>
<li><code>READ</code>：控制对页面的读访问权限。</li>
<li><code>WRITE</code>：控制对页面的写访问权限。</li>
</ul>
<p>通过这些许可位就可以控制一个用户进程不能修改其只读代码段，不能读写内核中的代码和数据段，不能读写其他进程的私有内存，不能修改与其他进程共享的虚拟页面（除非其他共享者都显式地允许它这么做），从而起到了 <strong>内存保护</strong> 的作用。</p>
<p>如果指令违反了这些许可条件，例如修改一个只读代码段，CPU 就会触发保护机制，在 Linux 中会报段错误（segmentation fault）。</p>
<h2 id="地址翻译"><a class="markdownIt-Anchor" href="#地址翻译"></a> 地址翻译</h2>
<p>了解了虚拟页、物理页和页表之后，再来看一下 <strong>地址翻译</strong>，即 MMU 是如何通过页表将虚拟地址映射到物理地址的：</p>
<img src="https://img.gejiba.com/images/7c8774365c01d601e434fe57a33bc6a6.webp" alt="地址翻译" style="zoom:30%;" />
<p>其中 <strong>页表基址寄存器</strong> 指向当前页表。MMU 根据虚拟页号找到相应的 PTE，再根据物理页号与虚拟地址中的偏移量就可以得到相应的物理地址。</p>
<p>MMU 根据虚拟页号查找 PTE 时，有页命中和页不命中两种情况。当该 PTE 的有效位为 1 时页命中，为 0 时页不命中。</p>
<p>当页命中时：</p>
<img src="https://img.gejiba.com/images/f1b0706b7c81b38995c443f6ba08c05d.webp" alt="PTHit" style="zoom:25%;" />
<p>当页不命中时：</p>
<img src="https://img.gejiba.com/images/d44d25a093d0442c932ab25deea267aa.webp" alt="PTMiss" style="zoom:25%;" />
<p>为了方便理解，上图将高速缓存和内存放到一起进行表示，二者之间的实际交互关系如下：</p>
<img src="https://img.gejiba.com/images/073cdfdb3c2973603fd4546938322501.webp" alt="cache&dram" style="zoom:30%;" />
<p>可以发现，CPU 每产生一个虚拟地址，MMU 就必须进行一次访存操作，即查阅 PTE 将虚拟地址转换为物理地址。在最坏情况下，内存中也没有该页表项，这时就需要从磁盘换入该 PTE，然后 MMU 再额外进行一次访存操作。而在最好情况下，该 PTE 恰好缓存在 L1 Cache，那么访存开销就只有 1~2 个周期，而即便是这样的开销，很多系统也仍会试图消除它，具体做法就是在 MMU 中增加一个 PTE 的缓存，即 TLB。</p>
<h2 id="tlb"><a class="markdownIt-Anchor" href="#tlb"></a> TLB</h2>
<p>TLB（Translation Lookaside Buffer），俗称快表，是一个小的、虚拟寻址的缓存。为了通过虚拟地址寻找 TLB 中的项（TLB 是组相联或全相联的），将虚拟地址的虚拟页号（VPN）进一步划分为 TLB 的标记位（TLBT）和组索引位（TLBI），如图所示：</p>
<img src="https://img.gejiba.com/images/b7c9f89274715cefa3afc2b1ea971fe9.webp" alt="VA" style="zoom:30%;" />
<p>TLB 通常有高度的相联度，每一行都缓存了 PTE 的内容。并且由于是在 MMU 中，因此地址翻译非常快。</p>
<p>当 TLB 命中时：</p>
<img src="https://img.gejiba.com/images/4bf7ca2feda8831061d108d2cc7855db.webp" alt="TLBHit" style="zoom:30%;" />
<p>当 TLB 不命中时：</p>
<img src="https://img.gejiba.com/images/93e15328ed4c3497365420ceed176acd.webp" alt="TLBMiss" style="zoom:30%;" />
<h2 id="多级页表"><a class="markdownIt-Anchor" href="#多级页表"></a> 多级页表</h2>
<p>到现在为止，我们一直假设系统只用一个单独的页表来进行地址翻译，但这显然是不现实的。我们可以计算一下：对于一个 32 位地址空间的系统，页大小为 4KB，一个页表项是 4 个字节，那么这个页表有多大？</p>
<blockquote>
<ul>
<li>
<p>32 位地址空间 <span class="p red"><b>→</b></span> 地址总数是2<sup>32</sup> ，而每个地址对应的内存空间为 1 B，所以最大内存空间为 2<sup>32</sup> B</p>
</li>
<li>
<p>4 KB 的页 <span class="p red"><b>→</b></span> 即页大小为 2<sup>12</sup> B <span class="p red"><b>→</b></span> 总页数为 2<sup>32</sup> B / 2<sup>12</sup> B = 2<sup>20</sup></p>
</li>
<li>
<p>4 B 的页表项 <span class="p red"><b>→</b></span> 即页表项大小为 2<sup>2</sup> B，而一个页表项对应一个页，所以有 2<sup>20</sup> 个页就需要有相同数量的页表项 <span class="p red"><b>→</b></span> 页表大小 = 页表项数 x 页表项大小 = 2<sup>20</sup> x 2<sup>2</sup> B = 4 x 2<sup>20</sup> B = 4 MB</p>
</li>
</ul>
<p class='div-border blue left right'> 2<sup>30</sup> B	=	1 GB</br>2<sup>20</sup> B	=	1 MB</br>2<sup>10</sup> B	=	1 KB</p>
</blockquote>
<p>由此可知，在内存中必须驻留一个 4MB 大小的页表，即使该程序只用到了虚拟地址空间中很小的一部分。对于 64 位的系统来说，页表会更大。</p>
<p>为了压缩页表，常用的方法就是使用 <strong>多级页表</strong>。还是上面的例子，一个 4MB 的页表映射了 4GB 的空间，如果我们使用两级页表，那么效果会是什么样呢？</p>
<p>将这个独立的页表拆分成 1024 个等大小的页表，那么每个页表的大小为 4MB / 1024 = 4 KB，每个 4KB 的页表能够映射 4KB / 4B * 4KB = 4MB 的虚拟地址空间，这段空间我们称其为 <strong>片</strong>（chunk）。</p>
<p>为了管理这 1024 个页表，还需要一个页表，这里将其称为 <strong><span class="p red">一级页表（也叫页目录）</span></strong>，相应地这 1024 个页表就叫二级页表。一级页表中一个页表项对应一个二级页表，因此一级页表就有 1024 个页表项，于是一级页表的大小为 1024 * 4B = 4KB。</p>
<p>可以发现，一级页表和每个二级页表大小都是 4KB，刚好是一个页的大小。</p>
<img src="https://img.gejiba.com/images/aa4db5f33751e65016341f82cc31be0a.webp" alt="2levelPT" style="zoom:40%;" />
<p>如果某个片中每个虚拟页均未分配，那么相应的一级页表项就为空（片2~7），自然也不需要二级页表了。多级页表从两个方面缓解了对内存的需求：</p>
<ul>
<li>如果一级页表为空，那么相应的二级页表根本就不会存在。这代表着一种巨大的潜在节约，因为对于一个典型的程序来说，4GB 的虚拟地址空间中大部分虚拟页都是未分配的。</li>
<li>只有一级页表和经常使用的二级页表才需要缓存在主存中，其他二级页表只在必要时换入换出，这就大大减少了主存的压力。</li>
</ul>
<p>当使用了 k 级页表之后，进行地址翻译时虚拟地址中的虚拟页号会被划分成 k 个：</p>
<img src="https://img.gejiba.com/images/a2b7aa48456b24f6f8be5fd722fbfc07.webp" alt="klevelPT" style="zoom:28%;" />
<p>在前 k - 1 级页表中，每个 PTE 都指向下一级页表的基地址，第 k 级页表中的 PTE 则包含了某个物理页的页号，或者某个磁盘块的地址。为了构造出物理地址，MMU 必须访问 k 个页表。</p>
<div class="note quote flat"><p>事实上，多级页表的地址翻译并不会比单页表慢很多。</p>
</div>
<p>以 Core i7 为例，看一下完整的地址翻译过程。</p>
<p>Core i7 采用四级页表的层次结构，CR3 寄存器保存了一级页表的基地址。CR3 的值是每个进程上下文的一部分，每次进程上下文切换时，CR3 的值都会被保存和恢复。</p>
<p>Core i7 的内存系统如下：</p>
<img src="https://img.gejiba.com/images/b7450e2a058a179082ebcac570771477.webp" alt="corei7mem" style="zoom:40%;" />
<p>地址翻译过程如下：</p>
<img src="https://img.gejiba.com/images/1be6c26ad41cec6488e280cbddcc30d3.webp" alt="corei7addtranslation" style="zoom:40%;" />
<h2 id="linux-虚拟内存系统"><a class="markdownIt-Anchor" href="#linux-虚拟内存系统"></a> Linux 虚拟内存系统</h2>
<p>Linux 进程的虚拟内存空间如下图，我们已经很熟悉了。</p>
<img src="https://img.gejiba.com/images/b3d458042407463af9d69dfab0d3a6d1.webp" alt="Linux进程的虚拟内存空间" style="zoom:60%;" />
<p>Linux 将虚拟内存组织为区域（area，也叫段）的集合，每个区域实际上都是一个数据结构。内核为系统中的每个进程都维护了一个任务结构 <code>task_struct</code>，其中包含了运行该进程所需的所有信息，例如 PID、PC、栈指针、可执行文件的名字等等。</p>
<p><img src="https://img.gejiba.com/images/0c09cdfb806b3ec4eec728948ddeeee9.webp" alt="vmas" /></p>
<p><code>task_struct</code> 的其中一个成员 <code>mm</code> 指向 <code>mm_struct</code>，它描述了虚拟内存的当前状态。其中 <code>pgd</code>（page global directory，页目录）指向页目录的基地址，当内核运行该进程时会将其存放在 CR3 控制寄存器中；<code>mmap</code> 则指向 <code>vm_area_struct</code> 链表。</p>
<p>每个 <code>vm_area_struct</code> 都描述了当前虚拟地址空间的一个区域，其中各字段的含义已在图中标出。</p>
<p>当 MMU 翻译某个虚拟地址时发生了缺页，缺页处理程序将会执行以下步骤：</p>
<ol>
<li>判断该虚拟地址是否合法，即是否在某个区域的地址范围内。此时需要比较该虚拟地址与每个区域结构的 <code>vm_start</code> 和 <code>vm_end</code>，如果不合法，则会触发 <strong>段错误</strong>，如图中 ① 所示，从而终止进程。</li>
<li>判断该内存访问是否合法，即进程是否有读、写或执行该区域的权限。如果不合法，比如要对只读代码段进行写操作，则会触发 <strong>保护异常</strong>，如图中 ② 所示，从而终止进程。</li>
<li>此时便可以确定该缺页是由于合法的虚拟地址进行合法的内存访问所造成的。处理缺页的过程为：选择一个牺牲页（如果没有空白页的话），如果被修改过则需要写回磁盘，然后换入新的物理页并更新页表。当缺页处理程序返回时，CPU 重新执行引起缺页的指令，此时就可以正常翻译了。</li>
</ol>
<h2 id="内存映射"><a class="markdownIt-Anchor" href="#内存映射"></a> 内存映射</h2>
<p>前面在介绍 <a href="#%E8%99%9A%E6%8B%9F%E9%A1%B5">虚拟页</a> 的时候，我们提到了当可执行文件被装载时，会建立虚拟地址空间与可执行文件的映射关系，这实际上就是内存映射。</p>
<p>Linux 通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化该虚拟内存区域中的内容，这个过程称为 <strong>内存映射</strong>。可以映射的磁盘文件有两种类型：</p>
<ol>
<li>普通文件。文件中保存了初始化的内容，例如可执行目标文件。页面按需调度，直到发生缺页时才会换入物理内存。如果换入之后没有填满该区域，则用零来填充剩余部分。</li>
<li><strong>匿名文件</strong>。文件中保存的都是二进制零，由内核创建。当虚拟内存空间映射到该区域时，并不需要在磁盘和内存之间进行数据传送，只需用零覆盖即可。因此，映射到匿名文件的页有时也叫 <strong>请求二进制零的页</strong>。</li>
</ol>
<p>无论哪种情况，一旦一个虚拟页与磁盘中的文件完成了内存映射，它就会在由内核维护的交换空间与物理内存之间换入换出。</p>
<p class='div-border blue left'><b>交换空间</b> 是磁盘上的一块区域，当物理内存吃紧时，会将内存中不常访问的数据换出到该区域，这样系统就有了更多的物理内存为各进程服务。当需要访问交换空间中存储的内容时，再将其换入到物理内存中。因此，<span class="p red"><b>交换空间限制了当前进程所能分配的虚拟页的总数。</b></span></p>]]></content>
      <categories>
        <category>读书笔记 - CSAPP</category>
      </categories>
      <tags>
        <tag>虚拟内存</tag>
        <tag>地址翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>高速缓存是如何查找数据的</title>
    <url>/posts/2065420180.html</url>
    <content><![CDATA[<h2 id="cache-的组织结构"><a class="markdownIt-Anchor" href="#cache-的组织结构"></a> Cache 的组织结构</h2>
<p>高速缓存可以看成由缓存行（cache line）组成的数组，每个缓存行分为三个部分，其中：</p>
<ul>
<li>
<p><strong>有效位</strong> 指明了当前行所存储的数据是否有效，大小为 1 个 bit；</p>
</li>
<li>
<p><strong>标记位</strong> 唯一地标识了存储在缓存行中的信息；</p>
</li>
<li>
<p><strong>数据块</strong>（Block） 则是部分内存数据的副本。</p>
</li>
</ul>
<p>高速缓存的组织结构可以用元组 <code>(S, E, B, m)</code> 表示，<code>m</code> 是主存物理地址的位数。</p>
<img src="https://img.gejiba.com/images/86f467a47a83e338e941edf133d73fc5.webp" alt="cachestruct" style="zoom:45%;" />
<p>高速缓存的大小（Capacity）指的是所有数据块的大小之和，并不包含有效位和标记位，因此可以通过 <code>C = B x E x S</code> 计算得到。</p>
<p>相应地，对高速缓存访问的 <code>m</code> 位的地址被划分成了如下结构：</p>
<img src="https://img.gejiba.com/images/85db219b099cce3ea5c5a13f86de723f.webp" alt="cacheaddr" style="zoom:70%;" />
<p>当某个地址向高速缓存发出访问后，首先根据组索引位 <code>s</code> 确定索要访问的数据在哪个组，然后根据标记位 <code>t</code> 确定组中的哪一行与之匹配，当且仅当有效位为 1 并且标记位也匹配时才算访存命中。此时，根据块偏移位 <code>b</code> 就可以从 B 个字节的数据块中抽取出所访问的数据。</p>
<h2 id="cache-的地址映射方式"><a class="markdownIt-Anchor" href="#cache-的地址映射方式"></a> Cache 的地址映射方式</h2>
<p>根据每个组高速缓存行的行数 <code>E</code>，高速缓存可以分为三种类型：</p>
<h3 id="直接映射高速缓存"><a class="markdownIt-Anchor" href="#直接映射高速缓存"></a> 直接映射高速缓存</h3>
<p><code>E == 1</code>：</p>
<img src="https://img.gejiba.com/images/9828e5344d0fdc7b3d6b1754c5bfac0f.webp" alt="directmap" style="zoom:30%;" />
<p>由于每个组只有 1 个缓存行，因此访存时确定了所属组之后就只需访问一行，通过比较标记位和判断有效位来确定是否命中。若不命中，则从内存中取出相应数据直接替换掉当前行。</p>
<h3 id="组相联高速缓存"><a class="markdownIt-Anchor" href="#组相联高速缓存"></a> 组相联高速缓存</h3>
<p><code>1 &lt; E &lt; C/B</code>：</p>
<img src="https://img.gejiba.com/images/8ac0edf84c919e9c95998d17fe2aab75.webp" alt="二路组相联cache" style="zoom:43%;" />
<p>每个组包含不止一个缓存行，通常也叫 <strong>E路组相联</strong> 高速缓存。</p>
<p>访存时确定了所属组之后，必须检查多个缓存行的标记位和有效位，因为组中的每一行都可以包含任何映射到这个组中的内存块，就相当于将所有哈希值相同的数据都放在同一个组中。</p>
<p>当访存不命中时，需要从内存中取出包含这个数据的块。此时，若该组中有空行，自然将取回的数据放入空行；如果没有，则需要选择其中一行进行替换。常见的缓存替换策略有 LFU（Least Frequently Used，最不经常使用）、LRU（Least Recently Used，最近最少使用）、随机替换等等。</p>
<h3 id="全相联高速缓存"><a class="markdownIt-Anchor" href="#全相联高速缓存"></a> 全相联高速缓存</h3>
<p><code>E == C/B</code>：</p>
<img src="https://img.gejiba.com/images/945c8168db1fd891a288777fd799a8b2.webp" alt="fullyassociativecache" style="zoom:45%;" />
<p>高速缓存只有一个组，包含了所有行。因此地址中不再需要组索引位，只包含标记位和块偏移。</p>
<p>此时的访存操作必须并行地比对很多标记位，构造一个又大又快的全相联高速缓存困难且昂贵，因此这种方式只适合做小的高速缓存，例如 TLB。</p>
]]></content>
      <categories>
        <category>读书笔记 - CSAPP</category>
      </categories>
      <tags>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title>多核CPU如何保证缓存一致性</title>
    <url>/posts/921523538.html</url>
    <content><![CDATA[<p>当 CPU 中的某个核要对内存中的数据进行修改时，会先将其缓存到 cache 中，然后再去修改。此时由于修改后的数据尚未写回到内存，如果其他核要去访问这个数据，就会读到修改之前的数据，这就是 <strong>缓存一致性问题</strong>。对此有两种解决方式：</p>
<h2 id="对总线加锁"><a class="markdownIt-Anchor" href="#对总线加锁"></a> 对总线加锁</h2>
<p>CPU 和其他组件都是通过 <strong>总线</strong>（数据总线、控制总线、地址总线）进行通信的，因此通过对总线加锁就可以保证只有一个核获取到锁，而其他核都处于阻塞状态。这样虽然保证了数据的一致性，但也严重影响了 CPU 的执行效率。</p>
<h2 id="使用缓存一致性协议-mesi"><a class="markdownIt-Anchor" href="#使用缓存一致性协议-mesi"></a> 使用缓存一致性协议 MESI</h2>
<p>该协议只对单个缓存行加锁，因此不会影响到内存中其他数据的读写，这样就可以保证执行效率。</p>
<p><strong>MESI</strong> 每个字母对应一种状态：</p>
<table>
<thead>
<tr>
<th style="text-align:center">状态</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">M（Modified）</td>
<td style="text-align:center">修改</td>
<td style="text-align:center">缓存行中的数据已被修改，与内存中的数据不一致，并且该数据只存在于本地 cache 中（即只存在于当前核的 cache 中）</td>
</tr>
<tr>
<td style="text-align:center">E（Exclusive）</td>
<td style="text-align:center">独享、互斥</td>
<td style="text-align:center">缓存行中的数据与内存中的数据一致，并且该数据只存在于本地 cache 中</td>
</tr>
<tr>
<td style="text-align:center">S（Shared）</td>
<td style="text-align:center">共享</td>
<td style="text-align:center">缓存行中的数据与内存中的数据一致，并且该数据存在于多个 cache 中（即存在于多个核的 cache 中）</td>
</tr>
<tr>
<td style="text-align:center">I（Invalid）</td>
<td style="text-align:center">无效</td>
<td style="text-align:center">当前缓存行无效</td>
</tr>
</tbody>
</table>
<p>MESI 的状态转移过程：</p>
<p class='div-border blue left'>local read/write：当前核读写本地 cache 中的缓存行数据。</br>remote read/write：其它核读写内存中的数据，该数据已被缓存到某个核的 cache 中。</p>
<table style="width:100%">
    <tr>
        <th align="center" bgcolor="#f5f6f8">当前<br/>状态</th> 
        <th align="center" bgcolor="#f5f6f8">事件</th> 
        <th align="center" bgcolor="#f5f6f8">行为</th> 
        <th align="center" width="8%" bgcolor="#f5f6f8">下个<br/>状态</th> 
   </tr>
    <tr>
        <td rowspan="5" align="center" style="font-size:50px; font-weight:bold">M</td>
    </tr>
    <tr>
        <td align="center">local read</td>
        <td align="left">从 cache 中读，状态不变</td>
        <td align="center">M</td>
    </tr>
    <tr>
        <td align="center">local write</td>
        <td align="left">修改 cache 数据，状态不变</td>
        <td align="center">M</td>
    </tr>
    <tr>
        <td align="center">remote read</td>
        <td align="left">将数据写回内存，使其它核能够获取到最新数据，状态变为 S</td>
        <td align="center">S</td>    
    </tr>
    <tr>
        <td align="center">remote write</td>
        <td align="left">将数据写回内存，使其它核能够获取到最新数据，状态变为 I</td>
        <td align="center">I</td>    
    </tr>
    <tr>
        <td rowspan="5" align="center" style="font-size:50px; font-weight:bold">E</td>    
    </tr>
    <tr>
        <td align="center">local read</td>
        <td align="left">从 cache 中读，状态不变</td>
        <td align="center">E</td>
    </tr>
    <tr>
        <td align="center">local write</td>
        <td align="left">修改 cache 数据，状态变为 M</td>
        <td align="center">M</td>
    </tr>
    <tr>
        <td align="center">remote read</td>
        <td align="left">数据与其它核共享，状态变为 S</td>
        <td align="center">S</td>    
    </tr>
    <tr>
        <td align="center">remote write</td>
        <td align="left">数据被修改，状态变为 I</td>
        <td align="center">I</td>    
    </tr>
    <tr>
        <td rowspan="5" align="center" style="font-size:50px; font-weight:bold">S</td>    
    </tr>
    <tr>
        <td align="center">local read</td>
        <td align="left">从 cache 中读，状态不变</td>
        <td align="center">S</td>
    </tr>
    <tr>
        <td align="center">local write</td>
        <td align="left">先将其它核的状态变为 I，再将本地状态变为 M</td>
        <td align="center">M</td>
    </tr>
    <tr>
        <td align="center">remote read</td>
        <td align="left">数据与其它核共享，状态不变</td>
        <td align="center">S</td>    
    </tr>
    <tr>
        <td align="center">remote write</td>
        <td align="left">数据被修改，状态变为 I</td>
        <td align="center">I</td>    
    </tr>
    <tr>
        <td rowspan="9" align="center" style="font-size:50px; font-weight:bold">I</td>    
    </tr>
    <tr>
        <td rowspan="3" align="center">local read</td>
        <td align="left">若其它核中没数据，则将内存中的数据缓存到本地 cache，状态变为 E</td>
        <td rowspan="3" align="center">E/S</td>
    </tr>
    <tr>
        <td align="left">若其它核中有数据，且状态为 M，则先将数据写回内存，然后将内存中的数据缓存到本地 cache，二者状态均变为 S</td>
    </tr>
    <tr>
        <td align="left">若其它核中有数据，且状态为 E 或 S，则将内存中的数据缓存到本地 cache，并将它们的状态均变为 S</td>
    </tr>
    <tr>
        <td rowspan="3" align="center">local write</td>
        <td align="left">若其它核中没数据，则将内存中的数据缓存到本地 cache，状态变为 M</td>
        <td rowspan="3" align="center">M</td>
    </tr>
    <tr>
        <td align="left">若其它核中有数据，且状态为 M，则先将数据写回内存，状态变为 I，然后将内存中的数据缓存到本地 cache，状态变为 M</td>
    </tr>
    <tr>
        <td align="left">若其它核中有数据，且状态为 E 或 S，则将它们的状态变为 I，然后将内存中的数据缓存到本地 cache，状态变为 M</td>
    </tr>
    <tr>
        <td align="center">remote read</td>
        <td align="left">本地数据已失效，不受其它核操作的影响</td>
        <td align="center">I</td>    
    </tr>
    <tr>
        <td align="center">remote write</td>
        <td align="left">本地数据已失效，不受其它核操作的影响</td>
        <td align="center">I</td>    
    </tr>
</table>]]></content>
      <categories>
        <category>读书笔记 - CSAPP</category>
      </categories>
      <tags>
        <tag>MESI</tag>
      </tags>
  </entry>
  <entry>
    <title>如何摆脱CPU分支预测错误</title>
    <url>/posts/2875321003.html</url>
    <content><![CDATA[<p>现在我们已经知道，CPU 引入流水线的目的就是为了保证每个时钟周期都能发射一条新的指令，从而提升其性能。要做到这一点，就必须在取出当前指令后立马确定下一条指令的位置。</p>
<p>根据 <a href="https://younghblog.gitee.io/posts/3931262747.html" target="_blank">上一篇</a> 博文可知，大多数指令都可以在取指阶段确定下一条指令的地址，比如对于 call 和 jmp（无条件跳转）指令来说，下一条指令的地址就是指令中的常数字 <code>valC</code>，而对于其他指令来说则是 <code>valP</code>。</p>
<p>但不幸的是，如果取出的指令是条件转移指令 cmovXX，则必须等到执行阶段完成才能确定下一条指令的地址。类似地，如果取出的指令是返回指令 ret，则要等到访存结束后才能确定下一条指令的地址。</p>
<p>CPU 对于 ret 的处理比较简单，即 <span class="p red">流水线必须暂停直到 ret 指令访存结束。</span>而对于 cmovXX，则会进行分支预测以提高 CPU 的执行效率。</p>
<h2 id="cpu-分支预测"><a class="markdownIt-Anchor" href="#cpu-分支预测"></a> CPU 分支预测</h2>
<p>具体来说，CPU 既可以预测选择了分支，也可以预测没有选择分支，然后按照所预测的方向继续往下执行。当然，预测终归只是预测，必然会有错误的情况发生。如果错误的分支预测经常发生，那么性能损失就会显著增加。因为当这样的事件发生时，CPU 已经取出并执行了部分错误的指令，因此需要清除掉所有这些错误的指令，同时还需要用来自正确分支的指令填充流水线。 <span class="p red">通常，现代 CPU 会因分支预测错误而遭受 10-20 个周期的惩罚。</span></p>
<p>如今，处理器非常擅长预测分支结果，不仅可以遵循静态预测规则，还可以检测动态模式。通常，分支预测器会采用后者。</p>
<p class='div-border blue left'> <b>静态分支预测</b>：由编译器来决定哪个分支可能被 CPU 命中。一般会选择第一个分支，即 if 后面的逻辑，而不是 else 后面的逻辑。</br><b>动态分支预测</b>：在运行期间决定预测结果。它会在 CPU 硬件中开辟一块缓存，专门记录每个分支最近几次的命中情况，然后做出预测。</p>
<p>通用来说，应用程序的错误预测率在 5%-10% 的范围是正常的，如果该指标高于 10% 就要引起注意了。</p>
<h2 id="摆脱分支预测错误的方式"><a class="markdownIt-Anchor" href="#摆脱分支预测错误的方式"></a> 摆脱分支预测错误的方式</h2>
<p><span class="p red">为了摆脱分支预测错误，最直接的方法就是摆脱分支本身。</span>接下来就介绍两种摆脱分支的方式。</p>
<h3 id="1-用查找表替换分支"><a class="markdownIt-Anchor" href="#1-用查找表替换分支"></a> 1. 用查找表替换分支</h3>
<p>通过查找表可以避免频繁的分支。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mapToBucket</span><span class="params">(<span class="type">unsigned</span> v)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; <span class="number">10</span>)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(v &gt;= <span class="number">10</span> &amp;&amp; v &lt; <span class="number">20</span>)  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v &gt;= <span class="number">20</span> &amp;&amp; v &lt; <span class="number">30</span>)  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(v &gt;= <span class="number">30</span> &amp;&amp; v &lt; <span class="number">40</span>)  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(v &gt;= <span class="number">40</span> &amp;&amp; v &lt; <span class="number">50</span>)  <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中存在许多分支，这些分支可能具有很高的错误预测率。</p>
<p>我们可以使用数组查找来重写该函数，这样函数的汇编代码应该只有一个分支而不是多个分支。此外，buckets 数组相对较小，因此我们可以期望它驻留在 CPU 缓存中，从而能够对其进行快速访问：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找表版本</span></span><br><span class="line"><span class="type">int</span> buckets[<span class="number">256</span>] = &#123;</span><br><span class="line">     <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,</span><br><span class="line">     <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>,</span><br><span class="line">     <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>,</span><br><span class="line">     <span class="number">3</span>,  <span class="number">3</span>,  <span class="number">3</span>,  <span class="number">3</span>,  <span class="number">3</span>,  <span class="number">3</span>,  <span class="number">3</span>,  <span class="number">3</span>,  <span class="number">3</span>,  <span class="number">3</span>,</span><br><span class="line">     <span class="number">4</span>,  <span class="number">4</span>,  <span class="number">4</span>,  <span class="number">4</span>,  <span class="number">4</span>,  <span class="number">4</span>,  <span class="number">4</span>,  <span class="number">4</span>,  <span class="number">4</span>,  <span class="number">4</span>,</span><br><span class="line">    <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>,</span><br><span class="line">    <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>,</span><br><span class="line">    ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mapToBucket</span><span class="params">(<span class="type">unsigned</span> v)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(v &lt; (<span class="keyword">sizeof</span>(buckets) / <span class="keyword">sizeof</span>(<span class="type">int</span>)))</span><br><span class="line">    	<span class="keyword">return</span> buckets[v];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们需要映射更大范围的值，分配一个非常大的数组是不切实际的。在这种情况下，可以使用 interval map 数据结构，以使用更少的内存和对数级的查找复杂度来实现该目标。</p>
<h3 id="2-用谓词替换分支"><a class="markdownIt-Anchor" href="#2-用谓词替换分支"></a> 2. 用谓词替换分支</h3>
<p>通过执行分支的两个部分，然后选择正确的结果，可以有效地消除一些分支。 如果 if 分支有非常多的错误预测，可以尝试通过这种方式来消除分支。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原始版本</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">if</span>(cond) &#123; <span class="comment">// 假设分支有较高的错误预测率</span></span><br><span class="line">    a = computeX();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    a = computeY();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 原始汇编版本</span></span><br><span class="line"><span class="attr">400504:</span> 	<span class="string">test</span>	<span class="string">%edi,</span> <span class="string">%edi</span>	<span class="comment"># 要在执行阶段完成后才能知道结果</span></span><br><span class="line"><span class="attr">400506:</span> 	<span class="string">je</span>	<span class="string">$400514</span></span><br><span class="line"><span class="attr">400508:</span> 	<span class="string">mov</span>	<span class="string">$0,</span> <span class="string">%eax</span></span><br><span class="line"><span class="attr">40050d:</span> 	<span class="string">call</span>	<span class="string">&lt;computeX&gt;</span></span><br><span class="line"><span class="attr">400512:</span> 	<span class="string">jmp</span>	<span class="string">$40051e</span></span><br><span class="line"><span class="attr">400514:</span> 	<span class="string">mov</span> 	<span class="string">$0,</span> <span class="string">%eax</span></span><br><span class="line"><span class="attr">400519:</span> 	<span class="string">call</span> 	<span class="string">&lt;computeY&gt;</span></span><br><span class="line"><span class="attr">40051e:</span> 	<span class="string">mov</span> 	<span class="string">%eax,</span> <span class="string">%edi</span></span><br></pre></td></tr></table></figure>
<p>用谓词替换分支后：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无分支版本</span></span><br><span class="line"><span class="type">int</span> x = computeX();</span><br><span class="line"><span class="type">int</span> y = computeY();</span><br><span class="line"><span class="type">int</span> a = cond ? x : y;</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 无分支汇编版本</span></span><br><span class="line"><span class="attr">400537:</span> 	<span class="string">mov</span> 	<span class="string">$0,</span> <span class="string">%eax</span></span><br><span class="line"><span class="attr">40053c:</span> 	<span class="string">call</span> 	<span class="string">&lt;computeX&gt;</span></span><br><span class="line"><span class="attr">400541:</span> 	<span class="string">mov</span> 	<span class="string">%eax,</span> <span class="string">%ebp</span></span><br><span class="line"><span class="attr">400543:</span> 	<span class="string">mov</span> 	<span class="string">$0,</span> <span class="string">%eax</span></span><br><span class="line"><span class="attr">400548:</span> 	<span class="string">call</span> 	<span class="string">&lt;computeY&gt;</span></span><br><span class="line"><span class="attr">40054d:</span> 	<span class="string">test</span> 	<span class="string">%ebx,</span> <span class="string">%ebx</span></span><br><span class="line"><span class="attr">40054f:</span> 	<span class="string">cmovne</span>	<span class="string">%ebp,</span> <span class="string">%eax</span>	<span class="comment"># 要在执行阶段完成后才能知道结果</span></span><br></pre></td></tr></table></figure>
<p>在无分支版本中，编译器能够去除分支并生成 cmovne 指令来替代。</p>
<blockquote>
<p>这里大家可能会有疑问：无分支汇编版本中的 <code>cmovne</code>（第 8 行）跟原始汇编版本中的 <code>test</code>（第 2 行）一样，都是要等到执行阶段完成后才能确定下一条指令的地址，那为什么无分支版本的效率会更高呢？</p>
<p>在当前示例中，<code>test</code> 后面还有很多依赖其结果的指令，它们都会阻塞起来等待其执行完成；而 <code>cmovne</code> 并没有阻塞后续指令，因此它的执行效率会更高。</p>
</blockquote>
<h2 id="消除分支的负面影响"><a class="markdownIt-Anchor" href="#消除分支的负面影响"></a> 消除分支的负面影响</h2>
<p>在上述无分支版本的示例中，x 和 y 都是独立计算的，然后只选择其中一个值。<span class="p red">虽然这种转换消除了分支错误预测的惩罚，但它会比原始代码做更多的工作。</span></p>
<p>在这种情况下，性能改进在很大程度上取决于 computeX() 和 computeY() 函数的特性。如果函数很小并且编译器能够内联它们，它可能会带来显著的性能优势；但 <span class="p red">如果函数很大，两个函数都去执行的开销就会比分支预测错误的开销更大。</span></p>
<p>此外，<span class="p red">消除分支还会限制 CPU 的并行执行能力。</span></p>
<p>对于原始版本中的代码片段，CPU 可以根据分支预测器选择 if 分支，并使用 <code>a = computeX()</code> 来推测执行。如果后续有指令要用 <code>a</code> 来索引数组元素，那么在知道 if 分支的真实结果之前就可以发出此加载（即直接使用分支预测所计算出的 <code>a</code> 的值。因为分支预测只需选择一个分支然后向下执行即可，而不需要计算出所有情况）。</p>
<p>而对于无分支版本中的代码，这种推测是不可能的，因为 CPU 无法在 <code>cmovne</code> 指令完成之前发出使用 <code>a</code> 的加载（无分支版本需要计算出所有情况，并且在最终执行完 <code>cmovne</code> 指令后才能确定 <code>a</code> 的值到底属于哪种情况）。</p>
<h2 id="何时选择无分支版本"><a class="markdownIt-Anchor" href="#何时选择无分支版本"></a> 何时选择无分支版本</h2>
<p>在代码的原始版本和无分支版本之间进行权衡的典型例子是 <strong>二分查找</strong>。</p>
<ul>
<li>
<p><span class="p red">对于不适合 CPU 缓存的大型数组的查找，基于分支的二分查找版本的性能更好。</span>因为与内存访问的延迟（cache 未命中会导致较高的延迟，无分支版本可能会有更多的 cache 不命中）相比，分支预测错误的代价较低。由于存在分支，CPU 可以推测它们的结果，从而同时加载当前迭代和下一次迭代中的数组元素。</p>
</li>
<li>
<p><span class="p red">对于适合 CPU 缓存的小型数组的查找，情况则正好相反。</span>由于数组适合 CPU 缓存，因此加载延迟很小（只有几个周期）。而基于分支的二分查找可能会遭受持续的错误预测（对于二分查找一旦预测错误，后续所有的预测一定都是错的），惩罚约为 20 个周期。在这种情况下，错误预测的代价远远大于内存访问的代价，从而大大削弱了推测执行的优势。在这种情况下，无分支版本通常会更快。</p>
</li>
</ul>
<p>二分查找是一个很好的例子，说明了如何在基础版本和无分支版本之间进行选择。但现实情况可能很难分析，因此，需要通过测试来确定在特定场景中替换分支是否有益。</p>
<h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2>
<ul>
<li>现代处理器非常擅长预测分支结果，因此 <strong>建议仅在错误预测率较高时再去修复分支错误预测的工作</strong>。</li>
<li>当 CPU 分支预测错误率较高时，应用程序的性能可能会受到影响。在这种情况下，算法的无分支版本可能会更好，因此可以考虑通过 <strong>查找表</strong> 和 <strong>谓词</strong> 来替换分支。</li>
<li><strong>无分支算法并非总是有益的</strong>，要通过测试来确定是否适合特定场景。</li>
</ul>
</br>
<div class="note info flat"><p><span class="p blue">以上内容主要参考自『Performance Analysis and Tuning on Modern CPUs』</span></p>
</div>]]></content>
      <categories>
        <category>读书笔记 - CSAPP</category>
      </categories>
      <tags>
        <tag>分支消除</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU流水线的各个阶段到底做了什么</title>
    <url>/posts/3931262747.html</url>
    <content><![CDATA[<p>我们在学习 CPU 处理机制的时候，为了便于理解，都会从 <strong>顺序执行</strong>（Sequential）的处理器开始介绍。对于顺序执行的 CPU，每个时钟周期都要处理一条完整的指令，这是一个漫长的过程，因此时钟频率会低到让人难以接受。为了提升 CPU 的性能，便引入了流水线技术。</p>
<p class='div-border blue left'>可即便使用了流水线，顺序执行的 CPU 的处理效率仍然无法满足我们的现实需要，因此现代处理器都是 <b>乱序执行</b>（Out-of-Order）的。</br>乱序执行即指令的执行并非按照程序中指令的原始顺序，而是后面的指令有可能会先于前面的指令执行。当然，为了保证程序的正确性，乱序执行必须保证与顺序执行相同的执行结果。</p>
<p>通常来说，处理一条指令包括很多操作，将它们组织成一个特殊的序列，就能设计出一个充分利用每个硬件的处理器。CPU 流水线最经典的划分方式包括：取指、译码、执行、访存、写回、更新 PC 寄存器。这些阶段的划分已是老生常谈，但每个阶段具体都做了什么，却跟我之前的理解有着严重的偏差。比如：</p>
<ul>
<li><span class="p red">取指阶段就只是单纯地从 PC 寄存器取出指令吗？</span></li>
<li><span class="p red">译码阶段是要对取出的机器指令进行翻译吗？</span></li>
<li><span class="p red">执行阶段好像是最简单的，就是执行程序逻辑中的主体运算，但真的就只有这一种情况吗？</span></li>
<li><span class="p red">访存就是访问 DRAM 内存吗？</span></li>
<li><span class="p red">写回是将修改后的值重新写回到内存吗？</span></li>
</ul>
<p>当然这些答案都是否定的，接下来我将通过各种类型的指令来详细介绍 CPU 流水线的各个阶段。</p>
<p>为了彻底搞清楚 CPU 对这些指令的处理过程，首先需要了解这些 <code>Y86-64</code> 指令的编码格式：</p>
<p><img src="https://img.gejiba.com/images/9cfcac8bb960fb57bda358842cf65826.webp" alt="Y86-64" /></p>
<p>可以看到指令编码长度从 1 字节到 10 字节不等。其中：</p>
<p>第 1 个字节表示操作码（icode : ifun），根据第 1 个字节就能知道指令的类型，进而知道有没有操作数，以及有几个操作数。图中 <code>fn</code> 用来表示该条指令是整数操作（OPq）、数据传送条件（cmovXX）或是分支条件（jXX）。</p>
<p>第 2 个字节表示操作数（rA : rB），对于那些只需要一个寄存器操作数的指令（irmovq、pushq 和 popq），将另一个寄存器指示符设置为十六进制数 <code>F</code>。</p>
<p>剩余 8 个字节表示立即数（irmovq 中的 <code>V</code>）、地址偏移量（rmmovq 与 mrmovq 中的 <code>D</code>）或是目标地址（jXX 与 call 中的 <code>Dest</code>）。</p>
<p>背景知识介绍差不多了，接下来我们就进入正题！</p>
<h2 id="opq-rrmovq-与-irmovq"><a class="markdownIt-Anchor" href="#opq-rrmovq-与-irmovq"></a> OPq、rrmovq 与 irmovq</h2>
<p><img src="https://img.gejiba.com/images/8f1a06dd51324402e831fdfa77d93088.webp" alt="OPq&amp;rrmovq&amp;irmovq" /></p>
<p>图中 <span class="p red">M<sub>n</sub>[X]</span> 表示访问内存位置 <code>X</code> 处的 <code>n</code> 个字节，下同。</p>
<p>可以看到，<strong>取指阶段</strong> 根据 PC 寄存器中所保存的地址从内存中取出指令，同时还解析出了指令的操作码和操作数，以及当前指令的长度，并且根据该长度计算出了下一条指令的地址 <code>valP</code>。</p>
<p><strong>译码阶段</strong> 从寄存器文件中读取最多两个操作数。而 irmovq 指令是将立即数读入到寄存器，不涉及对寄存器的读取，因此该指令在译码阶段不执行任何操作。</p>
<p><strong>执行阶段</strong> 由 ALU 执行指令指明的操作，当只有一个操作数时，将第二个操作数设为 0。这个过程可能需要设置条件码（<code>set CC</code>）。</p>
<p>由于这三类指令均未涉及到内存操作，因此在 <strong>访存阶段</strong> 不执行任何操作。</p>
<p><strong>写回阶段</strong> 将执行阶段得到的结果写回到目的寄存器，最后 <strong>更新 PC 寄存器</strong>。</p>
<h2 id="rmmovq-与-mrmovq"><a class="markdownIt-Anchor" href="#rmmovq-与-mrmovq"></a> rmmovq 与 mrmovq</h2>
<p><img src="https://img.gejiba.com/images/186a2f5d3d11a529447ab9046504c0dc.webp" alt="rmmovq&amp;mrmovq" /></p>
<p>这里的 <code>D</code> 表示地址偏移量，例如 <code>rmmovq %rsp,100(%rbx)</code>，表示将 %rsp 寄存器中的值放到内存中，内存地址是 %rbx 寄存器中的值加上 100。</p>
<p>这里的 <strong>执行阶段</strong> 计算的是内存地址。</p>
<p><strong>访存阶段</strong> 将值写入内存或者从内存中读出某个值。</p>
<p>由于 rmmovq 的不涉及到对目的寄存器的写，因此在 <strong>写回阶段</strong> 该指令不执行任何操作。</p>
<p>其余阶段中相同的操作这里不再赘述，下同。</p>
<h2 id="pushq-与-popq"><a class="markdownIt-Anchor" href="#pushq-与-popq"></a> pushq 与 popq</h2>
<p><img src="https://img.gejiba.com/images/0ed95a00e91e504ff8ee2a6b780504eb.webp" alt="pushq&amp;popq" /></p>
<p><strong>译码阶段</strong> 除了要读取指定寄存器中的操作数，还要读取栈顶指针的值。</p>
<p><strong>执行阶段</strong> 计算栈顶指针移动后的地址，该地址就是将要访问的内存地址。</p>
<p><strong>写回阶段</strong> 除了将结果写回目的寄存器外，还要更新栈顶指针的位置。</p>
<h2 id="jxx-call-与-ret"><a class="markdownIt-Anchor" href="#jxx-call-与-ret"></a> jXX、call 与 ret</h2>
<p><img src="https://img.gejiba.com/images/6f15acef0a82abde1779d52ca2104e86.webp" alt="jXX&amp;call&amp;ret" /></p>
<p>call 和 ret 指令类似于 pushq 和 popq。call 指令会将下一条指令的地址压入栈中（<strong>访存</strong>），然后将调用的目的地址 <code>valC</code> 作为下一条执行指令的地址（<strong>更新 PC</strong>）。ret 指令将从栈顶弹出的地址 <code>valM</code> 作为下一条执行指令的地址（<strong>更新 PC</strong>），并且由 call 可知，这条指令其实就是 call 指令后面紧跟的那条指令，表示在函数调用返回后继续往下执行。</p>
<p>jXX 指令在 <strong>执行阶段</strong> 会计算是否满足跳转条件。</p>
<p><strong>更新 PC 阶段</strong> 将根据分支条件设置下一条指令的地址。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>处理一条指令可以划分成以下几个阶段，这些阶段不一定都会执行，与具体的指令类型有关。</p>
<ul>
<li><strong>取指</strong>（Fetch）：从内存中读取指令，地址为 PC 寄存器的值。同时还会解析指令的操作码（指令类型）和操作数（寄存器指示符 rA/rB，可能还有常数），并计算出顺序执行时下一条指令的地址，该地址等于 PC 的值加上当前指令的长度。</li>
<li><strong>译码</strong>（Decode）：根据寄存器指示符从相应的寄存器文件中读入最多两个操作数，有时候需要读取 %rsp 寄存器所保存的地址。</li>
<li><strong>执行</strong>（Execute）：根据操作码类型，这个阶段可能执行的操作包括：执行指令指明的操作（可能还会设置条件码）；计算内存引用的有效地址；增加或减少栈指针；检验条件码和传送条件是否成立（条件传送指令 cmovXX）；决定是否选择分支（跳转指令）。</li>
<li><strong>访存</strong>（Memory）：从内存读取数据，或者将数据写入内存。</li>
<li><strong>写回</strong>（Write back）：最多可以将两个结果写到寄存器文件，包括写回指令中指定的目的寄存器，以及 %rsp 寄存器（更新栈顶指针的位置）。</li>
<li><strong>更新 PC</strong>（PC update）：将 PC 寄存器设置成下一条指令的地址。</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记 - CSAPP</category>
      </categories>
      <tags>
        <tag>CPU流水线</tag>
      </tags>
  </entry>
  <entry>
    <title>看懂简单的汇编代码</title>
    <url>/posts/3467593604.html</url>
    <content><![CDATA[<p>本文介绍的是 AT&amp;T 格式的汇编代码。先上表格：</p>
<img src="https://img.gejiba.com/images/2ec02466ed8dac1bfe60bab88be7fa76.webp" alt="整数寄存器" style="zoom:80%;" />
<p>表格记录了不同寄存器的功能。汇编指令通常都有一个或多个操作数，有的指令没有操作数，这些操作数有三种类型：立即数 <span class="p red">$<em>Imm</em></span>、寄存器 <span class="p red"><em>r<sub>a</sub></em></span> 和内存引用 <span class="p red">(<em>r<sub>a</sub></em>)</span>。</p>
<p>常见的操作指令有：</p>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">mov    S, D</td>
<td style="text-align:center">把数据从S传送到D</td>
</tr>
<tr>
<td style="text-align:center">push    S</td>
<td style="text-align:center">栈顶指针下移，S入栈</td>
</tr>
<tr>
<td style="text-align:center">pop    D</td>
<td style="text-align:center">栈顶内容赋值给D，栈顶指针上移</td>
</tr>
<tr>
<td style="text-align:center">lea    S, D</td>
<td style="text-align:center">将S的地址（&amp;S）赋值给D</td>
</tr>
<tr>
<td style="text-align:center">inc/dec/neg/not    D</td>
<td style="text-align:center">将D<code>加1/减1/取负/取反</code>后赋值给D</td>
</tr>
<tr>
<td style="text-align:center">add/sub/imul/xor/or/and    S, D</td>
<td style="text-align:center">将D<code>加/减/乘/异或/或/与</code>S后赋值给D</td>
</tr>
<tr>
<td style="text-align:center">sal/shl/sar/shr    k, D</td>
<td style="text-align:center">将D<code>算术/逻辑左移</code>/<code>算术/逻辑右移</code>k位后赋值给D</td>
</tr>
<tr>
<td style="text-align:center">leaq    S, D</td>
<td style="text-align:center">将S的地址赋值给D或者对S算术运算后赋值给D</td>
</tr>
<tr>
<td style="text-align:center">cmp/test    S1, S2</td>
<td style="text-align:center">根据<code>S2-S1或S2&amp;S1</code>的结果设置条件码</td>
</tr>
<tr>
<td style="text-align:center">cltq</td>
<td style="text-align:center">将 %eax 符号扩展到 %rax</td>
</tr>
<tr>
<td style="text-align:center">call/ret</td>
<td style="text-align:center">函数调用/函数返回</td>
</tr>
<tr>
<td style="text-align:center">enter/leave</td>
<td style="text-align:center">堆积/撤销一个栈</td>
</tr>
</tbody>
</table>
<p>接下来通过几个示例来进一步理解。</p>
<h2 id="mov-指令"><a class="markdownIt-Anchor" href="#mov-指令"></a> mov 指令</h2>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">exchange</span><span class="params">(<span class="type">long</span> *xp, <span class="type">long</span> y)</span> &#123;</span><br><span class="line">    <span class="type">long</span> x = *xp;</span><br><span class="line">    *xp = y;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一个参数 xp 保存在 %rdi 中，第二个参数 y 保存在 %rsi 中，返回值保存在 %rax 中</span></span><br><span class="line"><span class="comment"># *xp 是对 xp 的解引用，即读取内存中地址 xp 处所存放的值，因此表示为 (%rdi)</span></span><br><span class="line"><span class="attr">exchange:</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">(%rdi),</span> <span class="string">%rax</span>	<span class="comment"># 将 *xp 作为返回值</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">%rsi,</span> <span class="string">(%rdi)</span>	<span class="comment"># 将 y 赋值给 *xp</span></span><br><span class="line">	<span class="string">ret</span>			<span class="comment"># return</span></span><br></pre></td></tr></table></figure>
<h2 id="lea-指令"><a class="markdownIt-Anchor" href="#lea-指令"></a> lea 指令</h2>
<p>lea（load effective address）表示加载有效地址，虽然形式上是内存引用，但实际上并没有引用内存，而是将一个内存地址直接赋值给目的操作数；mov 则是将地址处的数据赋值给目的操作数。例如：</p>
<p><code>leaq 8(%rbx), %rax</code>  表示将 <code>%rbx+8</code> 这个地址直接赋值给 <code>%rax</code>，而不是把该地址处所对应的数据赋值给 <code>%rax</code>。mov 指令则恰恰相反：</p>
<p><code>movq 8(%rbx), %rax</code> 表示将 <code>%rbx+8</code> 这个地址处所对应的数据赋值给 <code>%rax</code>。</p>
<p>lea 的用法比较灵活，除了加载有效地址，还可以进行算术运算。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">scale</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span> &#123;</span><br><span class="line">    <span class="type">long</span> t = x + <span class="number">4</span> * y + <span class="number">12</span> * z;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># x in %rdi, y in %rsi, z in %rdx</span></span><br><span class="line"><span class="attr">scale:</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="string">(%rdi,</span> <span class="string">%rsi,</span> <span class="number">4</span><span class="string">),</span> <span class="string">%rax</span>	<span class="comment"># 将 x + 4y 放入 %rax</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="string">(%rdx,</span> <span class="string">%rdx,</span> <span class="number">2</span><span class="string">),</span> <span class="string">%rdx</span>	<span class="comment"># z = z + 2z = 3z</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="string">(%rax,</span> <span class="string">%rdx,</span> <span class="number">4</span><span class="string">),</span> <span class="string">%rax</span>	<span class="comment"># 将 (x + 4y) + 3z * 4 作为返回值</span></span><br><span class="line">	<span class="string">ret</span></span><br></pre></td></tr></table></figure>
<p>对于后两条 <code>leaq</code> 指令，之所以没有直接合并成 <code>leaq (%rax, %rdx, 12), %rax</code>，是因为对于变址寻址中的比例因子只能取 1、2、4、8，因此需要对 12 分解。</p>
<p>比例因子的取值与源代码中定义的数组类型相关，编译器会据此来确定比例因子的数值。比如对于 char 类型的数组，其比例因子是 1；short 类型的比例因子是 2；int 类型是 4；double 类型是 8 等等。</p>
<blockquote>
<p>判断 lea 是加载地址还是算术运算，可以根据所操作的寄存器的功能。如果是保存参数的普通寄存器一般表示算术运算，而其他特殊的寄存器则表示加载有效地址（个人观察，有待查证）。</p>
</blockquote>
<h2 id="算术指令"><a class="markdownIt-Anchor" href="#算术指令"></a> 算术指令</h2>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">arith</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span> &#123;</span><br><span class="line">    <span class="type">long</span> t1 = x ^ y;</span><br><span class="line">    <span class="type">long</span> t2 = z * <span class="number">48</span>;</span><br><span class="line">    <span class="type">long</span> t3 = t1 &amp; <span class="number">0x0F0F0F0F</span>;</span><br><span class="line">    <span class="type">long</span> t4 = t2 - t3;</span><br><span class="line">    <span class="keyword">return</span> t4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># x in %rdi, y in %rsi, z in %rdx</span></span><br><span class="line"><span class="attr">arith:</span></span><br><span class="line">	<span class="string">xorq</span>	<span class="string">%rsi,</span> <span class="string">%rdi</span>		<span class="comment"># x = x ^ y</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="string">(%rdx,</span> <span class="string">%rdx,</span> <span class="number">2</span><span class="string">),</span> <span class="string">%rax</span>	<span class="comment"># 将 z + 2z = 3z 放入 %rax</span></span><br><span class="line">	<span class="string">salq</span>	<span class="string">$4,</span> <span class="string">%rax</span>		<span class="comment"># 将 3z 左移 4 位，即 3z * 16 = 48z 作为返回值</span></span><br><span class="line">	<span class="string">andl</span>	<span class="string">$252645135,</span> <span class="string">%edi</span>	<span class="comment"># 该立即数有 8 * 4 = 32 位，因此只取前 32 位进行与运算</span></span><br><span class="line">	<span class="string">subq</span>	<span class="string">%rdi,</span> <span class="string">%rax</span>		<span class="comment"># 将 48z - t3 的值作为返回值</span></span><br><span class="line">	<span class="string">ret</span></span><br></pre></td></tr></table></figure>
<p>对于源程序第 3 行代码中的乘法操作，被编译成了 leaq 和左移两条指令。编译器之所以没有直接使用乘法指令来实现，是因为乘法指令的执行时间更长，因此编译器会优先选择更高效的方式。</p>
<h2 id="控制指令"><a class="markdownIt-Anchor" href="#控制指令"></a> 控制指令</h2>
<h3 id="条件码"><a class="markdownIt-Anchor" href="#条件码"></a> 条件码</h3>
<p>除了整数寄存器，CPU 还维护着一组单个比特位的条件码寄存器，可以通过检测这些寄存器来执行条件分支指令。常用的条件码：</p>
<table>
<thead>
<tr>
<th style="text-align:center">条件码</th>
<th style="text-align:center">全称</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CF</td>
<td style="text-align:center">Carry  Flag</td>
<td style="text-align:center">进位标志</td>
<td style="text-align:center">最高位产生了进位</td>
</tr>
<tr>
<td style="text-align:center">ZF</td>
<td style="text-align:center">Zero  Flag</td>
<td style="text-align:center">零标志位</td>
<td style="text-align:center">操作结果为零</td>
</tr>
<tr>
<td style="text-align:center">SF</td>
<td style="text-align:center">Sign  Flag</td>
<td style="text-align:center">符号标志</td>
<td style="text-align:center">操作结果为负</td>
</tr>
<tr>
<td style="text-align:center">OF</td>
<td style="text-align:center">Overflow  Flag</td>
<td style="text-align:center">溢出标志</td>
<td style="text-align:center">操作结果溢出</td>
</tr>
</tbody>
</table>
<p>算术和逻辑运算指令会改变条件码寄存器的内容（<code>leaq</code> 不会），还有两类指令专门用来设置条件码而不改变其它任何寄存器：<code>cmp</code> 和 <code>test</code>。</p>
<p><code>cmp S1, S2</code> 会根据 <code>S2 - S1</code> 的结果来设置条件码；</p>
<p><code>test S1, S2</code> 会根据 <code>S2 &amp; S1</code> 的结果来设置条件码。</p>
<p><code>test</code> 指令的典型用法是两个操作数相同，用来判断该操作数是正数，零，还是负数。对于这样的指令，如 <code>testq %rax,%rax</code>，它与 <code>cmpq $0, %rax</code> 是等价的。</p>
<p>接下来通过示例看一下对条件码的访问。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">comp</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a in %rdi, b in %rsi</span></span><br><span class="line"><span class="attr">comp:</span></span><br><span class="line">	<span class="string">cmpq</span>	<span class="string">%rsi,</span> <span class="string">%rdi</span>	<span class="comment"># 根据 a - b 的结果设置条件码寄存器</span></span><br><span class="line">	<span class="string">setl</span>	<span class="string">%al</span>		<span class="comment"># 如果 a &lt; b，将 al 寄存器设置为 1；否则设置为 0</span></span><br><span class="line">	<span class="string">movzbl</span>	<span class="string">%al,</span> <span class="string">%eax</span>	<span class="comment"># movz 表示零扩展，将 al 寄存器从 byte 扩展到 long word</span></span><br><span class="line">	<span class="string">ret</span></span><br></pre></td></tr></table></figure>
<h3 id="循环"><a class="markdownIt-Anchor" href="#循环"></a> 循环</h3>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fact_do</span><span class="params">(<span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        result *= n;</span><br><span class="line">        n = n - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span>(n &gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># n in %rdi</span></span><br><span class="line"><span class="attr">fact_do:</span></span><br><span class="line">	<span class="string">movl</span>	<span class="string">$1,</span> <span class="string">%eax</span>	<span class="comment"># 将 1 放入 %eax</span></span><br><span class="line"><span class="string">.L2:</span></span><br><span class="line">	<span class="string">imulq</span>	<span class="string">%rdi,</span> <span class="string">%rax</span>	<span class="comment"># 将 %rax 中的值更新为自身乘以 n</span></span><br><span class="line">	<span class="string">subq</span>	<span class="string">$1,</span> <span class="string">%rdi</span>	<span class="comment"># n = n - 1</span></span><br><span class="line">	<span class="string">cmpq</span>	<span class="string">$1,</span> <span class="string">%rdi</span>	<span class="comment"># 根据 n - 1 的结果设置条件码寄存器</span></span><br><span class="line">	<span class="string">jg</span>		<span class="string">.L2</span>	<span class="comment"># 如果 n &gt; 1 则跳转到 .L2 处执行</span></span><br><span class="line">	<span class="string">rep;</span> <span class="string">ret</span>		<span class="comment"># rep 是空操作，可以直接无视它</span></span><br></pre></td></tr></table></figure>
<p><code>imul</code> 表示有符号整数乘法，<code>mul</code> 则表示无符号整数乘法。</p>
<h2 id="push-与-pop-指令"><a class="markdownIt-Anchor" href="#push-与-pop-指令"></a> push 与 pop 指令</h2>
<p><code>pushq S</code>，等价于以下两条操作指令：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">subq</span>	<span class="string">$8,</span> <span class="string">%rsp</span></span><br><span class="line"><span class="string">movq</span>	<span class="string">S,</span> <span class="string">(%rsp)</span></span><br></pre></td></tr></table></figure>
<p>因此两次 push 之后 %rsp 依然指向栈顶。</p>
<p>相应地，<code>popq D</code> 也等价于两条指令：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">movq</span>	<span class="string">(%rsp),</span> <span class="string">D</span></span><br><span class="line"><span class="string">addq</span>	<span class="string">$8,</span> <span class="string">%rsp</span></span><br></pre></td></tr></table></figure>
<p>如图所示：</p>
<img src="https://img.gejiba.com/images/944e92c68fc061803e0017ae75b7e13e.webp" alt="pushpop" style="zoom:80%;" />
<h2 id="call-与-ret-指令"><a class="markdownIt-Anchor" href="#call-与-ret-指令"></a> call 与 ret 指令</h2>
<p><code>call</code> 和 <code>ret</code> 指令类似于 <code>pushq</code> 和 <code>popq</code>。</p>
<p><code>call</code> 指令会将下一条指令的地址压入栈中，然后将调用的目的地址 <code>D</code> 作为下一条执行指令的地址。</p>
<p><code>ret</code> 指令将从栈顶弹出的地址作为下一条执行的指令的地址。由 <code>call</code> 可知，这条指令其实就是 <code>call</code> 指令后面紧跟的那条指令，表示在函数调用返回后继续往下执行。</p>
<p>如图所示：</p>
<p><img src="https://img.gejiba.com/images/e3492a3a945ffa8638842c82d99b6f9e.webp" alt="callret" /></p>
<h2 id="enter-与-leave-指令"><a class="markdownIt-Anchor" href="#enter-与-leave-指令"></a> enter 与 leave 指令</h2>
<p><code>enter</code> 指令在原有的栈上堆积了一个栈，等价于以下两条操作指令：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">pushq</span>	<span class="string">%rbp</span></span><br><span class="line"><span class="string">movq</span>	<span class="string">%rsp,</span> <span class="string">%rbp</span></span><br></pre></td></tr></table></figure>
<p><code>leave</code> 指令则是撤销这个新堆积的栈，等价于以下两条指令：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">movq</span>	<span class="string">%rbp,</span> <span class="string">%rsp</span></span><br><span class="line"><span class="string">popq</span>	<span class="string">%rbp</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img.gejiba.com/images/1a55414f1ab12c87dd1345e47778e8e3.webp" alt="enter&amp;leave" /></p>
<h2 id="函数调用"><a class="markdownIt-Anchor" href="#函数调用"></a> 函数调用</h2>
<h3 id="函数栈帧"><a class="markdownIt-Anchor" href="#函数栈帧"></a> 函数栈帧</h3>
<p>当函数需要的存储空间超出寄存器所能存放的大小时，就会在栈上分配空间，这块存储空间称为该函数的 <strong>栈帧</strong>。例如，在本文最开始给出的表格中可以发现，对于前 6 个参数，每一个都有相对应的寄存器进行保存，而从第 7 个参数开始，则被保存到了栈里面。另外，还有两种常见的情况需要为函数分配栈帧，一种是对一个局部变量使用取地址符，因此必须能为它产生一个地址；另一种是当局部变量是数组或结构体。</p>
<p>当函数 P 调用函数 Q 时，其栈帧结构如下：</p>
<img src="https://img.gejiba.com/images/e89ffa3aefa3462d8eb41ee9777ead4c.webp" alt="P调用Q的栈帧结构" style="zoom:16%;" />
<p>当前正在执行的函数的栈帧总是保存在栈顶，当 P 调用 Q 时，call 指令会把返回地址压入栈中，该地址指明了当 Q 返回时，要从 P 的哪个位置继续执行。下面看一个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">proc</span><span class="params">(<span class="type">long</span>  a1, <span class="type">long</span>  *a1p,</span></span><br><span class="line"><span class="params">          <span class="type">int</span>   a2, <span class="type">int</span>   *a2p,</span></span><br><span class="line"><span class="params">          <span class="type">short</span> a3, <span class="type">short</span> *a3p,</span></span><br><span class="line"><span class="params">          <span class="type">char</span>  a4, <span class="type">char</span>  *a4p)</span> &#123;</span><br><span class="line">    *a1p += a1;</span><br><span class="line">    *a2p += a2;</span><br><span class="line">    *a3p += a3;</span><br><span class="line">    *a4p += a4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">call_proc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span>  x1 = <span class="number">1</span>; <span class="type">int</span>  x2 = <span class="number">2</span>;</span><br><span class="line">    <span class="type">short</span> x3 = <span class="number">3</span>; <span class="type">char</span> x4 = <span class="number">4</span>;</span><br><span class="line">    proc(x1, &amp;x1, x2, &amp;x2, x3, &amp;x3, x4, &amp;x4);</span><br><span class="line">    <span class="keyword">return</span> (x1 + x2) * (x3 - x4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>proc 的汇编代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a1 in %rdi, a1p in %rsi</span></span><br><span class="line"><span class="comment"># a2 in %edx, a2p in %rcx</span></span><br><span class="line"><span class="comment"># a3 in %r8w, a3p in %r9</span></span><br><span class="line"><span class="comment"># %rsp 指向栈顶</span></span><br><span class="line"><span class="comment"># a4 in %rsp+8, a4p in %rsp+16</span></span><br><span class="line"><span class="attr">proc:</span></span><br><span class="line">	<span class="string">movq</span>	<span class="number">16</span><span class="string">(%rsp),</span> <span class="string">%rax</span>	<span class="comment"># 将 a4p 放入 %rax</span></span><br><span class="line">	<span class="string">addq</span>	<span class="string">%rdi,</span> <span class="string">(%rsi)</span>	<span class="comment"># *a1p += a1</span></span><br><span class="line">	<span class="string">addl</span>	<span class="string">%edx,</span> <span class="string">(%rcx)</span>	<span class="comment"># *a2p += a2</span></span><br><span class="line">	<span class="string">addw</span>	<span class="string">%r8w,</span> <span class="string">(%r9)</span>	<span class="comment"># *a3p += a3</span></span><br><span class="line">	<span class="string">movl</span>	<span class="number">8</span><span class="string">(%rsp),</span> <span class="string">%edx</span>	<span class="comment"># 将 a4 放入 %edx</span></span><br><span class="line">	<span class="string">addb</span>	<span class="string">%dl,</span> <span class="string">(%rax)</span>	<span class="comment"># *a4p += a4</span></span><br><span class="line">	<span class="string">ret</span></span><br></pre></td></tr></table></figure>
<p>有几点需要注意：</p>
<ul>
<li>虽然从第 7 个参数开始都被保存到了栈中，但是当指令需要对这些参数操作时，仍然需要先从栈读入到寄存器中。</li>
<li>通过栈传递参数时，所有数据都需要 8 字节对齐，所以 a4 即便只有 1 个字节，仍然为其分配了 8 个字节的存储空间。<span class="p red">注意：只有借助栈传递参数时才需要 8 字节对齐，如果只是在栈中存放局部变量，比如使用了取地址运算符的局部变量（必须存放在栈中），它们是不需要对齐的。</span></li>
<li>a4 是从 %rsp+8 的位置开始存放的，而不是 %rsp 指向的位置，说明返回地址占据了栈顶位置。函数 proc 的栈帧如图所示：</li>
</ul>
<img src="https://img.gejiba.com/images/3dc0f287b4a191a0053e3de978a4726a.webp" alt="proc 的栈帧" style="zoom:45%;" />
<p>call_proc 的汇编代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">call_proc:</span></span><br><span class="line">	<span class="string">subq</span>	<span class="string">$32,</span> <span class="string">%rsp</span>	<span class="comment"># %rsp - 32，分配 32 字节大小的栈帧</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">$1,</span> <span class="number">24</span><span class="string">(%rsp)</span>	<span class="comment"># 将立即数 1 放到栈帧 %rsp + 24 处</span></span><br><span class="line">	<span class="string">movl</span>	<span class="string">$2,</span> <span class="number">20</span><span class="string">(%rsp)</span>	<span class="comment"># 将立即数 2 放到栈帧 %rsp + 20 处</span></span><br><span class="line">	<span class="string">movw</span>	<span class="string">$3,</span> <span class="number">18</span><span class="string">(%rsp)</span>	<span class="comment"># 将立即数 3 放到栈帧 %rsp + 18 处</span></span><br><span class="line">	<span class="string">movb</span>	<span class="string">$4,</span> <span class="number">17</span><span class="string">(%rsp)</span>	<span class="comment"># 将立即数 4 放到栈帧 %rsp + 17 处</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="number">17</span><span class="string">(%rsp),</span> <span class="string">%rax</span>	<span class="comment"># 将 &amp;x4 放入 %rax</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">%rax,</span> <span class="number">8</span><span class="string">(%rsp)</span>	<span class="comment"># 将 &amp;x4 放到栈帧 %rsp + 8 处作为第 8 个参数</span></span><br><span class="line">	<span class="string">movl</span>	<span class="string">$4,</span> <span class="string">(%rsp)</span>	<span class="comment"># 将立即数 4 放到栈帧 %rsp 处作为第 7 个参数</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="number">18</span><span class="string">(%rsp),</span> <span class="string">%r9</span>	<span class="comment"># 将 &amp;x3 作为第 6 个参数</span></span><br><span class="line">	<span class="string">movl</span>	<span class="string">$3,</span> <span class="string">%r8d</span>	<span class="comment"># 将立即数 3 作为第 5 个参数</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="number">20</span><span class="string">(%rsp),</span> <span class="string">%rcx</span>	<span class="comment"># 将 &amp;x2 作为第 4 个参数</span></span><br><span class="line">	<span class="string">movl</span>	<span class="string">$2,</span> <span class="string">%edx</span>	<span class="comment"># 将立即数 2 作为第 3 个参数</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="number">24</span><span class="string">(%rsp),</span> <span class="string">%rsi</span>	<span class="comment"># 将 &amp;x1 作为第 2 个参数</span></span><br><span class="line">	<span class="string">movl</span>	<span class="string">$1,</span> <span class="string">%edi</span>	<span class="comment"># 将立即数 1 作为第 1 个参数</span></span><br><span class="line">	<span class="comment"># 调用函数 proc</span></span><br><span class="line">	<span class="string">call</span>	<span class="string">proc</span></span><br><span class="line">	<span class="string">movslq</span>	<span class="number">20</span><span class="string">(%rsp),</span> <span class="string">%rdx</span>	<span class="comment"># 将 x2 符号扩展为四字放入 %rdx</span></span><br><span class="line">	<span class="string">addq</span>	<span class="number">24</span><span class="string">(%rsp),</span> <span class="string">%rdx</span>	<span class="comment"># 将 x2 + x1 放入 %rdx</span></span><br><span class="line">	<span class="string">movswl</span>	<span class="number">18</span><span class="string">(%rsp),</span> <span class="string">%eax</span>	<span class="comment"># 将 x3 符号扩展为双字放入 %eax</span></span><br><span class="line">	<span class="string">movsbl</span>	<span class="number">17</span><span class="string">(%rsp),</span> <span class="string">%ecx</span>	<span class="comment"># 将 x4 符号扩展为双字放入 %ecx</span></span><br><span class="line">	<span class="string">subl</span>	<span class="string">%ecx,</span> <span class="string">%eax</span>	<span class="comment"># 将 x3 - x4 放入 %eax</span></span><br><span class="line">	<span class="string">cltq</span>			<span class="comment"># 将 %eax 符号扩展到 %rax</span></span><br><span class="line">	<span class="string">imulq</span>	<span class="string">%rdx,</span> <span class="string">%rax</span>	<span class="comment"># 将 (x3 - x4) * (x2 + x1) 作为返回值</span></span><br><span class="line">	<span class="string">addq</span>	<span class="string">$32,</span> <span class="string">%rsp</span>	<span class="comment"># %rsp + 32，释放 32 字节大小的栈帧</span></span><br><span class="line">	<span class="string">ret</span></span><br></pre></td></tr></table></figure>
<p>函数 call_proc 的栈帧如图所示：</p>
<img src="https://img.gejiba.com/images/64c8434dd3f2a16518fbd172400264e8.webp" alt="call_proc 的栈帧" style="zoom:45%;" />
<h3 id="被调用者保存寄存器"><a class="markdownIt-Anchor" href="#被调用者保存寄存器"></a> [被]调用者保存寄存器</h3>
<p>在程序执行的过程中，寄存器是被所有函数共享的，因此为了确保在使用过程中寄存器内的数据不被覆盖，处理器采用了一组统一的寄存器使用惯例，所有函数都必须遵守。</p>
<p>根据惯例，对于 16 个通用寄存器，除了 %rsp 之外，其余 15 个寄存器被划分为调用者保存和被调用者保存。其中，%rbx、%rbp、%r12~%r15 被划分为 <strong>被调用者保存寄存器</strong>，剩余的被划分为 <strong>调用者保存寄存器</strong>。下面以一个例子说明其使用方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">P</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span> &#123;</span><br><span class="line">    <span class="type">long</span> u = Q(y);</span><br><span class="line">    <span class="type">long</span> v = Q(x);</span><br><span class="line">    <span class="keyword">return</span> u + v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># x in %rdi, y in %rsi</span></span><br><span class="line"><span class="attr">P:</span></span><br><span class="line">	<span class="string">pushq</span>	<span class="string">%rbp</span>		<span class="comment"># 保存 %rbp 中的值</span></span><br><span class="line">	<span class="string">pushq</span>	<span class="string">%rbx</span>		<span class="comment"># 保存 %rbx 中的值</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">%rdi,</span> <span class="string">%rbp</span>	<span class="comment"># 将 %rdi 中的值 x 保存到 %rbp 中</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">%rsi,</span> <span class="string">%rdi</span>	<span class="comment"># 将 y 放入 %rdi 作为第一个参数</span></span><br><span class="line">	<span class="string">call</span>	<span class="string">Q</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">%rax,</span> <span class="string">%rbx</span>	<span class="comment"># 将 Q 的返回结果 u 保存到 %rbx 中</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">%rbp,</span> <span class="string">%rdi</span>	<span class="comment"># 将 x 放入 %rdi 作为第一个参数</span></span><br><span class="line">	<span class="string">call</span>	<span class="string">Q</span></span><br><span class="line">	<span class="string">addq</span>	<span class="string">%rbx,</span> <span class="string">%rax</span>	<span class="comment"># 将 v + u 作为返回值</span></span><br><span class="line">	<span class="string">addq</span>	<span class="string">$8,</span> <span class="string">%rsp</span>	<span class="comment"># 释放 8 个字节的栈帧</span></span><br><span class="line">	<span class="string">popq</span>	<span class="string">%rbx</span>		<span class="comment"># 恢复 %rbx 中的值</span></span><br><span class="line">	<span class="string">popq</span>	<span class="string">%rbp</span>		<span class="comment"># 恢复 %rbp 中的值</span></span><br><span class="line">	<span class="string">ret</span></span><br></pre></td></tr></table></figure>
<p>在函数 P 中，x 保存在 %rdi 中，当在第 7 行调用函数 Q 时，由于 Q 有一个参数，因此也会使用 %rdi。为了防止 P 中的 %rdi 值被覆盖，需要先将其保存到一个其他无关的寄存器 %rbp 中（第 6 行），而为了防止原本 %rbp 中的内容被覆盖，在此之前还需将其中的内容压入栈中保存起来（第 3 行）。</p>
<p>同样的道理，当第一次调用 Q 结束时，结果会被保存在 %rax 中返回；而当第二次调用函数 Q 时，其返回结果仍然会保存在 %rax 中。为了防止第一次返回的结果被覆盖，需要先将其保存到一个其他无关的寄存器 %rbx 中（第 8 行），而为了防止原本 %rbx 中的内容被覆盖，在此之前还需将其中的内容压入栈中保存起来（第 4 行）。</p>
<p>在函数 P 结束之前，按照栈后进先出的顺序出栈，依次恢复 %rbx 和 %rbp 中的内容。</p>
<h3 id="函数递归调用"><a class="markdownIt-Anchor" href="#函数递归调用"></a> 函数递归调用</h3>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">rfact</span><span class="params">(<span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)</span><br><span class="line">        result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        result = n * rfact(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># n in %rdi</span></span><br><span class="line"><span class="attr">rfact:</span></span><br><span class="line">	<span class="string">pushq</span>	<span class="string">%rbx</span>			<span class="comment"># 保存 %rbx 中的值</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">%rdi,</span> <span class="string">%rbx</span>		<span class="comment"># 将 n 放入 %rbx</span></span><br><span class="line">	<span class="string">movl</span>	<span class="string">$1,</span> <span class="string">%eax</span>		<span class="comment"># 将 1 放入 %rax</span></span><br><span class="line">	<span class="string">cmpq</span>	<span class="string">$1,</span> <span class="string">%rdi</span>		<span class="comment"># 根据 n - 1 的值设置条件码寄存器</span></span><br><span class="line">	<span class="string">jle</span>	<span class="string">.L35</span>			<span class="comment"># 如果 n &lt;= 1，跳转到 .L35</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="number">-1</span><span class="string">(%rdi),</span> <span class="string">%rdi</span>		<span class="comment"># 将 n = n - 1 作为第一个参数</span></span><br><span class="line">	<span class="string">call</span>	<span class="string">rfact</span>			<span class="comment"># 调用函数 rfact</span></span><br><span class="line">	<span class="string">imulq</span>	<span class="string">%rbx,</span> <span class="string">%rax</span>		<span class="comment"># 将 rfact(n - 1) * n 的值放入 %rax</span></span><br><span class="line"><span class="string">.L35:</span></span><br><span class="line">	<span class="string">popq</span>	<span class="string">%rbx</span>			<span class="comment"># 恢复 %rbx 中的值</span></span><br><span class="line">	<span class="string">ret</span></span><br></pre></td></tr></table></figure>
<h2 id="数组和指针"><a class="markdownIt-Anchor" href="#数组和指针"></a> 数组和指针</h2>
<p>数组在内存中是连续存放的，每个元素所占内存的大小由数组类型决定，如图所示：</p>
<img src="https://img.gejiba.com/images/e3d43bd460b0c20d24ce0fd3018b4f7b.webp" alt="array" style="zoom:62%;" />
<p>对指针进行运算时，计算结果会根据指针类型进行相应的伸缩。为方便理解，将内存抽象成一个很大的数组，假设初始时指针 p 和 q 都指向 0x100 处，现分别对两个指针进行加 1 操作，由于指针类型不同，指针 p + 1 会前进 1 个字节，而指针 q + 1 会前进 4 个字节，如图所示：</p>
<img src="https://img.gejiba.com/images/fb5a7e558f74a7c9c29816a82405f68a.webp" alt="padd" style="zoom:70%;" />
<p>而数组名正是指向该数组首元素的指针，因此对于数组 <code>int arr[5]</code> 中的每一个元素，均有两种表示方式，如图所示：</p>
<img src="https://img.gejiba.com/images/38e1cc7b41ea67d443c837bebf6bbe95.webp" alt="parr" style="zoom:75%;" />
<p>对于二维数组，在内存中是按照行优先的顺序存储的：</p>
<img src="https://img.gejiba.com/images/af9f4f55dd7d45b4c94e582e69595f8c.webp" alt="2D-array" style="zoom:70%;" />
<h2 id="结构体和联合体"><a class="markdownIt-Anchor" href="#结构体和联合体"></a> 结构体和联合体</h2>
<p>CPU 是按 32/64 位的大小进行存取的，为了提高 CPU 的执行效率，计算机系统对基本数据类型的合法地址做了一些限制，要求某种类型的地址必须是某个值（2 / 4 / 8）的倍数，这就是 <strong>数据对齐</strong>。数据对齐会由编译器自动实现，但了解其实现方法还是很有必要的，可以优化代码结构，达到节省空间和提高效率（减少访存次数）的目的。</p>
<p>数据对齐的基本原则是：<span class="p red">任何 K 字节的基本对象的地址必须是 K 的倍数</span>。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>  i;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span>  j;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果不进行数据对齐（以 64 位机器为例），结构体 S1 在内存中的分布如图 (a) 所示。</p>
<p>虽然整体只占了 9 个字节，但要访问成员 j，需要访问两次内存才行，这样效率并不高。而如果进行了数据对齐，则访问所有成员都只需访问一次内存即可，如图 (b)。其中在 c 后面插入 3 个字节，是因为 j 占 4 个字节，所以它的起始地址必须是 4 的倍数。</p>
<p>另外，在结构体的末尾，可能也需要一些填充。比如假设结构体 S1 中没有成员 j，那所有元素都是满足对齐要求的，但是当该结构体声明为数组时（比如 <code>struct S1 arr[2]</code>），对齐原则就无法保证了，因此需要在末尾进行填充以满足结构体数组的对齐原则，如图 (c)。</p>
<img src="https://img.gejiba.com/images/56afaf0f2107e96c0d3562725c18e2be.webp" alt="align" style="zoom:50%;" />
<p>与结构体不同，联合体中的所有字段共享同一存储区域，因此联合体的大小取决于其最大字段的大小。如果我们事先知道两个不同字段的使用是互斥的，那么就可以将这两个字段声明为一个联合体，从而达到节省内存空间的目的。</p>
<p>此外，联合体还可以用来访问不同数据类型的位模式，比如判断机器的大小端：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">    &#125; temp;</span><br><span class="line">    temp.i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(temp.c == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Little Endian\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Big Endian\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 i 占 4 个字节，c 占 1 个字节，二者共享同一段内存，因此只需为 temp 分配 4 字节的空间。当为联合体中的 i 赋值后（第 6 行），为 temp 分配的四个字节都填满了，此时访问其中的 c 成员，其实就是访问这段内存的第 1 个字节，即低地址处的第 1 个字节。</p>
<p>对于 4 字节的整型 1，其十六进制表示为 <code>0x0000 0001</code>。若机器是小端，则低位放低地址处，高位放高地址处，地址从低到高依次为 <code>0x01 0x00 0x00 0x00</code>；若机器是大端，则低位放高地址处，高位放低地址处，地址从低到高依次为 <code>0x00 0x00 0x00 0x01</code>。</p>
<p>此时只需判断 c 的值是 <code>0x01</code> 还是 <code>0x00</code>，即可判断机器是小端还是大端。</p>
<p>再比如，可以用如下方法来获取 double 类型的二进制位表示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">double2bits</span><span class="params">(<span class="type">double</span> d)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> u;</span><br><span class="line">    &#125; temp; <span class="comment">// 以一种类型存储，以另一种类型访问</span></span><br><span class="line">    temp.d = d;</span><br><span class="line">    <span class="keyword">return</span> temp.u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>double</code> 与 <code>unsigned long</code> 所占的字节相同，因此当为 d 赋值后，d 和 u 就共同拥有了相同大小的内存空间，此时对 u 的访问即是 d 的二进制位的十进制表示。</p>
]]></content>
      <categories>
        <category>读书笔记 - CSAPP</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>栈帧</tag>
        <tag>数据对齐</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机系统漫游</title>
    <url>/posts/4223884717.html</url>
    <content><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>《深入理解计算机系统-CSAPP》是计算机领域的圣经✨之前翻看过两三次，不过由于平时在实验室一直都有各种事情牵扯时间跟精力，每次阅读都近乎走马观花。</p>
<p>最近论文送审之后终于有了充足的时间，于是便静下心来重新读了一遍。对于其中一些晦涩难懂且意义不大（个人愚见）的知识点（如浮点数的表示和运算、存储器山等等）本人并未细究，这里仅对自己之前没有完全掌握，或者易忘易混淆的知识点做个记录📝方便日后查阅。</p>
<p>在整理了部分内容之后我发现整体架构看起来依然有些零散，没有逻辑主线💥事实上我也确实是从 <code>hello.c</code> 程序编译的各个过程中发散出来的小的知识点。</p>
<p>为了使介绍能够更加聚焦，后续内容我决定采用问答的形式，然后从回答中抽取关键字来“浅挖”其原理和细节。能力一般，水平有限，所有内容仅仅是个人的一些粗浅的理解，之后我会尽量多读相关书籍来修正和完善这些内容🚩</p>
<p>『计算机系统漫游』部分主要是对全书中我比较感兴趣的部分做一个粗略的介绍，其中每个 <span class="inline-tag blue">蓝色小标签</span> 中的内容（包括但不限于此）都将是后续博客中进一步展开介绍的对象~~</p>
<h2 id="从hello-world开始"><a class="markdownIt-Anchor" href="#从hello-world开始"></a> 从Hello World开始</h2>
<p><img src="https://img.gejiba.com/images/2df68f1e0cc0ea3c4bd7722f0b09e509.webp" alt="Hello World编译过程" /></p>
<h2 id="文本文件与二进制文件"><a class="markdownIt-Anchor" href="#文本文件与二进制文件"></a> 文本文件与二进制文件</h2>
<p>我们所编写的 <code>hello.c</code> 程序属于文本文件，经过编译后生成的可执行文件是二进制文件。它们最终在物理内存上都是以二进制形式保存的，因此二者的主要区别是逻辑上的而不是物理上的：</p>
<ul>
<li>
<p>文本文件：基于字符编码，如ASCII、Unicode等，每个值都有固定的Size。</p>
</li>
<li>
<p>二进制文件：基于值编码，没有固定的Size，实际上就是把值在物理内存上的原始二进制形式。</p>
</li>
</ul>
<p>比如 <code>\n</code> 在文本文件中是换行符，而在二进制文件中会被认为是 <code>\</code> 和 <code>n</code> 两个字符。</p>
<h2 id="原码-反码和补码"><a class="markdownIt-Anchor" href="#原码-反码和补码"></a> 原码、反码和补码</h2>
<p>有符号数的表示方法有三种，分别是原码、反码和补码，它们都是用最高位的 <code>0</code> 和 <code>1</code> 来区分正负。对于正数，三者的表示都是一致的，即该数的二进制表示，主要区别是在负数上。例如 <code>15</code> 的二进制表示为 <code>0000 1111</code>，而对于 <code>-15</code>：</p>
<ul>
<li>原码：<code>1000 1111</code> 符号位 + 二进制表示</li>
<li>反码：<code>1111 0000</code> 在原码基础上，除符号位外全部取反</li>
<li>补码：<code>1111 0001</code> 反码 + 1</li>
</ul>
<p>在计算机中，有符号数是用补码来表示的。之所以不用另外两种编码方式，是因为对于数字 <code>0</code>，二者都有两种不同的编码方式，分别是 <code>+0</code> 和 <code>-0</code>，而补码则不存在这种问题。</p>
<h2 id="汇编程序与机器指令"><a class="markdownIt-Anchor" href="#汇编程序与机器指令"></a> 汇编程序与机器指令</h2>
<p>高级语言编写的程序可以在很多不同的机器上编译运行，生成该机器所支持的 <span class="inline-tag blue">机器指令</span>。 <span class="inline-tag blue">汇编程序</span> 是机器指令的文本表示，在不同指令级架构的机器上有不同的表现形式，这也就解释了为什么最终生成的可执行目标文件一般都不能跨平台执行。</p>
<p>Java之所以能够跨平台（一次编译多次运行），是因为它并不是直接运行在CPU上的，而是生成字节码（.class）文件后由 JVM 统一执行。此时JVM有两种选择：一种是使用 Java 解释器解释执行，另一种是使用 JIT 编译器将字节码转化为本地机器指令。</p>
<p>二者的区别在于，前者启动速度快但运行速度慢，后者启动速度慢但运行速度快。这是因为解释器不需要像 JIT 编译器一样，将所有字节码都转化为机器指令，自然就省去了优化的时间。而当 JIT 编译器完成第一次编译后会将字节码对应的机器指令保存下来，下次可以直接使用。由于机器指令的执行效率要高于 Java 解释器，所以在实际情况中，为了速度和效率，通常采用两者相结合的方式。</p>
<h2 id="可重定位文件与可执行文件"><a class="markdownIt-Anchor" href="#可重定位文件与可执行文件"></a> 可重定位文件与可执行文件</h2>
<p>如果想让代码运行，那么生成的目标代码中的每个符号（函数或变量）的地址都应该是确定的。事实上，在汇编阶段，只有跟源代码在同一个模块中的符号地址能确定下来，而定义在其他模块中的全局变量和函数的地址要在链接的时候才能确定。编译器在没法确定地址的情况下，会先将其置为 0，等到链接的时候再去修正它们，这个过程就是<span class="inline-tag blue">重定位</span>。因此很自然地，在链接之前（汇编阶段）生成的目标文件叫做可重定位目标文件，在链接之后生成的目标文件叫做 <span class="inline-tag blue">可执行目标文件</span>。</p>
<h2 id="静态链接与动态链接"><a class="markdownIt-Anchor" href="#静态链接与动态链接"></a> 静态链接与动态链接</h2>
<p>链接分为 <span class="inline-tag blue">静态链接</span> 和 <span class="inline-tag blue">动态链接</span>，二者的区别在于：静态链接会把引用到的所有目标文件全部嵌入到可执行文件中，因此生成的是完全可执行的目标文件；动态链接只会链接所引用文件的重定位和符号表信息，因此生成的是部分链接的可执行目标文件，直到运行或加载的时候，才会由动态链接器将物理内存中的共享库的地址与其链接起来。</p>
<h2 id="cpu流水线划分"><a class="markdownIt-Anchor" href="#cpu流水线划分"></a> CPU流水线划分</h2>
<p>CPU流水线最经典的划分方式包括：取指、译码、执行、访存、写回、更新PC寄存器。这些阶段看似简单，但有很多细节与我之前的理解存在严重偏差。比如取指阶段就只是单纯地从PC寄存器取出指令吗？译码阶段是要对取出的机器指令进行翻译吗？执行阶段好像是最简单的，就是执行我们程序逻辑中的主体运算，但就只有这一种情况吗？访存就是访问DRAM内存吗？写回是将修改后的值重新写回到内存吗？当然这些答案都是否定的，后续我会详细介绍 <span class="inline-tag blue">CPU流水线</span> 的这几个阶段。</p>
<h2 id="高速缓存存储器"><a class="markdownIt-Anchor" href="#高速缓存存储器"></a> 高速缓存存储器</h2>
<p><span class="inline-tag blue">高速缓存</span> 的结构可以用<code>(S, E, B, m)</code>来表示，每个缓存行中还保存了有效位和标记位，方便快速定位目标数据，那具体工作过程是怎样的呢？另外根据<code>E</code>的不同，可以分为直接映射、组相连和全相连的高速缓存，这样划分的目的是什么？各有都有哪些优缺点？每种方式都有自己的应用场景吗？</p>
<h2 id="物理内存和虚拟内存"><a class="markdownIt-Anchor" href="#物理内存和虚拟内存"></a> 物理内存和虚拟内存</h2>
<p><span class="inline-tag blue">虚拟内存</span> 并不是虚拟的、非真实存在的内存，而是对磁盘的虚拟化，将内存视为磁盘的高速缓存，在内存空间不足时将磁盘的一块区域划分成虚拟内存，通过与物理内存的换入换出来满足程序运行的需求。有虚拟内存自然就有 <span class="inline-tag blue">虚拟地址</span>，相应地也会有物理地址，它们之间是如何完成映射的？进程的虚拟地址空间是真实存在的吗？是保存在物理内存中的吗？程序请求分配到的内存是物理内存吗？<span class="inline-tag blue">内存分配</span> 后忘记释放内存会怎么样？Java不需要手动释放内存，那它的 <span class="inline-tag blue">垃圾回收</span> 机制是怎么实现的？这些问题我都会在后续博客中一一解答。</p>
]]></content>
      <categories>
        <category>读书笔记 - CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>This is a test blog</title>
    <url>/posts/1243066710.html</url>
    <content><![CDATA[<h1 id="一级标题"><a class="markdownIt-Anchor" href="#一级标题"></a> 一级标题</h1>
<p>Welcome to <a href="https://hexo.io/">Hexo</a>!</p>
<h2 id="二级标题"><a class="markdownIt-Anchor" href="#二级标题"></a> 二级标题</h2>
<h3 id="三级标题"><a class="markdownIt-Anchor" href="#三级标题"></a> 三级标题</h3>
<h1 id="基础语法"><a class="markdownIt-Anchor" href="#基础语法"></a> 基础语法</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mapToBucket</span><span class="params">(<span class="type">unsigned</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v &gt;= <span class="number">0</span> &amp;&amp; v &lt; <span class="number">10</span>)  <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">if</span> (v &gt;= <span class="number">10</span> &amp;&amp; v &lt; <span class="number">20</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">if</span> (v &gt;= <span class="number">20</span> &amp;&amp; v &lt; <span class="number">30</span>) <span class="keyword">return</span> <span class="number">2</span>; <span class="keyword">if</span> (v &gt;= <span class="number">30</span> &amp;&amp; v &lt; <span class="number">40</span>) <span class="keyword">return</span> <span class="number">3</span>; <span class="keyword">if</span> (v &gt;= <span class="number">40</span> &amp;&amp; v &lt; <span class="number">50</span>) <span class="keyword">return</span> <span class="number">4</span>; <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按住<kbd>Ctrl</kbd>键<code>跳转</code></p>
<blockquote>
<p>提示块标签</p>
</blockquote>
<ul>
<li>
<p>无序列表1</p>
</li>
<li>
<p>无序列表2</p>
</li>
</ul>
<ol>
<li>有序列表1</li>
<li>有序列表2</li>
</ol>
<p><mark>文本高亮</mark>，<strong>加粗</strong>，<em>斜体</em>，<mark><em><strong>斜体高亮加粗</strong></em></mark>，<s>删除线</s>，<u>下划线</u>。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">+ 新增行</span></span><br><span class="line"><span class="deletion">- 删除行</span></span><br><span class="line">其他行</span><br></pre></td></tr></table></figure>
<h1 id="分隔线"><a class="markdownIt-Anchor" href="#分隔线"></a> 分隔线</h1>
<hr />
<h1 id="标签外挂"><a class="markdownIt-Anchor" href="#标签外挂"></a> 标签外挂</h1>
<div class="note default flat"><p>default 标签外挂</p>
</div>
<div class="note primary flat"><p>primary 标签外挂</p>
</div>
<div class="note success flat"><p>success 标签外挂</p>
</div>
<div class="note danger flat"><p>danger 标签外挂</p>
</div>
<div class="note info flat"><p>info 标签外挂</p>
</div>
<div class="note warning flat"><p>warning 标签外挂</p>
</div>
<div class="note red flat"><p>red  标签外挂</p>
</div>
<div class="note quote flat"><p>quote  标签外挂</p>
</div>
<div class="tip">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<div class="tip success">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<div class="tip error">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<div class="tip warning">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<div class="tip wtgo">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<div class="tip ban">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<div class="tip home">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<div class="tip important">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<div class="tip ref">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<div class="tip ffa">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<div class="tip key">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<div class="tip socd">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<h1 id="容器"><a class="markdownIt-Anchor" href="#容器"></a> 容器</h1>
<div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test2-1">test2 1</button></li><li class="tab"><button type="button" data-href="#test2-2">test2 2</button></li><li class="tab active"><button type="button" data-href="#test2-3">test2 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test2-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="test2-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<div class="tabs" id="test3"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test3-1">test3 1</button></li><li class="tab"><button type="button" data-href="#test3-2">test3 2</button></li><li class="tab"><button type="button" data-href="#test3-3">test3 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test3-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">第一个Tab</button></li><li class="tab"><button type="button" data-href="#test4-2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#test4-3"><i class="fas fa-bomb"></i>炸弹</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab名字为第一个Tab</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><strong>只有图标 没有Tab名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p><strong>名字+icon</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h1 id="tag-hide"><a class="markdownIt-Anchor" href="#tag-hide"></a> tag hide</h1>
<p>哪个英文字母最酷？ <span class="hide-inline"><button type="button" class="hide-button" style="background-color: #FF7242;color: #fff">查看答案
  </button><span class="hide-content">因为西装裤(C装酷)</span></span></p>
<p>门里站着一个人? <span class="hide-inline"><button type="button" class="hide-button" style="">Click
  </button><span class="hide-content">闪</span></span></p>
<h1 id="block"><a class="markdownIt-Anchor" href="#block"></a> Block</h1>
<div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><div class="fj-gallery"><p><img src="https://cdn1.tianli0.top/gh/exploreMeta/cdn/img/banner/about.webp" alt="" /><br /><img src="https://cdn1.tianli0.top/gh/exploreMeta/cdn/img/banner/donate.webp" alt="" /></p>
          </div></div></div>
<h1 id="toggle"><a class="markdownIt-Anchor" href="#toggle"></a> Toggle</h1>
<details class="toggle" ><summary class="toggle-button" style="">查看代码</summary><div class="toggle-content"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure></div></details>
<h1 id="按键"><a class="markdownIt-Anchor" href="#按键"></a> 按键</h1>
<p><kbd>Ctrl </kbd>+<kbd>C </kbd> <kbd>Ctrl </kbd>+<kbd>V </kbd></p>
<h1 id="小标签"><a class="markdownIt-Anchor" href="#小标签"></a> 小标签</h1>
<!-- note语法示例 -->
<p class='div-border green left right'>加粗绿色</p>
<p class='div-border green'>绿色</p>
<p class='div-border red'>红色</p>
<p class='div-border yellow'>黄色</p>
<p class='div-border grey'>灰色</p>
<p class='div-border blue'>蓝色</p>
<!-- 小tag标签语法示例 -->
<span class="inline-tag red">红色小标签</span>
<span class="inline-tag green">绿色小标签</span>
<span class="inline-tag blue">蓝色小标签</span>
<span class="inline-tag yellow">黄色小标签</span>
<span class="inline-tag grey">灰色小标签</span>
<h1 id="彩色文字"><a class="markdownIt-Anchor" href="#彩色文字"></a> 彩色文字</h1>
<p>在一段话中方便插入各种颜色的标签，包括：<span class="p red">红色</span>、<span style="color:#ffbd2b">黄色</span>、<span class="p green">绿色</span>、<span class="p cyan">青色</span>、<span class="p blue">蓝色</span>。</p>
<h1 id="密码样式文本"><a class="markdownIt-Anchor" href="#密码样式文本"></a> 密码样式文本</h1>
<p><psw>你能看见我吗？</psw></p>
<h1 id="用markdown编写的表格样式"><a class="markdownIt-Anchor" href="#用markdown编写的表格样式"></a> 用markdown编写的表格样式</h1>
<table>
<thead>
<tr>
<th>写法</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>title</td>
<td>【必需】文章标题</td>
</tr>
<tr>
<td>date</td>
<td>【必需】文章创建日期</td>
</tr>
<tr>
<td>updated</td>
<td>【可选】文章更新日期</td>
</tr>
<tr>
<td>tags</td>
<td>【可选】文章标籤</td>
</tr>
<tr>
<td>categories</td>
<td>【可选】文章分类</td>
</tr>
<tr>
<td>keywords</td>
<td>【可选】文章关键字</td>
</tr>
<tr>
<td>description</td>
<td>【可选】文章描述</td>
</tr>
<tr>
<td>top_img</td>
<td>【可选】文章顶部图片</td>
</tr>
<tr>
<td>cover</td>
<td>【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false/图片地址/留空)</td>
</tr>
<tr>
<td>toc</td>
<td>【可选】显示文章TOC(默认为设置中toc的enable配置)</td>
</tr>
<tr>
<td>toc_number</td>
<td>【可选】显示toc_number(默认为设置中toc的number配置)</td>
</tr>
<tr>
<td>auto_open</td>
<td>【可选】是否自动打开TOC(默认为设置中toc的auto_open配置)</td>
</tr>
<tr>
<td>copyright</td>
<td>【可选】显示文章版权模块(默认为设置中post_copyright的enable配置)</td>
</tr>
<tr>
<td>mathjax</td>
<td>【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</td>
</tr>
<tr>
<td>katex</td>
<td>【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</td>
</tr>
<tr>
<td>aplayer</td>
<td>【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</td>
</tr>
<tr>
<td>highlight_shrink</td>
<td>【可选】配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置)</td>
</tr>
<tr>
<td>comments</td>
<td>【可选】显示文章评论模块(默认 true)</td>
</tr>
</tbody>
</table>
<p>另一种常见表格样式：</p>
<div alt="three-table"> <!--alt还可取值为"notitle-table"，一种无表头的小型表格-->
<table>
  <tr>
    <th alt="left">标题1</th>
    <th alt="center">标题2</th>
    <th alt="right">标题3</th>
  </tr>
  <tr>
    <td alt="left">居左：alt="left"</td>
    <td alt="center">居中：alt="center"</td>
    <td alt="right">居右：alt="right"</td>
  </tr>
  <tr>
    <td alt="left">x</td>
    <td alt="center">y</td>
    <td alt="right">z</td>
  </tr>
</table>
</div>
<p><a href="#%E4%BA%8C%E7%BA%A7%E6%A0%87%E9%A2%98">跳转</a>至二级标题（锚点）</p>
<h1 id="上下标"><a class="markdownIt-Anchor" href="#上下标"></a> 上下标</h1>
<p>X<sup>2</sup>, H<sub>2</sub>O，下标如果是多个单词或字符并以空格分隔，需要对空格进行转义，即在空格前面加<code>\</code>，（X<sub>下标1 下标2</sub>）。要显示*特殊字符等，也是通过反斜杠转义</p>
<h1 id="双语"><a class="markdownIt-Anchor" href="#双语"></a> 双语</h1>
<ul>
<li>
<p><ruby>Base<rp> (</rp><rt>top</rt><rp>)</p>
</li>
<li>
<p></rp></ruby>、<ruby>佐天泪子<rp> (</rp><rt>xiān qún kuáng mó</rt><rp>) </rp></ruby></p>
</li>
<li>
<p><ruby>超電磁砲<rp> (</rp><rt>レールガン</rt><rp>) </rp></ruby></p>
</li>
</ul>
<h1 id="图片"><a class="markdownIt-Anchor" href="#图片"></a> 图片</h1>
<img src="https://cdn1.tianli0.top/gh/exploreMeta/cdn/img/banner/client.jpg" style="zoom: 67%;"/>
<p>Gallery 相册</p>
<div class="fj-gallery"><p><img src="https://cdn1.tianli0.top/gh/exploreMeta/cdn/img/banner/about.webp" alt="" /><br /><img src="https://cdn1.tianli0.top/gh/exploreMeta/cdn/img/banner/donate.webp" alt="" /></p>
          </div>
<h1 id="音乐"><a class="markdownIt-Anchor" href="#音乐"></a> 音乐</h1>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" src="//music.163.com/outchain/player?type=2&id=1342183925&auto=0"></iframe>
<h1 id="emoji表情"><a class="markdownIt-Anchor" href="#emoji表情"></a> Emoji表情</h1>
<p><a href="https://hub.xn--p8jhe.tw/SmallOyster/emoji">查询链接</a></p>
]]></content>
  </entry>
</search>
