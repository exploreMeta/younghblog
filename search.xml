<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++内存分配</title>
    <url>/posts/1960641146.html</url>
    <content><![CDATA[<h3 id="1-池化技术"><a class="markdownIt-Anchor" href="#1-池化技术"></a> 1. 池化技术</h3>
<p><strong>池</strong> 是计算机技术中经常使用的一种设计模型，其内涵在于：将程序中需要经常使用的核心资源先申请出来放到一个池中，由程序自己管理，不仅能够提高资源的利用率，还能保证本程序占有的资源数量。经常使用的池化技术包括内存池和线程池。</p>
<h3 id="2-内存池"><a class="markdownIt-Anchor" href="#2-内存池"></a> 2. 内存池</h3>
<p><strong>内存池</strong> 是一种动态内存分配与管理的技术。我们通常习惯使用 malloc/free等 API进行内存的申请和释放，这样导致的后果是：当程序长时间运行时，由于所申请的内存块大小不定，导致频繁使用这些 API时会产生大量的内存碎片，从而降低空间利用率。内存池是在真正使用内存之前，先申请分配一块大内存（内存池）留作备用，之后所有对内存的申请和释放操作都在这个内存池中进行。当内存池不够用时，继续从堆中申请更大的内存来扩大内存池。</p>
<h3 id="3-c中的内存分配技术"><a class="markdownIt-Anchor" href="#3-c中的内存分配技术"></a> 3. C++中的内存分配技术</h3>
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://wx1.sinaimg.cn/mw690/006ept9Hgy1gthp1wn1ihj30is0gsq3r.jpg" alt="内存分配" style="zoom:70%;" />
<p>为了减少内存碎片，C++ 通过内存池来管理内存。内存池维护了 16 个空闲链表，它们分别管理大小为 8、16、24、32、…、120、128 字节的内存，基本思路是：</p>
<ul>
<li>
<p>如果用户申请的内存大于 128 字节，直接使用 malloc() ，否则找到合适的空闲链表（需将申请内存大小 <code>m_size</code>上调至 8 的倍数 <code>size</code>），从上面摘下一个节点并将其头指针返回给用户，然后修改链表指针指向下一个未分配节点。</p>
<ul>
<li>
<p>如果空闲链表中没有可用节点，则使用 refill() 函数来填充空闲链表。具体做法是，在内存池中寻找大小为 20 * <code>size</code> 的空间划分给当前的空闲链表（因为此时空闲链表已经没有可分配节点，因此一次性给它分配了20 个节点），若不够 20 个，则能取多少就取多少。如果只有 1 个节点大小的空间，则直接返回给用户。如果连 1 个都没有，则需要通过 malloc() 从堆中申请内存。</p>
</li>
<li>
<p>从堆中申请到的内存依然是放到内存池中，如果分配成功，内存池中就有了可用空间，但此时用户所申请的那个空闲链表依然是空的，因此需要继续使用 refill() 函数再次执行上述过程。如果分配失败，即堆空间也不够用了，就会循环各个空闲链表来寻找空间，然后分给内存池。接下来的过程依然是执行 refill() 函数来填充当前所申请的空闲链表。如果在各空闲链表中依然找不到空间，那就只能抛出 bad_alloc 异常了。</p>
</li>
</ul>
</li>
<li>
<p>释放过程与分配相对应，如果待释放内存大于 128 字节，直接使用 free()，否则找到合适的空闲链表，将该内存节点重新连接到链表中。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>内存分配</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU分支预测优化</title>
    <url>/posts/2892503324.html</url>
    <content><![CDATA[<p>之前介绍过CPU的分支预测功能，如果错误的分支预测经常发生，性能损失就会显著增加。因为当这样的事件发生时，CPU 需要清除所有提前完成但后来被证明是错误的推测性工作，同时还需要用来自正确分支路径的指令来填充流水线。 通常，现代 CPU 会因分支预测错误而遭受 10-20 个周期的惩罚。</p>
<p>如今，处理器非常擅长预测分支结果，不仅可以遵循静态预测规则，还可以检测动态模式。通常，分支预测器会采用后者。</p>
<blockquote>
<p><strong>静态分支预测</strong>：由编译器决定哪个分支可能被 CPU命中，一般是第一个分支，即 if 后面的逻辑，而不是 else后面的逻辑</p>
<p><strong>动态分支预测</strong>：在运行期间决定预测结果。它会在 CPU硬件中开辟一块缓存，专门记录每个分支最近几次的命中情况，然后做出预测</p>
</blockquote>
<p>程序总是会遇到一些分支预测错误。通用应用程序的错误预测率在 5%-10% 的范围是正常的，如果该指标高于 10% 就要引起注意了。为了摆脱分支预测错误，最直接的方法就是摆脱分支本身。接下来就介绍两种摆脱分支的方式。</p>
<h2 id="1-用查找表替换分支"><a class="markdownIt-Anchor" href="#1-用查找表替换分支"></a> 1. 用查找表替换分支</h2>
<p>通过查找表可以避免频繁的分支。</p>
<p>先看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// baseline version</span></span><br><span class="line">int <span class="title function_">mapToBucket</span>(<span class="params">unsigned v</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v &gt;= <span class="number">0</span> &amp;&amp; v &lt; <span class="number">10</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (v &gt;= <span class="number">10</span> &amp;&amp; v &lt; <span class="number">20</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (v &gt;= <span class="number">20</span> &amp;&amp; v &lt; <span class="number">30</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (v &gt;= <span class="number">30</span> &amp;&amp; v &lt; <span class="number">40</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (v &gt;= <span class="number">40</span> &amp;&amp; v &lt; <span class="number">50</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数 mapToBucket 将 v 映射到相应的桶中。在基础版本中，我们会看到许多分支，这些分支可能具有很高的错误预测率。</p>
<p>我们可以使用单个数组查找来重写函数，这样函数的汇编代码应该只有一个分支而不是多个分支。此外，buckets 数组相对较小，因此我们可以期望它驻留在 CPU 缓存中，从而能够对其进行快速访问。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lookup version</span></span><br><span class="line">int buckets[<span class="number">256</span>] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>,</span><br><span class="line">    <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>,</span><br><span class="line">    <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>,</span><br><span class="line">    -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>,</span><br><span class="line">    -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>,</span><br><span class="line">    ... &#125;;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">mapToBucket</span>(<span class="params">unsigned v</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v &lt; (sizeof (buckets) / sizeof (int)))</span><br><span class="line">    	<span class="keyword">return</span> buckets[v];</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们需要映射更大范围的值，分配一个非常大的数组是不切实际的。在这种情况下，可以使用 interval map 数据结构，以使用更少的内存和对数级的查找复杂度来实现该目标。</p>
<h2 id="2-用谓词替换分支"><a class="markdownIt-Anchor" href="#2-用谓词替换分支"></a> 2. 用谓词替换分支</h2>
<p>通过执行分支的两个部分，然后选择正确的结果，可以有效地消除一些分支。 如果 if 分支有非常多的错误预测，可以尝试通过这种方式来消除分支。</p>
<p>看个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// baseline version</span></span><br><span class="line">int a;</span><br><span class="line"><span class="keyword">if</span> (cond) &#123; <span class="comment">// branch has high misprediction rate</span></span><br><span class="line">    a = <span class="title function_">computeX</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    a = <span class="title function_">computeY</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># assembly code</span><br><span class="line"><span class="number">400504</span>: test edi,edi</span><br><span class="line"><span class="number">400506</span>: je <span class="number">400514</span> 		# branch on cond</span><br><span class="line"><span class="number">400508</span>: mov eax,<span class="number">0x0</span></span><br><span class="line">40050<span class="attr">d</span>: call &lt;computeX&gt;</span><br><span class="line"><span class="number">400512</span>: jmp 40051e</span><br><span class="line"><span class="number">400514</span>: mov eax,<span class="number">0x0</span></span><br><span class="line"><span class="number">400519</span>: call &lt;computeY&gt;</span><br><span class="line">40051<span class="attr">e</span>: mov edi,eax</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// branchless version</span></span><br><span class="line">int x = <span class="title function_">computeX</span>();</span><br><span class="line">int y = <span class="title function_">computeY</span>();</span><br><span class="line">int a = cond ? x : y;</span><br><span class="line"></span><br><span class="line"># assembly code</span><br><span class="line"><span class="number">400537</span>: mov eax,<span class="number">0x0</span></span><br><span class="line">40053<span class="attr">c</span>: call &lt;computeX&gt; # compute x</span><br><span class="line"><span class="number">400541</span>: mov ebp,eax 	# assign x to a</span><br><span class="line"><span class="number">400543</span>: mov eax,<span class="number">0x0</span></span><br><span class="line"><span class="number">400548</span>: call &lt;computeY&gt; # compute y</span><br><span class="line">40054<span class="attr">d</span>: test ebx,ebx 	# test cond</span><br><span class="line">40054<span class="attr">f</span>: cmovne eax,ebp 	# override a <span class="keyword">with</span> y <span class="keyword">if</span> needed</span><br></pre></td></tr></table></figure>
<p>在无分支版本中，编译器能够去除分支并生成 <code>CMOV</code> 指令来替代：</p>
<p>不过要注意的是，在无分支版本中，X 和 Y 都是独立计算的，然后只选择其中一个值。虽然这种转换消除了分支错误预测的惩罚，但它会比原始代码做更多的工作。在这种情况下，性能改进在很大程度上取决于计算 X 和 Y 函数的特性。如果函数很小并且编译器能够内联它们，它可能会带来显著的性能优势；但如果函数很大，两个函数都去执行的开销要比分支预测错误的开销更大。</p>
<p>此外，消除分支还会限制 CPU 的并行执行能力。对于基础版本中的代码片段，CPU 可以选择 if 条件的 true 分支，并使用 <code>a = computeX()</code> 来推测执行。如果后续有指令要使用 a 来索引数组元素，那在我们在知道 if 分支的真实结果之前就可以发出此加载。而对于无分支版本中的代码，这种推测是不可能的，因为 CPU 无法在 <code>CMOVNE</code> 指令完成之前发出使用 a 的加载。</p>
<p>在代码的基础版本和无分支版本之间进行权衡的典型示例是二分查找：</p>
<ul>
<li>
<p>对于不适合 CPU 缓存的大型数组的查找，基于分支的二分查找版本的性能更好。因为与内存访问的延迟（缓存未命中会导致较高的延迟）相比，分支预测错误的代价较低。由于存在分支，CPU 可以推测它们的结果，从而同时加载当前迭代和下一次迭代中的数组元素。</p>
</li>
<li>
<p>对于适合 CPU 缓存的小型数组的查找，情况正好相反。由于数组适合 CPU 缓存，因此加载延迟很小（只有几个周期）。而基于分支的二分查找可能会遭受持续的错误预测，惩罚约为 20 个周期。在这种情况下，错误预测的代价远远大于内存访问的代价，从而大大削弱了推测执行的优势。在这种情况下，无分支版本通常会更快。</p>
</li>
</ul>
<p>二分查找是一个很好的例子，说明了如何在基础版本和无分支版本之间进行选择。但现实情况可能很难分析，因此，需要通过测试来确定在特定场景中替换分支是否有益。</p>
<h2 id="3-小结"><a class="markdownIt-Anchor" href="#3-小结"></a> 3. 小结</h2>
<ul>
<li>现代处理器非常擅长预测分支结果。因此，建议仅在错误预测率较高时再去修复分支错误预测的工作。</li>
<li>当 CPU 分支预测错误率较高时，应用程序的性能可能会受到影响。在这种情况下，算法的无分支版本可能会更好，因此可以考虑通过查找表和谓词来替换分支。</li>
<li>无分支算法并非总是有益的，要通过测试来确定在特定场景下的有效性。</li>
</ul>
<blockquote>
<p>以上内容参考自『Performance Analysis and Tuning on Modern CPUs』</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>分支预测 分支替换</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU微架构</title>
    <url>/posts/2175313746.html</url>
    <content><![CDATA[<p>简单总结一下影响软件性能的关键 CPU 架构和微架构特征。有些内容过于基础，我会只介绍重点。</p>
<h2 id="1-指令集架构isa"><a class="markdownIt-Anchor" href="#1-指令集架构isa"></a> 1. 指令集架构（ISA）</h2>
<ul>
<li>指令集：一系列指令的集合，用来实现软件与硬件之间的通信。</li>
<li>指令集架构：就是在指令集的基础上增加了一些规范，比如指令的编码规范、长度规范、操作数规范等等。</li>
</ul>
<p>部署最广泛的 ISA 有 Intel x86、ARM v8、RISC-V 等都是 64 位架构，ISA 开发人员通常确保符合规范的软件或固件将在使用该规范构建的任何处理器上执行，广泛部署的 ISA 通常还确保向后兼容性。</p>
<p>研究表明，使用更少的位表示变量能够节省计算和内存带宽。 因此，除了传统的 32 位和 64 位格式的数据类型之外，一些 CPU franchises 最近增加了对低精度数据类型的支持，例如 8 位整数（int8，例如 Intel VNNI）、ISA 中的 16 位浮点数（fp16、bf16） 。</p>
<h2 id="2-流水线"><a class="markdownIt-Anchor" href="#2-流水线"></a> 2. 流水线</h2>
<p>流水线是用于提高 CPU 速度的基础技术，其中多条指令在执行过程中重叠。最常见的流水线划分：</p>
<ul>
<li>
<p>Instruction fetch (IF)</p>
</li>
<li>
<p>Instruction decode (ID)</p>
</li>
<li>
<p>Execute (EXE)</p>
</li>
<li>
<p>Memory access (MEM)</p>
</li>
<li>
<p>Write back (WB)</p>
</li>
</ul>
<p>流水线 CPU 的 <strong>吞吐量</strong> ：单位时间内完成并退出流水线的指令数。</p>
<p>在理想的流水线中， <strong>每条指令的执行时间 = 非流水线机器上每条指令的时间 / 流水线深度​</strong></p>
<p>但在实际实现中，会有各类冒险导致流水线导致停顿，主要有三类：结构冒险、数据冒险和控制冒险。</p>
<ul>
<li>
<p><strong>结构冒险</strong>。是由对硬件资源的争用引起的。比如在只有一个取指部件的流水线中，指令在取指阶段阻塞，那后面指令就只能阻塞在取指阶段。</p>
</li>
<li>
<p><strong>数据冒险</strong>。由数据依赖引起的，有三种类型：</p>
<ul>
<li>
<p>RAW（解决：在 EXE 之后增加旁路）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">R1</span> = <span class="variable constant_">R0</span> <span class="variable constant_">ADD</span> <span class="number">1</span></span><br><span class="line"><span class="variable constant_">R2</span> = <span class="variable constant_">R1</span> <span class="variable constant_">ADD</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>WAR（不是真正的依赖，可以通过寄存器重命名技术来消除）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">R1</span> = <span class="variable constant_">R0</span> <span class="variable constant_">ADD</span> <span class="number">1</span></span><br><span class="line"><span class="variable constant_">R0</span> = <span class="variable constant_">R2</span> <span class="variable constant_">ADD</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>WAW（也不是真正的依赖，可以通过寄存器重命名技术来消除）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">R1</span> = <span class="variable constant_">R0</span> <span class="variable constant_">ADD</span> <span class="number">1</span></span><br><span class="line"><span class="variable constant_">R1</span> = <span class="variable constant_">R2</span> <span class="variable constant_">ADD</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>控制冒险</strong>。就是一条指令的执行取决于另一条条件指令的执行结果（解决：动态分支预测、推测执行）</p>
</li>
</ul>
<h2 id="3-指令级并行ilp"><a class="markdownIt-Anchor" href="#3-指令级并行ilp"></a> 3. 指令级并行（ILP）</h2>
<p>程序中的大多数指令都适合流水线化和并行执行，因为它们是独立的。现代 CPU 实现了大量附加硬件功能，以利用这种指令级并行来提高性能。对于指令级并行，有以下几种技术：</p>
<h3 id="1-乱序执行"><a class="markdownIt-Anchor" href="#1-乱序执行"></a> 1) 乱序执行</h3>
<p>指令可以任意顺序进入流水线，仅受其依赖项的限制，并且必须给出与指令顺序执行相同的结果。</p>
<p>引入乱序执行主要是为了避免因依赖项导致的停顿而不能充分利用CPU。</p>
<p><strong>retired</strong>：一条指令最终执行完毕的阶段。为了确保正确性，CPU必须按程序顺序 retire 所有指令，具体实现方式就是通过 ROB。ROB 是一个先进先出的队列，所有指令在译码结束后按照原始顺序进入ROB，里面的指令依然可以乱序执行，但必须从队头开始提交，从而维护了所有指令执行的状态并按顺序退出指令。</p>
<h3 id="2-超标量技术"><a class="markdownIt-Anchor" href="#2-超标量技术"></a> 2) 超标量技术</h3>
<p>大多数现代 CPU 都是超标量的，它们可以在单个周期内发出多条指令。</p>
<p><strong>发射宽度</strong>（Issue-width）是在同一周期内可以发出的最大指令数，当代 CPU 的发射宽度通常在 2 - 6。</p>
<p>通过超标量 + 深度流水线 + 乱序执行，能够使指令级并行程度最大化。</p>
<h3 id="3-推测执行"><a class="markdownIt-Anchor" href="#3-推测执行"></a> 3) 推测执行</h3>
<p>使用硬件来预测分支的可能方向并允许从预测路径执行指令。预测结果是不会被立即提交的，直到确定该推测是正确的，这样可以节省很多周期。而当预测错误时，执行结果会被丢弃。</p>
<p>预测结果不会立即提交，那应该存放在哪里呢？它总不能一直停留在流水线上，这样会阻塞后续指令的执行。其实它也会放在 ROB 里面。</p>
<h2 id="4-线程级并行"><a class="markdownIt-Anchor" href="#4-线程级并行"></a> 4. 线程级并行</h2>
<p>在多核 CPU中，线程级并行就是多个线程同时执行；而在单核 CPU 中，线程级并行实际上是线程的并发执行。</p>
<p>硬件多线程 CPU 能够跟踪每个线程的上下文，从而当一个线程被阻塞时，以 <strong>最小的延迟</strong> 切换到另一个上下文。而如果是单线程发生阻塞，CPU 需要先保存该线程的上下文，再去调度和恢复另一个线程的上下文来执行，所以多线程的优势就体现在它能跟踪多个线程的上下文并以最小的延迟在线程之间进行切换。</p>
<p>这里介绍一种线程级并行技术：<strong>同步多线程（SMT）</strong>，它能够在一个时钟周期内执行来自多个线程的指令。</p>
<p>同步多线程为什么会存在呢？或者说，在一个时钟周期内就执行一个线程的指令不好吗？为什么要执行多个线程的指令？</p>
<p>这是因为任何单个应用程序都不能完全使处理器达到满负荷状态。当一个线程遇到较长时间的等待事件时，同步多线程允许另一个线程中的指令使用这些执行单元。比如当一个线程发生 cache 不命中时，另一个线程是可以继续执行的。这样的话，对于一个单核 CPU，在逻辑上是不是就拥有了两个核？到这里大家估计也想到了，这不就是 <strong>超线程</strong> 吗？是的，它们确实是一回事儿，超线程是 Intel 的一个营销名称。</p>
<h2 id="5-内存层次结构"><a class="markdownIt-Anchor" href="#5-内存层次结构"></a> 5. 内存层次结构</h2>
<p>CPU 内存层次结构建立在两个基本属性上：时间局部性和空间局部性。</p>
<p>时间局部性即访问过的数据在不久的将来很可能会被再次访问，所以对于频繁访问的数据我们希望它离CPU足够近，也就是内存金字塔的上层，因为它们的性能更好。</p>
<p>空间局部性即所访问数据的附近位置不久的将来很可能会被再次访问，所以当程序需要读取单个字节时，我们通常会把一个更大的块缓存上来。</p>
<p>简单介绍一下其中的 <strong>缓存层次结构</strong>，即 L1、L2、L3，各级缓存都由以下四个属性定义：</p>
<h3 id="1-数据放置"><a class="markdownIt-Anchor" href="#1-数据放置"></a> 1) 数据放置</h3>
<ul>
<li>直接映射：一个数据块只能放在缓存中的一个位置。</li>
<li>全相连：一个块能放在缓存中的任意位置。</li>
<li>多路组相连：一个块能放在其映射组中的任意位置。</li>
</ul>
<h3 id="2-数据查找"><a class="markdownIt-Anchor" href="#2-数据查找"></a> 2) 数据查找</h3>
<p>先计算出数据所在的组，然后匹配块中的标签位、有效位等进行查找。具体计算方式这里不做详细介绍。</p>
<h3 id="3-失效管理"><a class="markdownIt-Anchor" href="#3-失效管理"></a> 3) 失效管理</h3>
<p>缓存不命中时，要在高速缓存中替换一个块来分配导致未命中的地址。对于直接映射，由于新地址只能分配在单个位置，因此映射到该位置的先前条目被释放，然后放置新条目。若是其他情况，则需要替换算法。典型替换算法是 LRU 或者随机替换。大多数 CPU 在硬件中定义这些功能。</p>
<h3 id="4-写管理"><a class="markdownIt-Anchor" href="#4-写管理"></a> 4) 写管理</h3>
<ul>
<li>写命中
<ul>
<li>直写：命中数据写到缓存块与下一级。</li>
<li>写回：命中数据只写到缓存块中，并标记位脏数据，当逐出时再写到下一级。</li>
</ul>
</li>
<li>写失效
<ul>
<li>写分配：先缓存到 cache 中再进行写入。</li>
<li>写不分配：不缓存到 cache，直接写入。</li>
</ul>
</li>
</ul>
<h2 id="6-虚拟内存"><a class="markdownIt-Anchor" href="#6-虚拟内存"></a> 6. 虚拟内存</h2>
<p>虚拟地址到物理地址的转换：（为了减少地址转换时间，会引入 TLB）</p>
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://wx3.sinaimg.cn/mw690/006ept9Hgy1gs9mf8nexpj30n10d5dgq.jpg" alt="虚实地址转换" style="zoom:70%;" />
<h2 id="7-simd多处理器"><a class="markdownIt-Anchor" href="#7-simd多处理器"></a> 7. SIMD多处理器</h2>
<p>在一个周期内，单条指令能够同时对多个数据元素进行操作。</p>
<p>大多数流行的 CPU 架构都具有向量指令，包括 x86、PowerPC、ARM 和 RISC-V。 1996 年，Intel 发布了新的指令集 <code>MMX</code>，这是专为多媒体应用程序设计的 SIMD 指令集。继 MMX 之后，英特尔推出了具有更多功能和更大向量大小的新指令集：<code>SSE</code>、<code>AVX</code>、<code>AVX2</code>、<code>AVX512</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">double *a, *b, *c;</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">	c[i] = a[i] + b[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上述代码，在 SISD 处理器中，每个周期只会处理一个数据，如左图所示。而 SIMD 多处理器会同时处理多个数据，如右图，<code>SSE</code> 每个周期能处理两个数据，而 <code>AVX-512</code> 的处理能力达到了 8 个 / 周期。</p>
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://wx3.sinaimg.cn/mw690/006ept9Hgy1gs9mgjef02j30sm0h2gnw.jpg" alt="SIMD" style="zoom:70%;" />
<h2 id="8-现代cpu设计"><a class="markdownIt-Anchor" href="#8-现代cpu设计"></a> 8. 现代CPU设计</h2>
<p>2015 年，Intel 发布了第 6 代内核 Skylake 的详细信息，分为 <strong>前端</strong> 和 <strong>后端</strong>。</p>
<p>前端主要是从内存中高效地取指和译码，并将准备好的指令提供给 CPU 后端，后者负责指令的实际执行。</p>
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://wx2.sinaimg.cn/mw690/006ept9Hgy1gs9mgnag11j30on0hlwhm.jpg" alt="CPU前后端" style="zoom:90%;" />
<p>先简单看一下该架构的整体处理流程：</p>
<p>首先 CPU 从 L1 I-cache 中取指（若发生 miss 会向 L2 发送请求），指令会先经过传统流水线 <strong>Legacy Decode Pipeline</strong> 译码成微指令，并同时发送到 <strong>IDQ</strong>与 <strong>DSB</strong>。<strong>DSB</strong> 保存了指令地址到微指令的映射，这样当再次访问时就可以直接从该缓存中取 uop 而无需再次译码。一条复杂的指令会被译码为多条微指令，当微指令数量过多超出译码器的处理能力时，就会由 <strong>MSROM</strong> 来完成。<strong>BPU</strong> 是分支预测单元，会按预测的分支方向取指和译码。</p>
<p>此时 IDQ 中的微指令已经按顺序排列好了，下一步就会分配资源，如果微指令之间存在数据冒险还会有重命名等操作。当微指令所需资源就绪时，会由调度器发送到不同的端口执行。port-0 1 5 6 提供所有的整型、浮点型、向量的算术和逻辑运算，这些运算不需要访问内存；port-2 3用于地址的生成和加载操作，port-4 用于数据的存储操作，port-7 用于地址的生成操作。</p>
<p>接下来具体看一下 CPU 的前后端。</p>
<h3 id="1-cpu前端"><a class="markdownIt-Anchor" href="#1-cpu前端"></a> 1) CPU前端</h3>
<p>CPU前端从 L1I-cache 中每个周期获取 16 字节的 x86 指令，所以每个线程每隔一个周期就会获得 16 个字节，这会在两个线程之间共享。这些是复杂的可变长度x86指令。流水线的预译码和译码阶段将这些复杂的 x86 指令转换成微指令，这些微指令按顺序排队进入分配队列（IDQ）。</p>
<p>预译码主要是确定和标记可变指令的边界。因为在 x86 中，指令长度的范围可以从 1 字节到 15 字节。该阶段还会识别分支指令。</p>
<p>前端的一个主要性能提升部件是译码流式缓冲区 (DSB) ，它会缓存宏操作到微指令的转换。在取指期间，先检查 DSB 以查看 DSB 中是否已提供 UOP 转换。频繁发生的宏操作将在 DSB 中命中，从而提高执行效率。</p>
<p>一些非常复杂的指令可能需要更多的 UOP，这会超出译码器的处理能力，此类指令的 UOP 由微码排序器 (MSROM) 提供。</p>
<p>指令译码队列（IDQ）提供了前端与后端之间的接口。</p>
<h3 id="2-cpu后端"><a class="markdownIt-Anchor" href="#2-cpu后端"></a> 2) CPU后端</h3>
<p>CPU 后端使用乱序引擎来执行指令和存储结果，后端的核心是 ROB，能够始终按程序顺序 retire。</p>
<p>ROB 会维护所有指令执行的状态并按顺序退出指令。</p>
<p>保留站/调度器跟踪微指令所需资源的可用性，并在其准备就绪后分派到指定的端口。调度器的核心是 8 路超标量，因此每个周期最多可以调度 8 个微指令。每个调度端口支持不同的操作：</p>
<ul>
<li>端口 0、1、5 、6 提供所有整数、FP 和向量 ALU，分派到这些端口的微指令不需要内存操作。</li>
<li>端口 2 和 3 用于地址生成和加载操作。</li>
<li>端口 4 用于存储操作。</li>
<li>端口 7 用于地址生成。</li>
</ul>
<h2 id="9-性能检测单元pmu"><a class="markdownIt-Anchor" href="#9-性能检测单元pmu"></a> 9. 性能检测单元（PMU）</h2>
<p>现代 CPU 中都提供了性能检测方法，可以帮助开发人员分析应用程序的性能，这些方法由性能检测单元 (PMU) 提供。大多数 PMU 都有一组性能监控计数器 (PMC)，可用于收集程序执行期间发生的各种性能事件。</p>
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://wx3.sinaimg.cn/mw690/006ept9Hgy1gs9mgsllyzj30li0cz0u1.jpg" alt="PMC" style="zoom:50%;" />
<blockquote>
<p>以上内容参考自『Performance Analysis and Tuning on Modern CPUs』</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>CPU微架构 ISA 流水线 指令级并行 线程级并行 SIMD Skylake CPU前后端</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU性能分析中的术语和指标</title>
    <url>/posts/682752931.html</url>
    <content><![CDATA[<p>简单介绍一下 Linux 性能分析工具 <code>perf</code> 中所使用到的基本术语和指标。</p>
<h2 id="1-retired-vs-executed-instruction"><a class="markdownIt-Anchor" href="#1-retired-vs-executed-instruction"></a> 1. Retired vs. Executed Instruction</h2>
<p>现代处理器通常执行比程序流所需更多的指令，这主要是因为其中一些是推测执行的。</p>
<p>推测执行的结果不会被立即提交，当推测结果正确时，CPU 才会解除对它的阻塞并继续执行；而当推测错误的时，CPU 就会丢弃推测指令所做的所有更改，因此它们并不会正常 retire。</p>
<p>CPU 处理的指令可以 excuted 但不一定 retired。因此，我们通常可以推测 excuted 指令的数量高于 retired 指令的数量。</p>
<p><code>perf</code> 可以收集 retired 指令的数量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ perf stat -e instructions ./hello</span><br><span class="line">  <span class="number">4</span>,<span class="number">564</span>,<span class="number">863</span>		instructions</span><br></pre></td></tr></table></figure>
<h2 id="2-cpu利用率"><a class="markdownIt-Anchor" href="#2-cpu利用率"></a> 2. CPU利用率</h2>
<p>CPU 在某个时间段内的忙碌时间所占的比例。</p>
<p>如果 CPU 利用率低，通常意味着应用程序性能不佳。但是高 CPU 利用率也未必总是好事。这只能表明系统正在做一些工作，但并不知道它具体在做什么。在多线程上下文中，线程也可以在等待资源处理时自旋。</p>
<p><code>perf</code> 可以计算 CPU 利用率：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ perf stat -e task-clock ./hello</span><br><span class="line">  <span class="number">1.867875</span>      task-clock (msec)	# <span class="number">0.878</span> <span class="title class_">CPUs</span> utilized</span><br></pre></td></tr></table></figure>
<h2 id="3-cpi-ipc"><a class="markdownIt-Anchor" href="#3-cpi-ipc"></a> 3. CPI &amp; IPC</h2>
<p>两个很重要的指标，可用于评估硬件和软件效率，二者互为倒数。</p>
<p>CPI 是每条指令到 retire 阶段所经历的周期，IPC 是每个时钟周期能够 retire 指令的数量。</p>
<p><code>perf</code> 可以计算 IPC：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ perf stat -e cycles,instructions ./hello</span><br><span class="line">  <span class="number">4</span>,<span class="number">460</span>,<span class="number">351</span>      cycles                                                      </span><br><span class="line">  <span class="number">4</span>,<span class="number">531</span>,<span class="number">686</span>      instructions		# <span class="number">1.02</span>  insn per cycle</span><br></pre></td></tr></table></figure>
<h2 id="4-uopsmicro-ops"><a class="markdownIt-Anchor" href="#4-uopsmicro-ops"></a> 4. UOPs（micro-ops）</h2>
<p>具有 x86 架构的微处理器将复杂的 CISC-like 指令转换为简单的 RISC-like 微指令（缩写为 µops 或 uops）。 这样做的主要优点是可以乱序执行 µops。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>| 	<span class="variable constant_">ADD</span>		<span class="variable constant_">EAX</span>, <span class="variable constant_">EBX</span></span><br><span class="line"><span class="number">2</span>| 	<span class="variable constant_">ADD</span>		<span class="variable constant_">EAX</span>, [<span class="title class_">MEM1</span>]</span><br><span class="line"><span class="number">3</span>| 	<span class="variable constant_">ADD</span> 	[<span class="title class_">MEM1</span>], <span class="variable constant_">EAX</span></span><br></pre></td></tr></table></figure>
<p>在上述代码示例中：</p>
<p>第一条加法指令只能产生一个微指令；</p>
<p>第二条加法指令会产生两个微指令：一个用于从内存读取数据到临时寄存器，另一个用于将临时寄存器中的内容加到 EAX 寄存器。</p>
<p>第三条加法指令会产生三个微指令：一个用于从内存中读取数据到临时寄存器，一个将 EAX 寄存器中的内容加到临时寄存器，还有一个用于将结果写回内存。</p>
<p>指令之间的关系及其拆分为微指令的方式 CPU 而异。</p>
<p>除了将复杂的 CISC-like 指令拆分成 RISC-like 微指令外，微指令还可以融合。现代 Intel CPU 有两种类型的融合：</p>
<ul>
<li>
<p>微融合：融合的微指令来自相同的机器指令。微融合只能应用于两种类型的组合：内存写操作 和 读-修改操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># <span class="title class_">Read</span> the memory location [<span class="variable constant_">ESI</span>] and add it to <span class="variable constant_">EAX</span></span><br><span class="line"># <span class="title class_">Two</span> uops are fused into one at the decoding step.</span><br><span class="line">add eax, [esi]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>宏融合：融合的微指令来自不同的机器指令。在某些情况下，译码器可以将算术或逻辑指令与后续条件跳转指令融合为单个计算和分支微指令。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># <span class="title class_">Two</span> uops <span class="keyword">from</span> <span class="variable constant_">DEC</span> and <span class="variable constant_">JNZ</span> instructions are fused into one</span><br><span class="line">.<span class="property">loop</span>:</span><br><span class="line">	dec rdi</span><br><span class="line">	jnz .<span class="property">loop</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>融合操作节省了从 decode 到 retire 的流水线所有阶段的带宽。</p>
<p>融合以后会共用 ROB 中的一个条目，这样 ROB 的容量就增加了。当两个微指令融合为一个之后，虽然共用同一个 ROB 条目，可还是需要由两个不同的执行单元来完成两个操作。融合条目会被分派到两个不同的执行端口，但最终还是作为一个单元 retire。</p>
<p><code>perf</code> 可以计算 issued, executed, 和 retired 微指令的数量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ perf stat -e uops_issued.<span class="property">any</span>,uops_executed.<span class="property">thread</span>,uops_retired.<span class="property">all</span> ./test</span><br><span class="line">  <span class="number">2856278</span> uops_issued.<span class="property">any</span></span><br><span class="line">  <span class="number">2720241</span> uops_executed.<span class="property">thread</span></span><br><span class="line">  <span class="number">2557884</span> uops_retired.<span class="property">all</span></span><br></pre></td></tr></table></figure>
<h2 id="5-流水线槽"><a class="markdownIt-Anchor" href="#5-流水线槽"></a> 5. 流水线槽</h2>
<p>处理一个微指令所需的硬件资源。</p>
<p>下图展示了一个 CPU 的执行流水线，它每个周期可以处理 4 个 uops。在图中的六个连续周期中，只有一半的可用插槽被利用。从微架构的角度来看，它的执行效率只有 50%.</p>
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://wx4.sinaimg.cn/mw690/006ept9Hgy1gs9ndly8dej30i60cxdjf.jpg" alt="slot" style="zoom:50%;" />
<h2 id="6-内核周期和参考周期"><a class="markdownIt-Anchor" href="#6-内核周期和参考周期"></a> 6. 内核周期和参考周期</h2>
<p>大多数现代 CPU，包括 Intel 和 AMD CPU，都没有固定的运行频率，而是实现了 <strong>动态频率缩放</strong>。在英特尔的 CPU 中，这项技术称为 Turbo Boost，在 AMD 的处理器中称为 Turbo Core。它允许 CPU 动态地增加和降低其频率：<strong>减小频率降低了功耗但牺牲了性能，增加频率提高了性能但牺牲了功耗</strong>。</p>
<p><strong>内核周期</strong> 是以 CPU 内核运行的实际时钟频率计算出的时钟周期，而 <strong>参考周期</strong> 直接统计外部时钟周期，不考虑动态频率的缩放。</p>
<h2 id="7-缓存失效"><a class="markdownIt-Anchor" href="#7-缓存失效"></a> 7. 缓存失效</h2>
<p>根据<a href="https://younghblog.github.io/2021/07/03/CPU%E5%BE%AE%E6%9E%B6%E6%9E%84.html">上一篇博客</a>中自顶向下的微架构分析，指令缓存未命中会导致前端停顿，因此被归为前端问题，而数据缓存未命中会导致后端停顿，因此被归为后端问题。</p>
<p>缓存的命中与失效此时都可以通过 <code>perf</code>工具统计出来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ perf stat -e mem_load_retired.<span class="property">fb_hit</span>,mem_load_retired.<span class="property">l1_miss</span>,</span><br><span class="line">  mem_load_retired.<span class="property">l1_hit</span>,mem_inst_retired.<span class="property">all_loads</span> ./test</span><br><span class="line">  <span class="number">29580</span> mem_load_retired.<span class="property">fb_hit</span></span><br><span class="line">  <span class="number">19036</span> mem_load_retired.<span class="property">l1_miss</span></span><br><span class="line">  <span class="number">497204</span> mem_load_retired.<span class="property">l1_hit</span></span><br><span class="line">  <span class="number">546230</span> mem_inst_retired.<span class="property">all_loads</span></span><br></pre></td></tr></table></figure>
<h2 id="8-分支预测错误"><a class="markdownIt-Anchor" href="#8-分支预测错误"></a> 8. 分支预测错误</h2>
<p>分支错误预测时，CPU 需要撤销它最近所做的所有推测工作，这通常会涉及 10 到 20 个时钟周期的惩罚。</p>
<p><code>perf</code> 可以查看分支预测错误次数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ perf stat -e branches,branch-misses ./test</span><br><span class="line">  <span class="number">358209</span> branches</span><br><span class="line">  <span class="number">14026</span> branch-misses # <span class="number">3</span>,<span class="number">92</span>% <span class="keyword">of</span> all branches</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上内容参考自『Performance Analysis and Tuning on Modern CPUs』</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>perf IPC 微指令融合 slot 动态频率缩放</tag>
      </tags>
  </entry>
  <entry>
    <title>LRU缓存机制</title>
    <url>/posts/2357652358.html</url>
    <content><![CDATA[<p>这是 <a href="https://leetcode-cn.com/problems/lru-cache/">LeetCode 第 146 题</a> 。</p>
<blockquote>
<p><strong>题目描述</strong>：运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。</p>
<p>实现 LRUCache 类：</p>
<ul>
<li>LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存</li>
<li>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</li>
<li>void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li>
</ul>
<p><strong>进阶</strong>：你是否可以在 <code>O(1)</code> 时间复杂度内完成这两种操作？</p>
<p><strong>示例</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[<span class="string">&quot;LRUCache&quot;</span>,<span class="string">&quot;put&quot;</span>,<span class="string">&quot;put&quot;</span>,<span class="string">&quot;get&quot;</span>,<span class="string">&quot;put&quot;</span>,<span class="string">&quot;get&quot;</span>,<span class="string">&quot;put&quot;</span>,<span class="string">&quot;get&quot;</span>,<span class="string">&quot;get&quot;</span>,<span class="string">&quot;get&quot;</span>]</span><br><span class="line">[[<span class="number">2</span>], [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">1</span>], [<span class="number">3</span>, <span class="number">3</span>], [<span class="number">2</span>], [<span class="number">4</span>, <span class="number">4</span>], [<span class="number">1</span>], [<span class="number">3</span>], [<span class="number">4</span>]]</span><br><span class="line">输出:</span><br><span class="line">[<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">1</span>, <span class="literal">null</span>, -<span class="number">1</span>, <span class="literal">null</span>, -<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line"><span class="title class_">LRUCache</span> lRUCache = <span class="keyword">new</span> <span class="title class_">LRUCache</span>(<span class="number">2</span>);</span><br><span class="line">lRUCache.<span class="title function_">put</span>(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 缓存是 &#123;1=1&#125;</span></span><br><span class="line">lRUCache.<span class="title function_">put</span>(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// 缓存是 &#123;1=1, 2=2&#125;</span></span><br><span class="line">lRUCache.<span class="title function_">get</span>(<span class="number">1</span>);    <span class="comment">// 返回 1</span></span><br><span class="line">lRUCache.<span class="title function_">put</span>(<span class="number">3</span>, <span class="number">3</span>); <span class="comment">// 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span></span><br><span class="line">lRUCache.<span class="title function_">get</span>(<span class="number">2</span>);    <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">lRUCache.<span class="title function_">put</span>(<span class="number">4</span>, <span class="number">4</span>); <span class="comment">// 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span></span><br><span class="line">lRUCache.<span class="title function_">get</span>(<span class="number">1</span>);    <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">lRUCache.<span class="title function_">get</span>(<span class="number">3</span>);    <span class="comment">// 返回 3</span></span><br><span class="line">lRUCache.<span class="title function_">get</span>(<span class="number">4</span>);    <span class="comment">// 返回 4</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<ul>
<li>要在 O(1) 时间复杂度内实现关键字的查找以及修改工作，必须使用 map。</li>
<li>当容量达到上限时需要删除最久未使用的元素，因此每访问一个元素就应该将其放到一端，表示最近被访问的位置，并将当前位置删除；而每次删除从另一端开始，表示最久未使用元素。</li>
<li>这里涉及到头部和尾部数据的维护以及中间数据的删除，要在 O(1) 的时间复杂度内完成，就需要用到循环队列 list。双端队列 deque 虽然也能够维护头部和尾部数据，但其中间元素的插入和删除还是需要移动数据的。</li>
<li>map 支持快速查找但不支持头部尾部数据的维护和中间数据的删除，而 list 正好相反，二者可以结合使用，各取所长。</li>
</ul>
<p>接下来要考虑的就是怎么结合的问题。</p>
<p>可以将 map 作为索引表，将 list 作为实际操作的对象。因此需要在 map 中保存 key 值以及对应在 list 中节点的位置，而在 list 中如果只保存 map 中的 key 所对应的 value 显然是不行的，因为对 list 操作的同时需要维护其索引表 map，比如要删除某个节点，那 map 中对应的 key 也应该删除，或者要移动某个节点，map 中对应的指向 list 节点的位置也要更新。而此时只有一个 map 指向 list 的指针，必须再维护一个 list 指向 map 的指针，只需在 list 中多保存一个 key 即可，因为 key 在 map 中是唯一字段，因此可以定位到 map。</p>
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://wx4.sinaimg.cn/mw690/006ept9Hgy1gttyla4fwoj30jr07maar.jpg" alt="LRU"/>
<h2 id="c代码"><a class="markdownIt-Anchor" href="#c代码"></a> C++代码</h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="attr">private</span>:</span><br><span class="line">    int _capacity;</span><br><span class="line">    list&lt;pair&lt;int, int&gt;&gt; _list;</span><br><span class="line">    unordered_map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt; _map;</span><br><span class="line">    </span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    <span class="title class_">LRUCache</span>(int capacity) &#123;</span><br><span class="line">        _capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int <span class="title function_">get</span>(<span class="params">int key</span>) &#123;</span><br><span class="line">        auto pos = _map.<span class="title function_">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(pos == _map.<span class="title function_">end</span>())  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将_list中pos-&gt;second位置的节点剪切到_list的最前端</span></span><br><span class="line">        _list.<span class="title function_">splice</span>(_list.<span class="title function_">begin</span>(), _list, pos-&gt;second);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// pos-&gt;second即为_map的value，它是指向_list中某个节点的迭代器</span></span><br><span class="line">        <span class="comment">// _list节点保存的是pair，所以再次-&gt;second即为pair所对应的value</span></span><br><span class="line">        <span class="keyword">return</span> pos-&gt;second-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">put</span>(<span class="params">int key, int value</span>) &#123;</span><br><span class="line">        auto pos = _map.<span class="title function_">find</span>(key);</span><br><span class="line">        <span class="comment">// 如果存在，更新_list并将其剪切到最前面</span></span><br><span class="line">        <span class="keyword">if</span>(pos != _map.<span class="title function_">end</span>()) &#123;</span><br><span class="line">            pos-&gt;second-&gt;second = value;</span><br><span class="line">            _list.<span class="title function_">splice</span>(_list.<span class="title function_">begin</span>(), _list, pos-&gt;second);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(_list.<span class="title function_">size</span>() == _capacity) &#123;</span><br><span class="line">            <span class="comment">// _map中erase的形参既可以是迭代器，也可以是key值</span></span><br><span class="line">            _map.<span class="title function_">erase</span>(_list.<span class="title function_">back</span>().<span class="property">first</span>);</span><br><span class="line">            _list.<span class="title function_">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ls.<span class="title function_">emplace_front</span>(key, value);</span><br><span class="line">        _map[key] = _list.<span class="title function_">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeeCode</category>
      </categories>
      <tags>
        <tag>LRU</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU 缓存一致性问题</title>
    <url>/posts/2452518558.html</url>
    <content><![CDATA[<p>当 CPU 中的某个核要对内存中的数据进行修改时，会先将其缓存到 cache 中，然后再去修改。此时由于修改后的数据尚未写回到内存，如果其他核要去访问这个数据，就会读到修改之前的数据，这就是 <strong>缓存一致性问题</strong>。对此问题有两种解决方式：</p>
<h3 id="1对总线加锁"><a class="markdownIt-Anchor" href="#1对总线加锁"></a> 1）对总线加锁</h3>
<p>CPU 和其他组件都是通过总线（数据总线、控制总线、地址总线）进行通信的，因此通过对总线加锁就可以保证只有一个核获取到锁，而其他核都处于阻塞状态。这样虽然保证了数据的一致性，但也严重影响了 CPU 的执行效率。</p>
<h3 id="2使用缓存一致性协议-mesi"><a class="markdownIt-Anchor" href="#2使用缓存一致性协议-mesi"></a> 2）使用缓存一致性协议 MESI</h3>
<p>它只对单个缓存行加锁，因此不会影响到内存中其他数据的读写，这样就保证了执行效率。</p>
<p>MESI 每个字母对应一种状态：</p>
<table>
<thead>
<tr>
<th style="text-align:center">状态</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">M（Modified）</td>
<td style="text-align:center">修改</td>
<td style="text-align:center">缓存行中的数据已被修改，与内存中的数据不一致，并且该数据只存在于本地 cache 中（即只存在于当前核的 cache 中）</td>
</tr>
<tr>
<td style="text-align:center">E（Exclusive）</td>
<td style="text-align:center">独享互斥</td>
<td style="text-align:center">缓存行中的数据与内存中的数据一致，并且该数据只存在于本地 cache 中</td>
</tr>
<tr>
<td style="text-align:center">S（Shared）</td>
<td style="text-align:center">共享</td>
<td style="text-align:center">缓存行中的数据与内存中的数据一致，并且该数据存在于多个 cache 中（即存在于多个核的 cache 中）</td>
</tr>
<tr>
<td style="text-align:center">I（Invalid）</td>
<td style="text-align:center">无效</td>
<td style="text-align:center">当前缓存行无效</td>
</tr>
</tbody>
</table>
<p>MESI 的状态转移过程：</p>
<table style="width:100%">
    <tr>
        <th align="center">当前<br/>状态</th> 
        <th align="center">事件</th> 
        <th align="center">行为</th> 
        <th align="center">下一个状态</th> 
   </tr>
    <tr>
        <td rowspan="5" align="center" style="font-size:50px; font-weight:bold">M</td>    
    </tr>
    <tr>
        <td align="center">local read</td>
        <td align="center">从 cache 中读，状态不变</td>
        <td align="center">M</td>
    </tr>
    <tr>
        <td align="center">local write</td>
        <td align="center">修改 cache 数据，状态不变</td>
        <td align="center">M</td>
    </tr>
    <tr>
        <td align="center">remote read</td>
        <td align="center">将数据写回内存，使其它核能够获取到最新数据，<br/>状态变为 S</td>
        <td align="center">S</td>    
    </tr>
    <tr>
        <td align="center">remote write</td>
        <td align="center">将数据写回内存，使其它核能够获取到最新数据，<br/>状态变为 I</td>
        <td align="center">I</td>    
    </tr>
    <tr>
        <td rowspan="5" align="center" style="font-size:50px; font-weight:bold">E</td>    
    </tr>
    <tr>
        <td align="center">local read</td>
        <td align="center">从 cache 中读，状态不变</td>
        <td align="center">E</td>
    </tr>
    <tr>
        <td align="center">local write</td>
        <td align="center">修改 cache 数据，状态变为 M</td>
        <td align="center">M</td>
    </tr>
    <tr>
        <td align="center">remote read</td>
        <td align="center">数据与其它核共享，状态变为 S</td>
        <td align="center">S</td>    
    </tr>
    <tr>
        <td align="center">remote write</td>
        <td align="center">数据被修改，状态变为 I</td>
        <td align="center">I</td>    
    </tr>
    <tr>
        <td rowspan="5" align="center" style="font-size:50px; font-weight:bold">S</td>    
    </tr>
    <tr>
        <td align="center">local read</td>
        <td align="center">从 cache 中读，状态不变</td>
        <td align="center">S</td>
    </tr>
    <tr>
        <td align="center">local write</td>
        <td align="center">先将其它核的状态变为 I，再将本地状态变为 M</td>
        <td align="center">M</td>
    </tr>
    <tr>
        <td align="center">remote read</td>
        <td align="center">数据与其它核共享，状态不变</td>
        <td align="center">S</td>    
    </tr>
    <tr>
        <td align="center">remote write</td>
        <td align="center">数据被修改，状态变为 I</td>
        <td align="center">I</td>    
    </tr>
    <tr>
        <td rowspan="9" align="center" style="font-size:50px; font-weight:bold">I</td>    
    </tr>
    <tr>
        <td rowspan="3" align="center">local read</td>
        <td align="center">若其它核中没有数据，则将内存中的数据缓存到本地 cache，状态变为 E</td>
        <td rowspan="3" align="center">E/S</td>
    </tr>
    <tr>
        <td align="center">若其它核中有数据，且状态为 M，则先将数据写回内存，然后将内存中的数据缓存到本地 cache，二者状态均变为 S</td>
    </tr>
    <tr>
        <td align="center">若其它核中有数据，且状态为 E 或 S，则将内存中的数据缓存到本地 cache，并将它们的状态均变为 S</td>
    </tr>
    <tr>
        <td rowspan="3" align="center">local write</td>
        <td align="center">若其它核中没有数据，则将内存中的数据缓存到本地 cache，状态变为 M</td>
        <td rowspan="3" align="center">M</td>
    </tr>
    <tr>
        <td align="center">若其它核中有数据，且状态为 M，则先将数据写回内存，状态变为 I，然后将内存中的数据缓存到本地 cache，状态变为 M</td>
    </tr>
    <tr>
        <td align="center">若其它核中有数据，且状态为 E 或 S，则将它们的状态变为 I，然后将内存中的数据缓存到本地 cache，状态变为 M</td>
    </tr>
    <tr>
        <td align="center">remote read</td>
        <td align="center">本地数据已失效，不受其它核操作的影响</td>
        <td align="center">I</td>    
    </tr>
    <tr>
        <td align="center">remote write</td>
        <td align="center">本地数据已失效，不受其它核操作的影响</td>
        <td align="center">I</td>    
    </tr>
</table>]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>MESI</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu16.0 下部署 Web项目（jdk + Tomcat + SQL Server）</title>
    <url>/posts/2510461242.html</url>
    <content><![CDATA[<h2 id="安装-jdk"><a class="markdownIt-Anchor" href="#安装-jdk"></a> 安装 jdk</h2>
<p>下载 jdk需要注意的两点：</p>
<ol>
<li><strong>要下载 Linux版本的 jdk</strong></li>
<li><strong>jdk的位数要与 ubuntu匹配</strong> （查看ubuntu位数的命令：<code>getconf LONG_BIT</code>）</li>
</ol>
<p>我下载的版本是：jdk-8u201-linux-x64.tar.gz</p>
<ul>
<li>将下好的安装包从 windows传到 Linux。</li>
</ul>
<p>我放在了  /usr/xg/java  目录下</p>
<p><img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190805183605142.png" alt="在这里插入图片描述" /></p>
<ul>
<li>
<p>进入此目录 <code>/usr/xg/java</code>，解压安装包 <code>tar xvf jdk-8u201-linux-x64.tar.gz</code></p>
</li>
<li>
<p>查看解压后的目录<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190805184412843.png" alt="在这里插入图片描述" /></p>
</li>
<li>
<p>配置环境变量 <code>/etc/profile</code>，在结尾处添加如下内容：</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">JAVA_HOME</span>=<span class="regexp">/usr/</span>xg/java/jdk1<span class="number">.8</span><span class="number">.0_201</span> </span><br><span class="line"><span class="variable constant_">PATH</span>=<span class="attr">$PATH</span>:$JAVA_HOME/bin</span><br><span class="line"><span class="variable constant_">CLASSPATH</span>=.:$JAVA_HOME/lib</span><br><span class="line"><span class="keyword">export</span> <span class="variable constant_">JAVA_HOME</span> <span class="variable constant_">PATH</span> <span class="variable constant_">CLASSPATH</span></span><br></pre></td></tr></table></figure>
<p>如图：<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190805185019343.png" alt="在这里插入图片描述" /></p>
<ul>
<li>重新加载 <code>source /etc/profile</code>，使其生效：<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/201908051856325.png" alt="在这里插入图片描述" /></li>
<li>检验是否安装成功<code>java -version</code><br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190805192216388.png" alt="在这里插入图片描述" /></li>
</ul>
<h2 id="安装-tomcat"><a class="markdownIt-Anchor" href="#安装-tomcat"></a> 安装 tomcat</h2>
<ul>
<li>同样需要下载 Linux版本的 tomcat，然后将下载好的压缩包放到 Linux相应的目录下。</li>
</ul>
<p>我下载的版本是：apache-tomcat-8.5.12.tar.gz<br />
放在了  /usr/xg/tomcat 目录下<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190805190705327.png" alt="在这里插入图片描述" /></p>
<ul>
<li>同样的，进入目录<code>../tomcat</code>并解压安装包<code>tar xvf apache-tomcat-8.5.12.tar.gz</code><br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190805191924122.png" alt="在这里插入图片描述" /></li>
<li>查看解压后的目录<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/2019080519242831.png" alt="在这里插入图片描述" /></li>
<li>配置环境变量 <code>/etc/profile</code>，在配置 jdk环境变量的基础上添加如下内容：<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190805192933446.png" alt="在这里插入图片描述" /></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">JAVA_HOME</span>=<span class="regexp">/usr/</span>xg/java/jdk1<span class="number">.8</span><span class="number">.0_201</span> </span><br><span class="line"><span class="variable constant_">CATALINA_HOME</span>=<span class="regexp">/usr/</span>xg/tomcat/apache-tomcat-<span class="number">8.5</span><span class="number">.12</span></span><br><span class="line"><span class="variable constant_">PATH</span>=<span class="attr">$PATH</span>:$JAVA_HOME/<span class="attr">bin</span>:$CATALINA_HOME/bin</span><br><span class="line"><span class="variable constant_">CLASSPATH</span>=.:$JAVA_HOME/<span class="attr">lib</span>:$CATALINA_HOME/lib</span><br><span class="line"><span class="keyword">export</span> <span class="variable constant_">JAVA_HOME</span> <span class="variable constant_">CATALINA_HOME</span> <span class="variable constant_">PATH</span> <span class="variable constant_">CLASSPATH</span></span><br></pre></td></tr></table></figure>
<ul>
<li>重新加载  <code>source /etc/profile</code>，使其生效：<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190805193125653.png" alt="在这里插入图片描述" /></li>
<li>进入 bin目录 <code>apache-tomcat-8.5.12/bin</code>，查看该目录下的文件<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/2019080519354791.png" alt="在这里插入图片描述" /></li>
<li>启动 tomcat <code>startup.sh</code><br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/2019080519371567.png" alt="在这里插入图片描述" /><br />
启动成功！</li>
</ul>
<p>为了避免每次都要进入 bin目录才能进行启动，这里将其 <strong>设置为系统服务</strong>：</p>
<ul>
<li>
<p>首先进行文件的复制：<code>cp catalina.sh /etc/init.d/tomcat</code></p>
</li>
<li>
<p>然后对复制后的文件进行编辑 <code>/etc/init.d/tomcat</code>，添加以下内容：</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">JAVA_HOME</span>=<span class="regexp">/usr/</span>xg/java/jdk1<span class="number">.8</span><span class="number">.0_201</span> </span><br><span class="line"><span class="variable constant_">CATALINA_HOME</span>=<span class="regexp">/usr/</span>xg/tomcat/apache-tomcat-<span class="number">8.5</span><span class="number">.12</span></span><br></pre></td></tr></table></figure>
<p>如图：<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190805195346687.png" alt="在这里插入图片描述" /></p>
<ul>
<li>
<p>添加 tomcat服务：<br />
<code>apt-get update</code><br />
<code>apt-get install sysv-rc-conf</code><br />
<code>sysv-rc-conf tomcat on</code></p>
</li>
<li>
<p>然后就可以通过以下方式启动 / 关闭Tomcat了：</p>
</li>
</ul>
<p>启动 Tomcat：<code>service tomcat start</code><br />
关闭 Tomcat：<code>service tomcat stop</code></p>
<p>如图：<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190805200245321.png" alt="在这里插入图片描述" /></p>
<h2 id="安装-sql-server-2017"><a class="markdownIt-Anchor" href="#安装-sql-server-2017"></a> 安装 SQL Server 2017</h2>
<ul>
<li>
<p>安装 curl软件包：<code>sudo apt install curl</code></p>
</li>
<li>
<p>导入 repository GPG键：<br />
<code>curl https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add -</code></p>
</li>
<li>
<p>导入 SQL Server Ubuntu的安装库：</p>
</li>
</ul>
<blockquote>
<p><code>curl https://packages.microsoft.com/config/ubuntu/16.04/mssql-server-2017.list | sudo tee /etc/apt/sources.list.d/mssql-server.list</code></p>
</blockquote>
<ul>
<li>
<p>安装 SQL Server：<br />
<code>sudo apt-get update</code><br />
<code>sudo apt-get install -y mssql-server</code></p>
</li>
<li>
<p>初始化 SQL Server配置：<br />
<code>sudo /opt/mssql/bin/mssql-conf setup</code><br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190805201359977.png" alt="在这里插入图片描述" /><br />
这里我选的版本是 2）</p>
</li>
<li>
<p>确认 SQL Server服务的状态：<code>systemctl status mssql-server</code><br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190805202404844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDUyOTA2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />
如果你的 Ubuntu版本是14.0，则在上一步结束时会显示安装失败或者启动失败，SQL Server 将无法运行！<br />
这里显示 running，说明SQL Server已正常启动。</p>
</li>
</ul>
<p>此时SQL Server安装成功，但还不能在终端执行 SQL语句。需要继续安装 <strong>SQL Server Tools</strong>：</p>
<ul>
<li>
<p>导入微软公共 GPG键<br />
<code>curl https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add -</code></p>
</li>
<li>
<p>注册微软 Ubuntu安装库</p>
</li>
</ul>
<blockquote>
<p><code>curl https://packages.microsoft.com/config/ubuntu/16.04/prod.list | sudo tee /etc/apt/sources.list.d/msprod.list</code></p>
</blockquote>
<ul>
<li>
<p>更新软件源： <code>sudo apt-get update</code></p>
</li>
<li>
<p>安装SQL Server工具包：  <code>sudo apt-get install mssql-tools unixodbc-dev</code></p>
</li>
<li>
<p>为了以后方便使用 sqlcmd，把安装目录添加到 bash shell环境变量中：<br />
<code>echo 'export PATH=&quot;$PATH:/opt/mssql-tools/bin&quot;' &gt;&gt; ~/.bash_profile</code><br />
<code>echo 'export PATH=&quot;$PATH:/opt/mssql-tools/bin&quot;' &gt;&gt; ~/.bashrc</code><br />
<code>source ~/.bashrc</code></p>
</li>
<li>
<p>然后输入以下命令即可进入 sqlcmd：<br />
<code>sqlcmd -S localhost -U SA -P 数据库密码</code></p>
</li>
</ul>
<p>到此为止 SQL Server已经全部安装完毕。如果需要 <strong>附加 mdf格式的数据库</strong>，继续如下操作：</p>
<ul>
<li>首先将 *.mdf的数据库文件和对应的 *_log.ldf文件放到 Linux目录下<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190805205418942.png" alt="在这里插入图片描述" /></li>
<li>进入该目录，将这两个文件通过  <code>chmod 777 文件名</code>赋予全部权限<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190805205509739.png" alt="在这里插入图片描述" /></li>
<li>进入 sqlcmd， 执行如下命令：<br />
<code>exec sp_attach_db 'patrol','/usr/xg/sqlPatrol/patrol.mdf','/usr/xg/sqlPatrol/patrol_log.ldf'</code></li>
</ul>
<p>其中， patrol为数据库名，执行此语句之前要先保证 patrol数据库不存在。<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190805205836163.png" alt="在这里插入图片描述" /><br />
附加成功后，执行  <code>exit</code> 可以退出 sqlcmd</p>
<h2 id="发布-web项目"><a class="markdownIt-Anchor" href="#发布-web项目"></a> 发布 Web项目</h2>
<ul>
<li>
<p>首先将 Web项目 Export为 war包</p>
</li>
<li>
<p>然后将其拷到 <code>/usr/xg/tomcat/apache-tomcat-8.5.12/webapps</code> 目录下，Tomcat启动后会自动将其解压</p>
</li>
<li>
<p>在浏览器输入 <strong><a href="http">主机 IP:8080/项目名</a></strong> 即可进行访问</p>
</li>
</ul>
<h3 id="大功告成"><a class="markdownIt-Anchor" href="#大功告成"></a> 大功告成！</h3>
<blockquote>
<p>文章首发于<a href="https://blog.csdn.net/qq_40452906/article/details/98520370?spm=1001.2014.3001.5501">CSDN</a></p>
</blockquote>
]]></content>
      <categories>
        <category>项目部署</category>
      </categories>
      <tags>
        <tag>项目部署</tag>
      </tags>
  </entry>
  <entry>
    <title>中标麒麟操作系统下部署 Web项目（Tongweb + DM）</title>
    <url>/posts/663218111.html</url>
    <content><![CDATA[<p>系统：中标麒麟桌面操作系统 V7.0</p>
<p>内核：Linux</p>
<p>CPU：龙芯</p>
<h2 id="配置-jdk"><a class="markdownIt-Anchor" href="#配置-jdk"></a> 配置 JDK</h2>
<p>安装东方通之前需要先安装 JDK。检查系统是否自带了JDK：打开终端输入 <code>java -version</code><br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818151258989.png" alt="在这里插入图片描述" /><br />
发现系统确实自带了JDK。查看系统环境变量  <code>cat /etc/profile</code> ，以确定是否配置了 JAVA_HOME <strong>（这一步至关重要！关系到 TongWeb能否正常工作）</strong>。可以看到，在 export 里面并没有 JAVA_HOME 的身影。那该如何对其进行配置呢？可通过如下方式一步步确定其路径：</p>
<p>1、 输入 <code>which java</code></p>
<p>这里显示的是 /bin/java 。将其作为下一步输入的值</p>
<p>2、 输入 <code>ls -lrt /bin/java</code></p>
<p>将  <code>-&gt;</code>之后的信息作为下一步的值。这里显示的是 /etc/alternatives/java</p>
<p>3、 输入 <code>ls -lrt /etc/alternatives/java</code></p>
<p>-&gt; 之后一直到包含jdk 信息的路径即为 JAVA_HOME 的路径。此处为： /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.60-1.8.nd7.02.mips64el<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818155722108.png" alt="在这里插入图片描述" /><br />
修改环境变量： <code>/etc/profile</code></p>
<p>在 export 之前添加 JAVA_HOME，并将 JAVA_HOME 添加至 export：<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/2019081815540514.png" alt="在这里插入图片描述" /><br />
保存后，输入 <code>source /etc/profile</code> 使其生效。</p>
<h2 id="安装-tongweb"><a class="markdownIt-Anchor" href="#安装-tongweb"></a> 安装 TongWeb</h2>
<p>将下载好的东方通 Install_TW6.0.7.0_Enterprise_Linux.zip解压，解压后其文件夹里有两个文件：</p>
<p>安装文件（Install_TW6.0.7.0_Enterprise_Linux.bin）和证书（license.dat）。</p>
<p>新建一个 tongweb 目录，将这两个文件全部拷贝进去。然后从终端进入 tongweb，执行以下命令进行安装：</p>
<p>输入： <code>sh Install_TW6.0.7.0_Enterprise_Linux.bin -i console</code><br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818161316677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDUyOTA2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />
这里我选的是中文，之后根据提示按 <kbd>Enter</kbd> 键继续。<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818161940719.png" alt="在这里插入图片描述" /><br />
这里的安装位置建议放在刚刚新建的 tongweb 目录下（如果放在其他目录，结束时记得将证书拷贝到其根目录）<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818162415471.png" alt="在这里插入图片描述" /><br />
这里我选择了默认位置。<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818162517419.png" alt="在这里插入图片描述" /><br />
开始安装。<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818162555971.png" alt="在这里插入图片描述" /><br />
然后出现了这个，可以直接回车。<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818162737168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDUyOTA2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />
之后同样可以一直回车，直到提示安装完毕。</p>
<p>进入 bin目录，输入  <code>sh startserver.sh</code> 启动服务。<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818163149739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDUyOTA2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />
最后看到启动完成，安装成功！</p>
<p>打开浏览器，输入 <a href="localhost:9060/console/rest">localhost:9060/console/rest</a>，可以进入 TongWeb 管理控制平台。<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818163702758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDUyOTA2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />
现在不急着登录，先安装达梦数据库。</p>
<h2 id="安装配置-dm"><a class="markdownIt-Anchor" href="#安装配置-dm"></a> 安装配置 DM</h2>
<p>根据官方文档，为了减少对系统的影响，不应该以 root 用户来安装和运行 DM。因此，在安装之前，先创建一个专门的系统用户。</p>
<h5 id="一-创建安装用户"><a class="markdownIt-Anchor" href="#一-创建安装用户"></a> 一、创建安装用户</h5>
<p>1、创建安装用户组 xggroup</p>
<p><code>groupadd xggroup</code></p>
<p>2、创建安装用户gh</p>
<p><code>useradd -g xggroup -m -d /home/gh -s /bin/bash gh</code></p>
<p>3、初始化用户密码，根据提示进行密码设置</p>
<p><code>passwd gh</code><br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/2019081817034794.png" alt="在这里插入图片描述" /></p>
<h5 id="二-通过命令行安装-dm"><a class="markdownIt-Anchor" href="#二-通过命令行安装-dm"></a> 二、通过命令行安装 DM</h5>
<p>下载好 DM 安装文件 DMInstall.bin ，新建 dm 目录并将安装文件拷贝进去。</p>
<p>以新用户身份 gh 从终端进入 dm，执行以下命令进行安装：</p>
<p>输入 <code>./DMInstall.bin -i</code><br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818171731651.png" alt="在这里插入图片描述" /><br />
这里我选的是中文。之后会自动解压程序。<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818171835499.png" alt="在这里插入图片描述" /><br />
这里根据实际情况选择。<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818171930473.png" alt="在这里插入图片描述" /><br />
这里选择“是”。<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818172002835.png" alt="在这里插入图片描述" /><br />
选择21即可。<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/2019081817203591.png" alt="在这里插入图片描述" /><br />
这里根据个人需要选择。<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818172152181.png" alt="在这里插入图片描述" /><br />
这里我选的是默认目录。<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818172246564.png" alt="在这里插入图片描述" /><br />
由于使用非 root 系统用户进行安装，所以部分安装步骤没有相应的系统权限。这里根据提示切换到 root 用户执行该命令。<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818172500199.png" alt="在这里插入图片描述" /><br />
安装完成！</p>
<h5 id="三-配置-dm"><a class="markdownIt-Anchor" href="#三-配置-dm"></a> 三、配置 DM</h5>
<p>首先切换至新建的 gh 用户。<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818173102478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDUyOTA2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />
登入以后可以在桌面上看到 DMDBMS 文件夹，在其子文件夹 client 中可以看到所有刚刚安装好的工具。<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818173703497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDUyOTA2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />
打开数据库配置助手，选择 “创建数据库实例” ，点击 “开始” 进入下一步。可以使用默认项进行配置。<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/2019081818050117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDUyOTA2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818180511726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDUyOTA2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818180536749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDUyOTA2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818180543302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDUyOTA2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818180617393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDUyOTA2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818180632323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDUyOTA2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818180639759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDUyOTA2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818180647692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDUyOTA2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/2019081818065533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDUyOTA2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818180703327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDUyOTA2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />
这里根据需要进行选择。<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818180734909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDUyOTA2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />
点击 “完成”。<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818180810276.png" alt="在这里插入图片描述" /><br />
这里先点击 “确定” 继续安装，之后再作处理。<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818181047760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDUyOTA2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />
根据提示执行相应命令。<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818181219297.png" alt="在这里插入图片描述" /><br />
点击 “确定”。<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818181313727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDUyOTA2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />
点击 “完成” ，安装初始化数据库完成。</p>
<p>现在解决刚刚的提示信息：<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818181432448.png" alt="在这里插入图片描述" /><br />
打开终端，以 root 身份执行一下命令：</p>
<p>输入 <code>ulimit -a</code> ，可以看到当前 open files 为 1024。<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818181829305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDUyOTA2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />
下面对 <code>vi /etc/security/limits.conf</code> 进行修改。</p>
<p>在打开的文件中插入如下两条记录：<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818182417477.png" alt="在这里插入图片描述" /><br />
保存并退出，再次输入 <code>ulimit -a</code> ，可以看到 open files 已被修改为 65535。<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818182614313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDUyOTA2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<h2 id="项目部署"><a class="markdownIt-Anchor" href="#项目部署"></a> 项目部署</h2>
<p>首先把项目导出为 war 格式并拷贝到目标目录下，然后对其进行读写权限的修改。</p>
<p><strong>这里读写权限的分配将关系到后面能否顺利部署！</strong></p>
<p>打开之前的网址 <a href="localhost:9060/console/rest">localhost:9060/console/rest</a>进入 TongWeb 管理控制平台，默认用户名：twnt，密码：<a href="http://twnt123.com">twnt123.com</a><br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818163702758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDUyOTA2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />
进入 “JDBC配置” 界面，点击 “创建连接池”：<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818185925763.png" alt="在这里插入图片描述" /><br />
&quot;数据库类型” 选择达梦；<br />
“连接url” 里将端口号修改为5236；<br />
“密码” 填写数据库配置时设置的口令；<br />
“连接参数” 可以不填；<br />
“驱动路径” 在数据库的安装目录 dmdbms 下，路径为：<code>dmdbms/drivers/jdbc/</code> ，选中所有类型的 jar 包（DmJdbcDriver根据配置的 jdk 版本进行选择：16对应 jdk1.6, 17对应 jdk1.7，以此类推）<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818190024714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDUyOTA2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />
点击 “下一步” ，可以看到提示 “数据库连接成功”<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818191115764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDUyOTA2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />
这里可以直接点 “完成” 使用默认设置。然后进入 “应用管理” 界面，点击 “部署应用”<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818191524825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDUyOTA2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />
点击 “浏览”，选择刚刚拷贝过来的项目<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818192015478.png" alt="在这里插入图片描述" /><br />
读取成功后，点击 “开始部署”<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818192116440.png" alt="在这里插入图片描述" /><br />
根据实际需要填写，然后点击 “下一步”<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818192205916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDUyOTA2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />
这里可以直接点击 “完成” 使用默认设置<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818192305181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDUyOTA2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />
可以看到列表中出现了刚刚部署的项目。可以点击 “http访问” 。<br />
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://img-blog.csdnimg.cn/20190818192353178.png" alt="在这里插入图片描述" /><br />
部署完成！</p>
<blockquote>
<p>文章首发于<a href="https://blog.csdn.net/qq_40452906/article/details/99704762?spm=1001.2014.3001.5501">CSDN</a></p>
</blockquote>
]]></content>
      <categories>
        <category>项目部署</category>
      </categories>
      <tags>
        <tag>项目部署</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/1243066710.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2>
<h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mapToBucket</span><span class="params">(<span class="type">unsigned</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v &gt;= <span class="number">0</span> &amp;&amp; v &lt; <span class="number">10</span>)  <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">if</span> (v &gt;= <span class="number">10</span> &amp;&amp; v &lt; <span class="number">20</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">if</span> (v &gt;= <span class="number">20</span> &amp;&amp; v &lt; <span class="number">30</span>) <span class="keyword">return</span> <span class="number">2</span>; <span class="keyword">if</span> (v &gt;= <span class="number">30</span> &amp;&amp; v &lt; <span class="number">40</span>) <span class="keyword">return</span> <span class="number">3</span>; <span class="keyword">if</span> (v &gt;= <span class="number">40</span> &amp;&amp; v &lt; <span class="number">50</span>) <span class="keyword">return</span> <span class="number">4</span>; <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>virtual底层实现</title>
    <url>/posts/40140329.html</url>
    <content><![CDATA[<p>在基类中，通过 virtual修饰虚函数可以实现多态的效果，下面就介绍下它的底层实现原理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">	virtual <span class="keyword">void</span> <span class="title function_">func1</span>(<span class="params"></span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - func1()&quot;</span> &lt;&lt; endl; </span><br><span class="line">	&#125;</span><br><span class="line">	virtual <span class="keyword">void</span> <span class="title function_">func2</span>(<span class="params"></span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - func2()&quot;</span> &lt;&lt; endl; </span><br><span class="line">	&#125;</span><br><span class="line">	virtual <span class="keyword">void</span> <span class="title function_">func3</span>(<span class="params"></span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - func3()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当基类的成员变量或函数被声明为虚函数后</span></span><br><span class="line"><span class="comment">// 其子类中的同名变量或函数都将自动成为虚函数（virtual关键字可省略）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : public <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">	virtual <span class="keyword">void</span> <span class="title function_">func1</span>(<span class="params"></span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son  - func1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 注意：func2() 虽然没重写，但依然继承下来了！！</span></span><br><span class="line">	virtual <span class="keyword">void</span> <span class="title function_">func3</span>(<span class="params"></span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son  - func3()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">func</span>(<span class="params">Base&amp; base</span>) &#123;</span><br><span class="line">    base.<span class="title function_">func1</span>();</span><br><span class="line">    base.<span class="title function_">func2</span>();</span><br><span class="line">    base.<span class="title function_">func3</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Son</span> son;</span><br><span class="line">    <span class="title function_">func</span>(son);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器见到这种继承层次结构后，就知道 Base定义了虚函数，并在 Son类中重写了虚函数，因此，编译器会为定义了虚函数的基类创建一个虚函数表（Virtual Function Table，VFT），这个虚函数表会被子类继承下去。在用 Base或 Son实例化对象时，编译器会在该对象内部创建一个隐藏的指针 VFT* 指向相应的虚函数表。虚函数表可视为一个由函数指针构成的静态数组，其中每个指针都指向相应虚函数的实现：</p>
<p><img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://wx3.sinaimg.cn/mw690/006ept9Hgy1gthondz83cj30z70mu76u.jpg" alt="virtual" /></p>
<p>在这种情况下，虽然将 son传递给了 base，进而被解读成一个 Base实例，但该实例（即 Son对象）内部的 VFT* 仍然指向 Son类的虚函数表，因此通过该虚函表执行的是 Son::func()，从而实现了多态。因此上述代码的输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Son  - func1()</span><br><span class="line">Base - func2()</span><br><span class="line">Son  - func3()</span><br></pre></td></tr></table></figure>
<p>要验证虚函数表的存在其实也很简单，可以通过比较同一个类，一个包含虚函数，一个不包含，对比其大小就知道了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">	int a, b;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">	int a, b;</span><br><span class="line">	virtual <span class="keyword">void</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof(Test): &quot;</span> &lt;&lt; <span class="title function_">sizeof</span>(<span class="title class_">Test</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof(Base): &quot;</span> &lt;&lt; <span class="title function_">sizeof</span>(<span class="title class_">Base</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sizeof(Test): 8</span><br><span class="line">sizeof(Base): 16</span><br></pre></td></tr></table></figure>
<p>虽然两个类几乎相同，但由于 Base 中的 func() 是一个虚函数，编译器为 Base类生成了一个虚函数表，并为其虚函数表指针预留了空间，因此 Base 类比 Test 类多了一个指针大小的空间。</p>
<p>虚函数表属于类，类的所有对象共享这个类的虚函数表，它在编译时生成，保存在 .rodata 只读数据段。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>virtual</tag>
      </tags>
  </entry>
  <entry>
    <title>以 hello为例了解程序的执行过程</title>
    <url>/posts/3718840809.html</url>
    <content><![CDATA[<p>hello 程序的生命周期从高级 C 程序 hello.c 开始的，这实际上是一个文本文件，里面都是 0 和 1 组成的比特序列。每 8 位为一个字节，一个字节对应的整数值表示一个 ASCII 文本字符。为了在系统上运行 hello.c 程序，每条 C 语句都必须被编译器转换为一系列低级的机器语言指令，这些指令被封装为可执行目标程序 hello，并以二进制文件的形式保存在磁盘上。</p>
<h2 id="1-程序的翻译"><a class="markdownIt-Anchor" href="#1-程序的翻译"></a> 1. 程序的翻译</h2>
<p>从源程序到目标程序的翻译过程可分为四个阶段，执行这四个阶段的程序——预处理器、编译器、汇编器、链接器一起构成了编译系统。</p>
<p><img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://wx1.sinaimg.cn/mw690/006ept9Hgy1gsgpbc16vuj30iv03gtaj.jpg" alt="编译系统" /></p>
<ul>
<li><strong>预处理阶段</strong>：预处理器根据以字符 # 开头的命令修改原始程序。比如对于 #include&lt;stdio.h&gt;，编译器会读取 stdio.h 中的内容并插入到 hello 程序文本中；对于 #define MAX 100，编译器会将程序中的所有 MAX 替换为 100。这样就得到了另一个 C 程序，并保存为 hello.i 文件。</li>
<li><strong>编译阶段</strong>：这个过程主要是进行词法分析、语法分析、语义分析等，将文本文件 hello.i 翻译成低级机器语言——汇编语言，从而为不同高级语言的不同编译器提供了通用的输出文件 hello.s（这里的通用只针对相同的平台，即只针对相同的指令集架构）。</li>
<li><strong>汇编阶段</strong>：汇编器将汇编代码翻译成机器代码，并将其打包为可重定位目标程序的格式，保存在目标文件 hello.o 中。hello.o 是一个二进制文件，用文本编辑器打开会看到一堆乱码。</li>
<li><strong>链接阶段</strong>：hello 程序调用了 C 标准库函数 printf，它保存在一个已经单独预编译好的目标文件 printf.o 中，链接器将其合并到 hello.o 程序，从而得到了可执行目标文件 hello，可以被加载到内存中执行。</li>
</ul>
<h2 id="2-程序的执行"><a class="markdownIt-Anchor" href="#2-程序的执行"></a> 2. 程序的执行</h2>
<p>shell 是一个命令行解释程序。初始时，shell 程序执行它的指令，等待命令的输入。如果该命令的第一个单词不是一个内置的 shell 命令，shell就会假设这是一个可执行文件的名字。当在键盘输入字符串“./hello”之后，shell 程序将字符逐一读入寄存器，再把它存入内存中。</p>
<p><img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://wx2.sinaimg.cn/mw690/006ept9Hgy1gsgpbf4e19j30dx0abgps.jpg" alt="从键盘上读取hello命令" /></p>
<p>当通过键盘输入回车时，shell 程序就知道命令输入结束，开始执行一系列指令加载保存在磁盘上的可执行文件 hello，将其中的代码和数据复制到主存。数据中包括最终要被输出的字符串 “hello, world\n”。此过程利用直接内存访问（DMA）技术，使数据能够不经过处理器直接从磁盘到达主存。</p>
<p><img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://wx2.sinaimg.cn/mw690/006ept9Hgy1gsgpbiv2asj30fq0aqtda.jpg" alt="从磁盘加载可执行程序到主存" /></p>
<p>当目标文件 hello 中的指令和数据被加载到主存后，处理器就开始执行其中 main 函数里面的机器指令，指令的执行过程即取指、译码、执行、访存、写回几个步骤，会有频繁的CPU对内存的数据访问，比如在第一步取指的时候就需要根据 PC 的值去内存中读取相应的指令。这些指令将 “hello, world\n” 字符串中的字节从主存复制到寄存器，再从寄存器复制到显示设备，最终显示在屏幕上。</p>
<p><img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://wx4.sinaimg.cn/mw690/006ept9Hgy1gsgpbm0aukj30fb0ac78x.jpg" alt="将输出字符串从存储器写到显示器" /></p>
<blockquote>
<p>以上内容参考自 Randal E.Bryant 编写的『深入理解计算机系统』</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>程序执行过程</tag>
      </tags>
  </entry>
  <entry>
    <title>多发射数据通路和数据调度</title>
    <url>/posts/3647999940.html</url>
    <content><![CDATA[<p>介绍两种提高流水线效率（即提高 IPC）的技术： <strong>多发射数据通路</strong> 和 <strong>动态调度</strong>。</p>
<p>为了提高流水线的执行效率，一个最直观的方式就是让处理器中的每级流水线能够同时处理多条指令，这就是多发射数据通路技术。比如对于双发射流水线来说，每次都会进行两条指令的取指、译码、执行、访存和写回操作，其理想 IPC 就从单发射流水线的 1 提升到了 2。</p>
<p>之所以说理想情况，是因为会有各类相关（也叫冒险）所引起的阻塞，因此其实际执行效率会大打折扣。为了减少这些阻塞，引入了动态调度技术。</p>
<p>先看一个例子：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">DIV</span>	$<span class="number">3</span>, $<span class="number">2</span>, $<span class="number">1</span></span><br><span class="line"><span class="variable constant_">ADD</span>	$<span class="number">5</span>, $<span class="number">4</span>, $<span class="number">3</span></span><br><span class="line"><span class="variable constant_">SUB</span>	$<span class="number">8</span>, $<span class="number">7</span>, $<span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>其中，DIV 与 ADD 指令有 RAW（Read After Write）相关，因此二者必须顺序执行，而 SUB 与前面两条指令都不相关，完全可以越过前面尚未执行完毕的 DIV 和 ADD 指令提前开始执行，从而减少整体的执行延迟，这就是 <strong>动态调度</strong>。</p>
<p>要完成此功能，需要将原有流水线中的译码阶段拆分为 <strong>发射</strong> 和 <strong>读操作数</strong> 两个阶段。发射阶段进行指令译码，并检查结构相关（两条指令要同时访问流水线中的同一个功能部件）；读操作数阶段则等待读取操作数。处在等待状态的指令不能一直停留在原有的译码流水级上，因为这会阻碍后面的指令进入流水线，因此我们会用一个称为 <strong>保留站</strong> 或者 <strong>发射队列</strong> 的结构来保存这些等待的指令。在每个时钟周期，保留站会选择一条未被阻塞的指令送往执行逻辑，并退出保留站，这个动作称为 <strong>发射</strong>。</p>
<p>保留站调度算法的核心就在于挑选未被阻塞的指令，那保留站是如何处理数据相关所引起的阻塞呢？</p>
<p>再看一个例子：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">DIV</span>	$<span class="number">3</span>, $<span class="number">2</span>, $<span class="number">1</span></span><br><span class="line"><span class="variable constant_">ADD</span>	$<span class="number">5</span>, $<span class="number">4</span>, $<span class="number">3</span></span><br><span class="line"><span class="variable constant_">SUB</span>	$<span class="number">4</span>, $<span class="number">7</span>, $<span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>ADD 与 SUB 指令之间存在 WAR（Write After Read）相关，在乱序执行的情况下，SUB 指令的执行不会依赖 DIV 与 ADD 两条指令，可以得到正确的结果，但这个结果在执行结束后是不会立即写入寄存器的。因为如果 ADD 指令由于等待 DIV 指令的结果还没有开始执行，而 SUB 却已经修改了 $4 寄存器的值，那么等到 ADD 开始执行的时候就会产生错误的结果。</p>
<p>类似地：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">DIV</span>	$<span class="number">3</span>, $<span class="number">2</span>, $<span class="number">1</span></span><br><span class="line"><span class="variable constant_">ADD</span>	$<span class="number">5</span>, $<span class="number">4</span>, $<span class="number">3</span></span><br><span class="line"><span class="variable constant_">SUB</span>	$<span class="number">5</span>, $<span class="number">7</span>, $<span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>ADD 与 SUB 指令之间存在 WAW（Write After Write）相关，在乱序执行的情况下，SUB 可以先于 ADD 执行。如果 SUB 已经执行完毕，而 ADD 因为等待 DIV 的结果还没有开始执行，那 SUB 修改的 $5 寄存器的值就会被 ADD 写回时覆盖，SUB 后面的指令读取该寄存器的值就会得到错误的结果。</p>
<p><mark>其实，WAR 和 WAW 与 RAW 是有本质区别的，它们并不是由程序中真正的数据依赖所引起的相关关系，而仅仅是由于恰好使用了具有相同名字的寄存器所引起的名字相关。</mark></p>
<p>因此，只需找一个不受干扰的寄存器来做中转，就省去了等待的过程，从而消除了 WAR 和 WAW 相关，这就是 <strong>寄存器重命名技术</strong>。</p>
<p>于是，上述两个例子就可以变为：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">DIV</span>	$<span class="number">3</span>, $<span class="number">2</span>, $<span class="number">1</span></span><br><span class="line"><span class="variable constant_">ADD</span>	$<span class="number">5</span>, $<span class="number">4</span>, $<span class="number">3</span></span><br><span class="line"><span class="variable constant_">SUB</span>	$ren_1, $<span class="number">7</span>, $<span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>以及</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">DIV</span>	$<span class="number">3</span>, $<span class="number">2</span>, $<span class="number">1</span></span><br><span class="line"><span class="variable constant_">ADD</span>	$<span class="number">5</span>, $<span class="number">4</span>, $<span class="number">3</span></span><br><span class="line"><span class="variable constant_">SUB</span>	$ren_2, $<span class="number">7</span>, $<span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>在流水线中实现动态调度，最后还需考虑一个问题：<strong>精确异常</strong>，即在处理异常时，要求异常指令前面的所有指令都已执行完（修改了机器状态），而异常指令及其后面的所有指令都没有执行（没有修改机器状态）。在乱序执行中，指令已经打破了原有的先后顺序在流水线中执行了，“前面”和“后面”这样的顺序关系要从哪里获得呢？还有，异常指令后面的指令都不能修改机器状态，但它们很可能已经越过异常指令提前执行了，这又该怎么解决？</p>
<p>对于上述两个问题的解决方法就是，在流水线中添加一个 <strong>ROB</strong>（ReOrder Buffer），使指令能够有序结束，同时在流水线中增加一个 <strong>提交阶段</strong>。指令对机器状态的修改只有在到达提交阶段才能生效，处在写回阶段的指令不能真正修改机器的状态。</p>
<p>ROB 是一个先进先出的有序队列，所有指令在译码之后按照原始顺序进入队列尾部，执行完毕的指令从队列头部按序提交。提交时一旦发现有异常指令，那么该指令即其之后处在 ROB 中的指令都会被清空。异常指令前面的指令都已经从 ROB 头部退出并提交了，它们对机器状态的修改都已生效；而异常指令及其后续指令都因被清空而没有提交，也就不会修改机器状态，这就满足了精确异常的需求。</p>
<blockquote>
<p>以上内容参考自胡伟武老师编写的『计算机体系结构基础』</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>多发射 动态调度 保留站 寄存器重命名 精确异常</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈结构体中的数据对齐</title>
    <url>/posts/1301175934.html</url>
    <content><![CDATA[<p>在计算机中，CPU是按 32/64 位的大小进行存取的，为了提高CPU的执行效率，计算机系统对基本数据类型的合法地址做了一些限制，要求某种类型的地址必须是某个值（2 / 4 / 8）的倍数，这就是数据对齐。数据对齐会由编译器自动实现，但了解其实现方法还是很有必要的，可以优化代码结构，达到节省空间和提高效率的目的。</p>
<p>数据对齐的基本原则是，任何 k 字节的基本对象的地址必须是 k 的倍数，同时结构体本身也要对齐，因此编译器可能需要在字段的地址空间分配时插入一些空隙以达到对齐的目的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">struct s1 &#123;</span><br><span class="line">    int i;</span><br><span class="line">    double d;</span><br><span class="line">    float f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在64位机器上，以结构体 s1 为例，当不进行数据对齐时，结构体内部各成员在内存中的分布如下：</p>
<p><img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://wx4.sinaimg.cn/mw690/006ept9Hgy1grcu7oh6ioj30e902bt8i.jpg" alt="不对齐" /></p>
<p>虽然整体只占 16 个字节，但如果要访问成员 d，需要两个周期才能完成。而当进行数据对齐后：</p>
<p><img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://wx4.sinaimg.cn/mw690/006ept9Hgy1grcu7s11czj30e7033a9v.jpg" alt="对齐" /></p>
<p>这时结构体占了 24 个字节，但访问每个成员都只需要 1 个周期。对齐第一个成员 i 是为了使成员 d 的地址为 <code>sizeof(d)</code> 的倍数，即为了使成员 d 不分段；最后还要补 4 个字节是为了对齐结构体自身，需要以其最大成员长度为标准进行对齐，即 8 字节对齐。</p>
<p>接下来我们可以稍稍调整一下结构体中各成员的顺序，得到结构体 s2：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">struct s2 &#123;</span><br><span class="line">    int i;</span><br><span class="line">    float f;</span><br><span class="line">    double d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时，其内存分布为：</p>
<p><img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://wx2.sinaimg.cn/mw690/006ept9Hgy1grcu7vx1haj30e702bq2q.jpg" alt="重排序" /></p>
<p>可以看到，这时结构体只占 16 个字节，同时对于每个成员的访问也只需要 1 个周期，这就同时达到了节省内存空间和提高处理器执行效率的目的。</p>
<p>当然，对齐系数也可以通过预编译命令 <code>#pragma pack(n)</code> 自己指定，其中 n 即为对齐系数，可取 1, 2, 4, 6, 8, 16，具体细节这里不做介绍。</p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>数据对齐</tag>
      </tags>
  </entry>
  <entry>
    <title>C++智能指针</title>
    <url>/posts/2579659560.html</url>
    <content><![CDATA[<p>智能指针是用来管理指针的，主要解决两类问题：一是忘记释放内存，造成内存泄漏；二是内存提前释放，造成指针悬空。智能指针是一个类，它的行为类似于常规指针，主要区别在于它会自动释放对象。<br />
C++ 有四种智能指针：auto_ptr, unique_ptr, shared_ptr 和 weak_ptr，其中 auto_ptr 已被 11 弃用。它们的区别在于管理底层指针的方法不同，shared_ptr允许多个指针指向同一个对象，unique_ptr则“独占”所指向的对象，weak_ptr是一种弱引用，指向 shared_ptr所管理的对象，它们都定义在 memory 头文件中。</p>
<h3 id="1-auto_ptr"><a class="markdownIt-Anchor" href="#1-auto_ptr"></a> 1. auto_ptr</h3>
<p>采用所有权模式。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">auto_ptr&lt;string&gt; <span class="title function_">p1</span>(<span class="keyword">new</span> string (<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line">auto_ptr&lt;string&gt; p2;</span><br><span class="line">p2 = p1;  <span class="comment">// 不会报错</span></span><br><span class="line">cout &lt;&lt; *p1 &lt;&lt; endl; <span class="comment">// 此时会报错！!</span></span><br></pre></td></tr></table></figure>
<p>此时 auto_ptr 不会报错，因为 p2 剥夺了 p1 的所有权，但是当程序访问 p1 时会报错。所以 auto_ptr 的缺点是存在潜在的内存崩溃问题。</p>
<h3 id="2-unique_ptr"><a class="markdownIt-Anchor" href="#2-unique_ptr"></a> 2. unique_ptr</h3>
<p>用于替换 auto_ptr，同样采用所有权模式，区别在于它能保证一个时刻只有一个 unique_ptr 指向给定对象，所以它不支持普通的拷贝或赋值操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">unique_ptr&lt;string&gt; <span class="title function_">p3</span>(<span class="keyword">new</span> string (<span class="string">&quot;auto&quot;</span>));</span><br><span class="line">unique_ptr&lt;string&gt; p4;</span><br><span class="line">p4 = p3; <span class="comment">// 此时会报错！！</span></span><br></pre></td></tr></table></figure>
<p>这样就避免了 p3 指针悬空问题，所以它比 auto_ptr 更安全。<br />
对于拷贝或赋值操作的限制有一个例外，如果要拷贝的 unique_ptr 是一个临时右值（即将被销毁），那编译器将允许这么做：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">unique_ptr&lt;string&gt; p1;</span><br><span class="line">p1 = unique_ptr&lt;string&gt;(<span class="keyword">new</span> <span class="title function_">string</span>(<span class="string">&quot;Hello&quot;</span>)); <span class="comment">// 不会报错</span></span><br><span class="line"></span><br><span class="line">unique_ptr&lt;int&gt; <span class="title function_">clone</span>(<span class="params">int num</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> unique_ptr&lt;int&gt;(<span class="keyword">new</span> <span class="title function_">int</span>(num));</span><br><span class="line">&#125;</span><br><span class="line">unique_ptr&lt;string&gt; p2 = <span class="title function_">clone</span>(<span class="number">2</span>); <span class="comment">// 不会报错</span></span><br></pre></td></tr></table></figure>
<p>对于其他情况，虽然不能对 unique_ptr 进行拷贝或赋值，但可以通过调用 release 或 reset 将对象所有权从一个非const的 unique_ptr转移给另一个：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">unique_ptr&lt;string&gt; <span class="title function_">p1</span>(<span class="keyword">new</span> string (<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将string (&quot;Hello World&quot;)的所有权从p1转移给p2</span></span><br><span class="line"><span class="comment">// release会释放p1的所有权，同时返回指向被管理对象的指针</span></span><br><span class="line">unique_ptr&lt;string&gt; <span class="title function_">p2</span>(p1.<span class="title function_">release</span>());</span><br><span class="line"></span><br><span class="line">unique_ptr&lt;string&gt; <span class="title function_">p3</span>(<span class="keyword">new</span> <span class="title function_">string</span>(<span class="string">&quot;Trex&quot;</span>));</span><br><span class="line"><span class="comment">// 将new string(&quot;Trex&quot;)的所有权从p3转移给p2</span></span><br><span class="line"><span class="comment">// reset会先释放p2原来指向的内存，然后指向新的传入对象</span></span><br><span class="line">p2.<span class="title function_">reset</span>(p3.<span class="title function_">release</span>());</span><br></pre></td></tr></table></figure>
<p>此外，C++标准库 <utility> 中还提供了一个函数 move()，也可将一个 unique_ptr 对象赋值给另一个，但它是通过将一个左值 p1 强制转换为右值引用，继而通过右值引用使用该值，基本等同于类型转换 static_cast：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">unique_ptr&lt;string&gt; <span class="title function_">p1</span>(<span class="keyword">new</span> <span class="title function_">string</span>(<span class="string">&quot;hello &quot;</span>));</span><br><span class="line">unique_ptr&lt;string&gt; p2 = <span class="title function_">move</span>(p1);</span><br><span class="line">p1 = unique_ptr&lt;string&gt;(<span class="keyword">new</span> <span class="title function_">string</span>(<span class="string">&quot;world&quot;</span>));</span><br><span class="line">cout &lt;&lt; *p2 &lt;&lt; *p1 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h3 id="3-shared_ptr"><a class="markdownIt-Anchor" href="#3-shared_ptr"></a> 3. shared_ptr</h3>
<p>采用共享模式，多个智能指针可以指向相同的对象，解决了 auto_ptr在对象所有权上的局限性（独占）。通过引用计数的方式来确定对象被几个指针共享（可以通过 use_count()查看），每次调用 reset()都释放当前指针的资源所有权，并将计数减一，当计数减为 0时，即表示指向对象的最后一个智能指针也被销毁，此时 shared_ptr会自动销毁此对象。<br />
由于 shared_ptr本质上是一个对象，所以通过 new对象的方式为其进行赋值时实际要分配两次内存，一次为智能指针对象，一次为 new对象。最安全的分配和使用动态内存的方法是调用 make_shared函数，它只需一次内存分配。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;<span class="title class_">Foo</span>&gt; <span class="title function_">sp1</span>(<span class="keyword">new</span> <span class="title class_">Foo</span>);</span><br><span class="line">auto sp2 = make_shared&lt;<span class="title class_">Foo</span>&gt;();</span><br></pre></td></tr></table></figure>
<p>手动实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shared_ptr</span> &#123;</span><br><span class="line"><span class="attr">private</span>:</span><br><span class="line">    int* cnt; <span class="comment">// 为了让所有对象共用同一个计数器，将其开辟到了堆中</span></span><br><span class="line">    T* ptr;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">release</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ptr &amp;&amp; --(*cnt) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> cnt;</span><br><span class="line">            <span class="keyword">delete</span> ptr;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;~Shared_ptr()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    <span class="comment">// 无参构造</span></span><br><span class="line">    <span class="title class_">Shared</span>_ptr() : <span class="title function_">cnt</span>(<span class="number">0</span>), <span class="title function_">ptr</span>(<span class="params">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="comment">// 有参构造</span></span><br><span class="line">    <span class="title class_">Shared</span>_ptr(T* p) : <span class="title function_">cnt</span>(<span class="keyword">new</span> <span class="title function_">int</span>(<span class="number">1</span>)), <span class="title function_">ptr</span>(<span class="params">p</span>) &#123;&#125;</span><br><span class="line">    <span class="comment">// 拷贝构造</span></span><br><span class="line">    <span class="title class_">Shared</span>_ptr(<span class="keyword">const</span> <span class="title class_">Shared</span>_ptr&lt;T&gt;&amp; sp) : <span class="title function_">cnt</span>(sp.<span class="property">cnt</span>), <span class="title function_">ptr</span>(<span class="params">sp.ptr</span>) &#123;++(*cnt);&#125;</span><br><span class="line">    <span class="comment">// 重载 * 与 -&gt; 实现指针功能</span></span><br><span class="line">    T&amp; operator*() &#123; <span class="keyword">return</span> *ptr; &#125;</span><br><span class="line">    T* operator-&gt;() &#123; <span class="keyword">return</span> ptr; &#125;</span><br><span class="line">    <span class="comment">// 重载 =</span></span><br><span class="line">    <span class="title class_">Shared</span>_ptr&lt;T&gt;&amp; operator=(<span class="title class_">Shared</span>_ptr&lt;T&gt;&amp; sp) &#123;</span><br><span class="line">        <span class="comment">// 如果this所指地址等于sp的地址，即二者本身就共享同一对象，无需进行任何操作</span></span><br><span class="line">        <span class="comment">// 否则，释放原始对象，共享新的对象，并且引用计数加一</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span> != &amp;sp) &#123;</span><br><span class="line">            <span class="title function_">release</span>();</span><br><span class="line">            ptr = sp.<span class="property">ptr</span>;</span><br><span class="line">            cnt = sp.<span class="property">cnt</span>;</span><br><span class="line">            ++(*cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="variable language_">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    int <span class="title function_">use_count</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> *cnt; &#125;</span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="title class_">Shared</span>_ptr() &#123;</span><br><span class="line">        <span class="title function_">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 有参构造</span></span><br><span class="line">    <span class="title class_">Shared</span>_ptr&lt;int&gt; <span class="title function_">sp1</span>(<span class="keyword">new</span> <span class="title function_">int</span>(<span class="number">5</span>));</span><br><span class="line">    cout &lt;&lt; *sp1 &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; sp1.<span class="title function_">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 拷贝构造</span></span><br><span class="line">    <span class="title class_">Shared</span>_ptr&lt;int&gt; <span class="title function_">sp2</span>(sp1);</span><br><span class="line">    cout &lt;&lt; *sp1 &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; sp1.<span class="title function_">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *sp2 &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; sp2.<span class="title function_">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="title class_">Shared</span>_ptr&lt;int&gt; <span class="title function_">sp3</span>(<span class="keyword">new</span> <span class="title function_">int</span>(<span class="number">10</span>));</span><br><span class="line">    cout &lt;&lt; *sp3 &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; sp3.<span class="title function_">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值操作</span></span><br><span class="line">    sp3 = sp2;</span><br><span class="line">    cout &lt;&lt; *sp1 &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; sp1.<span class="title function_">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *sp2 &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; sp2.<span class="title function_">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *sp3 &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; sp3.<span class="title function_">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span>  <span class="number">1</span></span><br><span class="line"><span class="number">5</span>  <span class="number">2</span></span><br><span class="line"><span class="number">5</span>  <span class="number">2</span></span><br><span class="line"><span class="number">10</span>  <span class="number">1</span></span><br><span class="line">~<span class="title class_">Shared</span>_ptr()</span><br><span class="line"><span class="number">5</span>  <span class="number">3</span></span><br><span class="line"><span class="number">5</span>  <span class="number">3</span></span><br><span class="line"><span class="number">5</span>  <span class="number">3</span></span><br><span class="line">~<span class="title class_">Shared</span>_ptr()</span><br></pre></td></tr></table></figure>
<h3 id="4-weak_ptr"><a class="markdownIt-Anchor" href="#4-weak_ptr"></a> 4. weak_ptr</h3>
<p>不控制对象的生命周期，只是指向由 shared_ptr所管理的对象。将 weak_ptr绑定到 shared_ptr不会改变 shared_ptr的引用计数，只要最后一个指向对象的 shared_ptr被销毁，对象就会被释放，即便仍然有 weak_ptr指向该对象。因此，由于对象可能不存在，所以不能使用 weak_ptr直接访问对象，必须使用 lock()。此函数检查 weak_ptr指向的对象是否存在，如果存在，lock()返回一个指向共享对象的 shared_ptr（相当于把 weak_ptr转换成了 shared_ptr），否则返回一个空指针。<br />
weak_ptr 主要是为了解决 shared_ptr相互引用时产生的死锁问题，如果两个 shared_ptr相互引用，那这两个指针的引用计数永远不可能下降为 0，资源也就永远不会释放：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    <span class="comment">// 修改：weak_ptr&lt;B&gt; pb_;</span></span><br><span class="line">    shared_ptr&lt;B&gt; pb_;</span><br><span class="line">    ~<span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A is deleted&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    shared_ptr&lt;A&gt; pa_;</span><br><span class="line">    ~<span class="title function_">B</span>(<span class="params"></span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B is deleted&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    shared_ptr&lt;A&gt; pa = make_shared&lt;A&gt;();</span><br><span class="line">    shared_ptr&lt;B&gt; pb = make_shared&lt;B&gt;();</span><br><span class="line">    cout &lt;&lt; pa.<span class="title function_">use_count</span>() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; pb.<span class="title function_">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    pa-&gt;pb_ = pb;</span><br><span class="line">    pb-&gt;pa_ = pa;</span><br><span class="line">    cout &lt;&lt; pa.<span class="title function_">use_count</span>() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; pb.<span class="title function_">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1  1</span><br><span class="line">2  2</span><br></pre></td></tr></table></figure>
<p>一开始  pa指向 A，因此 A的引用计数为1，当 pb的成员变量 pa_也指向 A时，A的引用计数变为 2。当函数结束运行时，智能指针 pa、pb析构会使其引用计数同时减 1，但此时结果仍然不是 0，而是 1，所以结束时资源没有被释放（未调用析构函数），这就是死锁问题。解决方式是，把 class A或 B中的成员变量 shared_ptr改为弱引用 weak_ptr，此时运行结果为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="number">1</span></span><br><span class="line"><span class="number">2</span>  <span class="number">1</span></span><br><span class="line">B is deleted</span><br><span class="line">A is deleted</span><br></pre></td></tr></table></figure>
<p>修改后 A的成员变量 pb_对 B的引用变为弱引用，因此 B的引用计数不会增加，一直都是 1，当 pb析构时，B的引用计数变为 0，B被释放。B的释放也会使 A的引用计数减 1，同时 pa析构时使 A的计数再次减 1，最终 A的计数为 0，A 也被释放：</p>
<img src="https://img.gejiba.com/images/0999217aac8ee3fee179053b9b3eefac.gif" data-original="https://wx3.sinaimg.cn/mw690/006ept9Hgy1gthohpi3fnj30bk07z3yj.jpg" alt="引用计数" style="zoom:60%;" />]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>智能指针</tag>
      </tags>
  </entry>
  <entry>
    <title>获取数组元素的物理地址范围</title>
    <url>/posts/3012990423.html</url>
    <content><![CDATA[<p>近期由于实验需要，编写了一个获取数组元素物理地址范围的小程序。</p>
<h2 id="1-获取trace"><a class="markdownIt-Anchor" href="#1-获取trace"></a> 1. 获取trace</h2>
<p>首先要对数组进行遍历，然后通过插桩工具获取到此 ROI 的物理地址。<br />
gem5 中自带的插桩工具是可以直接获取到物理地址的，如果要使用 pintool，需要额外实现从虚拟地址到物理地址的转换，具体方法我会在后面的博文中介绍。</p>
<h2 id="2-trace解码"><a class="markdownIt-Anchor" href="#2-trace解码"></a> 2. trace解码</h2>
<p>其次，需要将获取到的 trace 解码为一行一个物理地址的形式，地址采用十进制表示。如果使用 pintool，可以直接按此格式的 trace 输出到文件。这样做主要是为了配合此工具。</p>
<p>这里获取到的地址中有很多与数组元素无关的地址，比如对于一个大小为 20 的数组，获取到的 trace 多达 129 条，这显然不能满足我们的需求。</p>
<h2 id="3-地址提取"><a class="markdownIt-Anchor" href="#3-地址提取"></a> 3. 地址提取</h2>
<p>最后，使用如下代码来提取数组元素的物理地址。使用时需要指定文件路径以及数组元素类型所占的字节数（默认为 4 字节）。</p>
<p>这里主要利用了数组的物理地址空间连续的性质，或者更具体地说，是数组的局部物理地址连续，当数组庞大到没有完整的连续内存空间来供数组使用时，就会给其分配新的内存空间，因此整体上可能不连续，但局部一定是连续的。另外，在循环体中，每个数组元素只会被访问一次，因此 trace 中的物理地址一定不会重复出现。根据这两条性质，就可以提取到数组元素的物理地址。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include &lt;stdlib.<span class="property">h</span>&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">map&lt;int64_t, int64_t&gt; <span class="title function_">extract</span>(<span class="params">vector&lt;int64_t&gt; v, int type_size</span>) &#123;</span><br><span class="line">    map&lt;int64_t, int64_t&gt; addr;</span><br><span class="line">    int64_t start = v.<span class="title function_">front</span>();</span><br><span class="line">    int64_t prev = start;</span><br><span class="line">    int64_t elem_size = <span class="number">1</span>;</span><br><span class="line">    v.<span class="title function_">erase</span>(v.<span class="title function_">begin</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(auto i : v) &#123;</span><br><span class="line">        int64_t curr = i;</span><br><span class="line">        <span class="keyword">if</span>(prev + type_size == curr) &#123;</span><br><span class="line">            addr[start] = curr;</span><br><span class="line">            elem_size++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            start = curr;</span><br><span class="line">            <span class="keyword">if</span>(elem_size &gt; <span class="number">1</span>)</span><br><span class="line">                elem_size = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = curr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">mergePrint</span>(<span class="params">map&lt;int64_t, int64_t&gt; m, int type_size</span>) &#123;</span><br><span class="line">    int count = <span class="number">0</span>;</span><br><span class="line">    int64_t prev_start, prev_end, prev_size;</span><br><span class="line">    <span class="keyword">for</span>(auto i : m) &#123;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">            prev_start = i.<span class="property">first</span>;</span><br><span class="line">            prev_end = i.<span class="property">second</span>;</span><br><span class="line">            prev_size = (prev_end - prev_start) / type_size + <span class="number">1</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(prev_end + type_size == i.<span class="property">first</span>) &#123;</span><br><span class="line">                prev_end = i.<span class="property">second</span>;</span><br><span class="line">                prev_size += (i.<span class="property">second</span> - i.<span class="property">first</span>) / type_size + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cout &lt;&lt; prev_size &lt;&lt; <span class="string">&quot;\t[&quot;</span> &lt;&lt; prev_start &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; prev_end &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class="line">                prev_start = i.<span class="property">first</span>;</span><br><span class="line">                prev_end = i.<span class="property">second</span>;</span><br><span class="line">                prev_size = (prev_end - prev_start) / type_size + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; prev_size &lt;&lt; <span class="string">&quot;\t[&quot;</span> &lt;&lt; prev_start &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; prev_end &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params">int argc, char* argv[]</span>) &#123;</span><br><span class="line">    int type_size = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span> || argc &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Incorrect parameter nums!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(argc == <span class="number">3</span>)</span><br><span class="line">        type_size = <span class="title function_">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line">    string path = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    ifstream <span class="title function_">ifs</span>(path, <span class="attr">ios</span>::<span class="keyword">in</span>);</span><br><span class="line">    map&lt;int64_t, int64_t&gt; m;</span><br><span class="line">    map&lt;int64_t, int64_t&gt;::iterator pos;</span><br><span class="line">    string buffer;</span><br><span class="line">    <span class="keyword">while</span>(ifs &gt;&gt; buffer) &#123;</span><br><span class="line">        pos = m.<span class="title function_">find</span>(<span class="title function_">atol</span>(buffer.<span class="title function_">c_str</span>()));</span><br><span class="line">        <span class="keyword">if</span>(pos != m.<span class="title function_">end</span>())</span><br><span class="line">            pos-&gt;second++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            m.<span class="title function_">emplace</span>(<span class="title function_">atol</span>(buffer.<span class="title function_">c_str</span>()), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int64_t&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(pos = m.<span class="title function_">begin</span>(); pos != m.<span class="title function_">end</span>(); pos++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pos-&gt;second == <span class="number">0</span>)</span><br><span class="line">            v.<span class="title function_">push_back</span>(pos-&gt;first);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(v.<span class="title function_">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">mergePrint</span>(<span class="title function_">extract</span>(v, type_size), type_size);</span><br><span class="line"></span><br><span class="line">    ifs.<span class="title function_">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经验证，即使对于包含数千亿条地址的 trace，该工具依然可以很好地工作。</p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>物理地址 插桩</tag>
      </tags>
  </entry>
</search>
