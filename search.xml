<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android画面显示流程</title>
    <url>/posts/1916506233.html</url>
    <content><![CDATA[<p>本文将会介绍从 App 画出一帧画面到这帧画面被传送到屏幕进行显示的整个过程。这其中会涉及到一些硬件的基础知识，但这些硬件并不是本文关注的重点，介绍它们主要是为了跟软件层面关联起来，以便对 Android 的显示流程形成一个完整的认知体系。</p>
<p>先来简单介绍一下本文所涉及的硬件以及内核层中的几个概念。</p>
<h2 id="预备知识"><a class="markdownIt-Anchor" href="#预备知识"></a> 预备知识</h2>
<p><strong>ION</strong>：Android 流行的内存管理机制，处在内核空间。</p>
<p><strong>DRM</strong>：Direct Rendering Manager，直接渲染管理器，也在内核空间。提供了一组 API，用户空间程序可以通过它发送画面数据到 GPU，也可以使用它执行诸如配置分辨率、刷新率之类的设置操作。目前在高通平台手机 Android 系统上的显示系统也是使用的这组 API 来完成画面的渲染更新。</p>
<p>一个典型的 Android 显示系统一般包括以下三个部分：</p>
<ul>
<li><strong>SOC</strong>：负责绘画与多图层的合成，把合成好的数据传输给 DDIC。</li>
<li><strong>DDIC</strong>：负责把 Buffer 里的数据写到 <strong>GRAM</strong>（显示存储器）中。</li>
<li><strong>Panel</strong>：不断扫描 GRAM 以显示内容。</li>
</ul>
<h2 id="用户空间的帧数据流"><a class="markdownIt-Anchor" href="#用户空间的帧数据流"></a> 用户空间的帧数据流</h2>
<p>应用要绘制一个画面，首先要向 SurfaceFlinger（SF）申请一个画布，这个画布所使用的 Buffer 是 SF 通过 allocator service 分配的。allocator service 通过 ION 从内核中开辟一块内存出来作为共享内存，被 HWC Service 共享。其中每个图层都会申请一个独立的 Buffer，并由 SF 来控制这块 Buffer 的所有权，随着状态的不同，所有权会在 App、SF、HWC Service 之间流转。</p>
<p><img src="https://img.gejiba.com/images/c3ccd4dc0cc97fcea3e377b7f6bf0301.webp" alt="" /></p>
<p>HWC Service 会通过 DRM 与内核打交道，负责把 SF 传过来的图层进行合成，并将合成后的画面提交到 DRM 去显示。</p>
<p><strong>1. App到SurfaceFlinger</strong></p>
<p>应用首先通过 Surface 的接口向 SurfaceFlinger 申请一块 Buffer。需要说明的是，Surface 刚创建的时候是不会分配 Buffer 的，只有应用第一次绘画时调用 dequeueBuffer 才会让 SF 去申请 Buffer，然后在应用侧通过 importBuffer 把这块内存映射到应用的进程空间。</p>
<p>之后应用通过 dequeueBuffer 拿到画布，绘制好后再通过 queueBuffer 向 SF 提交数据。这个提交操作并不是把内存复制一份给 SF，而是把共享内存的控制权交还给 SF，SF 再把拿来的多个应用的共享内存送给 HWC 去合成。</p>
<p><strong>2. SurfaceFlinger到HWC</strong></p>
<p>HWC Service 负责将 SF 送来的图层做合成，形成最终的画面，然后通过 DRM 更新到屏幕上去。</p>
<p><strong>3. HWC到内核</strong></p>
<p>HWC Service 使用 libdrm 向 DRM 提交合成后的帧数据，最终调用的是 <code>drmModeAtomicCommit()</code> 接口，该接口又会通过系统函数 <code>ioctl()</code> 调用到内核去处理这些数据，完成 App 画面显示到屏幕的过程。</p>
<p>为了更有效地利用时间，这样的共享内存不止一份，因此就需要设计一个机制来管理这些 Buffer，这就是 BufferQueue。</p>
<h2 id="bufferqueue"><a class="markdownIt-Anchor" href="#bufferqueue"></a> BufferQueue</h2>
<p>BufferQueue 要解决的是生产者和消费者的同步问题：App 生产画面，SF 消费画面；SF 生产画面，HWC 消费画面。用来存储这些画面的存储区是 FrameBuffer，下面我们以 App 为生产者，SF 为消费者为例来了解一下 BufferQueue 的内部设计。</p>
<h3 id="bufferstate的切换"><a class="markdownIt-Anchor" href="#bufferstate的切换"></a> BufferState的切换</h3>
<p>在 BufferQueue 的设计中，一个 Buffer 的状态有以下几种：</p>
<p><strong>FREE</strong>：表示该 Buffer 可以被生产者 dequeue，此时 BufferSlot 的拥有者是 BufferQueue。当被 dequeue 之后它的状态会变成 DEQUEUED。</p>
<p><strong>DEQUEUED</strong>：表示该 Buffer 已经被生产者 dequeue，但还没有被 queue 或者 cancle，此时 BufferSlot 的拥有者是生产者。当被 queue 之后其状态会变为 QUEUED，或者被 cancle 之后会变为 FREE。</p>
<p><strong>QUEUED</strong>：表示该 Buffer 已经被生产者填充并且被 queue 到了 BufferQueue 中，此时 BufferSlot 的拥有者是 BufferQueue。当被 acquire 之后其状态会变为 ACQUIRED。</p>
<p><strong>ACQUIRED</strong>：表示该 Buffer 已经被消费者 acquire，此时 BufferSlot 的拥有者是消费者。当被 release 之后其状态会变为 FREE。</p>
<p><strong>SHARED</strong>：表示该 Buffer 正在共享模式中被使用。它可以同时处于除 FREE 外的任意状态的组合，也可以多次被 dequeue、queue 或者 acquire。</p>
<p>这里多次提到了 BufferSlot，那它究竟是什么呢？</p>
<h3 id="bufferslot"><a class="markdownIt-Anchor" href="#bufferslot"></a> BufferSlot</h3>
<p>每一个 App 的图层在 SF 里称为一个 Layer，而每个 Layer 都拥有一个独立的 BufferQueue，每个 BufferQueue 都有多个 Buffer。Android 系统上目前支持每个 Layer 最多 64 个 Buffer，每个 Buffer 用一个结构体 BufferSlot 来表示。</p>
<img src="https://img.gejiba.com/images/ffb559c74f0033cd5147341cd6f7f392.webp" alt="image-20220925171857831" style="zoom:50%;" />
<p>BufferSlot 中的一些重要成员如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/include/gui/BufferSlot.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BufferSlot</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    sp&lt;GraphicBuffer&gt; mGraphicBuffer; <span class="comment">// 指向为这个Slot分配的Buffer</span></span><br><span class="line">    BufferState mBufferState; <span class="comment">// BufferSlot的当前状态</span></span><br><span class="line">    <span class="type">uint64_t</span> mFrameNumber; <span class="comment">// 被queue的帧的编号，在按LRU顺序dequeue申请Buffer时会使用</span></span><br><span class="line">    sp&lt;Fence&gt; mFence; <span class="comment">// 后面再分析</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于这 64 个 BufferSlot，其分类如下：</p>
<p><img src="https://img.gejiba.com/images/d1b729b9f16996eb1b54626cf918c6cf.webp" alt="image-20220925173700870" /></p>
<p>处于 FREE状态的 Slot 根据是否已经为其分配过内存，可以分成两部分，如图所示。所以如果我们在代码中看到是从 mFreeSlots 里拿出一个 BufferSlot，那就说明这个 BufferSlot 还没有分配 GraphicBuffer，可能是第一次被使用到。</p>
<h3 id="bufferqueue构造"><a class="markdownIt-Anchor" href="#bufferqueue构造"></a> BufferQueue构造</h3>
<p>BufferQueue 的创建方法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/BufferQueue.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BufferQueue::createBufferQueue</span><span class="params">(sp&lt;IGraphicBufferProducer&gt;* outProducer, sp&lt;IGraphicBufferConsumer&gt;* outConsumer, <span class="type">bool</span> consumerIsSurfaceFlinger)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">sp&lt;BufferQueueCore&gt; <span class="title">core</span><span class="params">(<span class="keyword">new</span> BufferQueueCore())</span></span>;</span><br><span class="line">    <span class="function">sp&lt;IGraphicBufferProducer&gt; <span class="title">producer</span><span class="params">(<span class="keyword">new</span> BufferQueueProducer(core, consumerIsSurfaceFlinger))</span></span>;</span><br><span class="line">    <span class="function">sp&lt;IGraphicBufferConsumer&gt; <span class="title">consumer</span><span class="params">(<span class="keyword">new</span> BufferQueueConsumer(core))</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法会先创建 BufferQueueCore，然后再使用它分别去创建生产者 BufferQueueProducer 和消费者 BufferQueueConsumer。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/include/gui/BufferQueueCore.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferQueueCore</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase &#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">BufferQueueProducer</span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">BufferQueueConsumer</span>;  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// mSlots是一个BufferSlot数组，允许GraphicBuffer所有权在生产者和消费者之间不通过Binder转移</span></span><br><span class="line">    BufferQueueDefs::SlotsType mSlots;</span><br><span class="line">    <span class="comment">// mMaxDequeuedBufferCount是生产者一次可以dequeue的Buffer数</span></span><br><span class="line">    <span class="comment">// 默认为1，生产者可以通过setMaxDequeuedBufferCount()函数修改默认值</span></span><br><span class="line">    <span class="type">int</span> mMaxDequeuedBufferCount;</span><br><span class="line">    <span class="comment">// mQueue是一个用于同步模式的先进先出的Buffer队列</span></span><br><span class="line">    Fifo mQueue;  </span><br><span class="line">    <span class="comment">// mFreeSlots包含所有FREE且还没有分配Buffer的Slot</span></span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mFreeSlots;</span><br><span class="line">    <span class="comment">// mFreeBuffers包含所有FREE且已分配Buffer的Slot</span></span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; mFreeBuffers;</span><br><span class="line">    <span class="comment">// mUnusedSlots包含所有当前未使用的Slot，它们应该FREE且未分配Buffer</span></span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; mUnusedSlots;</span><br><span class="line">    <span class="comment">// mActiveBuffers包含所有非FREE状态的Slot</span></span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mActiveBuffers;  </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看一下<strong>应用上帧</strong>（应用提交绘制好的帧数据到 SF）时 SF 是如何管理分配这些 Slot 的。</p>
<h3 id="应用获取graphicbuffer"><a class="markdownIt-Anchor" href="#应用获取graphicbuffer"></a> 应用获取GraphicBuffer</h3>
<p>应用第一次 dequeueBuffer 前会通过 <code>connect()</code> 接口和 SurfaceFlinger 建立连接。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/Surface.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Surface::connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> api, <span class="type">const</span> sp&lt;IProducerListener&gt;&amp; listener, <span class="type">bool</span> reportBufferRemoval)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>(); <span class="comment">// 可以在systrace中看到</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 这里通过Binder调用和SurfaceFlinger建立连接</span></span><br><span class="line">    <span class="type">int</span> err = mGraphicBufferProducer-&gt;<span class="built_in">connect</span>(listener, api, mProducerControlledByApp, &amp;output);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用在第一次 <code>dequeueBuffer()</code> 时会调用 <code>requestBuffer()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/Surface.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Surface::dequeueBuffer</span><span class="params">(<span class="type">android_native_buffer_t</span>** buffer, <span class="type">int</span>* fenceFd)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>(); <span class="comment">// 可以在systrace中看到</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 这里尝试去dequeueBuffer，但因为第一次SF中对应Layer的Slot还没有分配Buffer</span></span><br><span class="line">    <span class="comment">// 所以SF回复的flag会带有BUFFER_NEEDS_REALLOCATION标识</span></span><br><span class="line">    <span class="type">status_t</span> result = mGraphicBufferProducer-&gt;<span class="built_in">dequeueBuffer</span>(&amp;buf, &amp;fence, dqInput.width, dqInput.height, dqInput.format, dqInput.usage, &amp;mBufferAge, dqInput.getTimestamps ? &amp;frameTimestamps : <span class="literal">nullptr</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ((result &amp; IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) || gbuf == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        result = mGraphicBufferProducer-&gt;<span class="built_in">requestBuffer</span>(buf, &amp;gbuf);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"> ...</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在 SF 端，第一次收到 <code>dequeueBuffer()</code> 时发现分配出来的 Slot 没有 GraphicBuffer，这时会去申请对应的 Buffer：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/BufferQueueProducer.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BufferQueueProducer::dequeueBuffer</span><span class="params">(<span class="type">int</span>* outSlot, sp&lt;android::Fence&gt;* outFence, <span class="type">uint32_t</span> width, <span class="type">uint32_t</span> height, PixelFormat format, <span class="type">uint64_t</span> usage, <span class="type">uint64_t</span>* outBufferAge, FrameEventHistoryDelta* outTimestamps)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ((buffer == <span class="literal">nullptr</span>) ||</span><br><span class="line">        buffer-&gt;<span class="built_in">needsReallocation</span>(width, height, format, BQ_LAYER_COUNT, usage)) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 发现需要分配Buffer，做个标记</span></span><br><span class="line">        returnFlags |= BUFFER_NEEDS_REALLOCATION;</span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (returnFlags &amp; BUFFER_NEEDS_REALLOCATION) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// new一个GraphicBuffer</span></span><br><span class="line">        sp&lt;GraphicBuffer&gt; graphicBuffer = <span class="keyword">new</span> <span class="built_in">GraphicBuffer</span>(width, height, format, BQ_LAYER_COUNT, usage, &#123;mConsumerName.<span class="built_in">string</span>(), mConsumerName.<span class="built_in">size</span>()&#125;);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 将新创建的GraphicBuffer给到对应的Slot</span></span><br><span class="line">        mSlots[*outSlot].mGraphicBuffer = graphicBuffer;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 此时返回给应用的flags仍然带有BUFFER_NEEDS_REALLOCATION标记</span></span><br><span class="line">    <span class="keyword">return</span> returnFlags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用侧收到带有 <code>BUFFER_NEEDS_REALLOCATION</code>  标记的返回结果后，会调用 <code>requestBuffer()</code> 来获取对应 Buffer 的信息：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/BufferQueueProducer.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BufferQueueProducer::requestBuffer</span><span class="params">(<span class="type">int</span> slot, sp&lt;GraphicBuffer&gt;* buf)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mSlots[slot].mRequestBufferCalled = <span class="literal">true</span>;</span><br><span class="line">    *buf = mSlots[slot].mGraphicBuffer;</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数的主要用作就是把 GraphicBuffer 传递到应用侧。</p>
<p>这里思考一个问题：既然 SF 在响应 <code>dequeueBuffer()</code> 时就已经为 Slot 创建了 GraphicBuffer，为什么还需要应用侧再次调用 <code>requestBuffer()</code> 时才会把 GraphicBuffer 传给应用？ 为什么 <code>dequeueBuffer()</code> 不直接返回呢？</p>
<p>要回答这个问题，我们需要看下应用侧接口 <code>dequeueBuffer()</code> 函数的设计：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/include/gui/IGraphicBufferProducer.h</span></span><br><span class="line">virtual <span class="type">status_t</span> <span class="title function_">dequeueBuffer</span><span class="params">(<span class="type">int</span>* slot, sp&lt;Fence&gt;* fence, <span class="type">uint32_t</span> w, <span class="type">uint32_t</span> h, PixelFormat format, <span class="type">uint64_t</span> usage, <span class="type">uint64_t</span>* outBufferAge, FrameEventHistoryDelta* outTimestamps)</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>注意第一个参数只是返回一个 int 指针，它表示的是 64 个 Slot 里的某一个 Slot，并不对应为其分配的 GraphicBuffer 信息，并且其他参数里也不会返回这个 Slot 所对应的 GraphicBuffer 的信息。但在应用侧拿到这个 Slot 之后，还需拿到确确实实的 GraphicBuffer 才能把共享内存 mmap 到自已的进程空间，才能在上面绘画，而显然这个接口的设计并不会带来 GraphicBuffer 的信息。</p>
<p>那设计之初为什么不把这个信息放进来呢？ 因为这个接口调用太频繁了，比如在 90 fps 的设备上，一秒钟该接口要执行 90 次，但这个信息只需要传递一次就可以了，如果每次这个接口都要带上 GraphicBuffer 的信息，就会传输很多冗余的数据，所以不如加入一个新的 API，即 <code>requestBuffer()</code> 来完成 GraphicBuffer 传递的事情。</p>
<p>应用侧在 <code>requestBuffer()</code> 后会拿到 GraphicBuffer 的信息，然后会通过 <code>importBuffer()</code> 在本进程内通过 Binder 传过来的 Parcel 包把 GraphicBuffer 重建出来：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/ui/GraphicBuffer.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">GraphicBuffer::unflatten</span><span class="params">(<span class="type">void</span> <span class="type">const</span>*&amp; buffer, <span class="type">size_t</span>&amp; size, <span class="type">int</span> <span class="type">const</span>*&amp; fds,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">size_t</span>&amp; count)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取从SurfaceFlinger传过来的Buffer</span></span><br><span class="line">    <span class="type">status_t</span> err = mBufferMapper.<span class="built_in">importBuffer</span>(handle, <span class="built_in">uint32_t</span>(width), <span class="built_in">uint32_t</span>(height), <span class="built_in">uint32_t</span>(layerCount), format, usage, <span class="built_in">uint32_t</span>(stride), &amp;importedHandle);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="buffer管理"><a class="markdownIt-Anchor" href="#buffer管理"></a> Buffer管理</h3>
<p><a href="#BufferSlot">前面</a> 提到了每个 Layer 都有最多 64 个 BufferSlot，但不是每个 Layer 都能用到这么多。每个 Layer 最多可用多少个 Buffer 是在这里设置的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/BufferQueueLayer.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BufferQueueLayer::onFirstRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// BufferQueueCore::mMaxDequeuedBufferCount默认是1</span></span><br><span class="line">    <span class="comment">// 当这里设为2时表示生产者一次可以dequeue的Buffer数为3，因为在BufferQueueCore那里会+1</span></span><br><span class="line">    mProducer-&gt;<span class="built_in">setMaxDequeuedBufferCount</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 App 侧看，前三帧都会有 requestBuffer 和 importBuffer，在第四帧时就没有了，因为我们当前系统一共使用了 3 个 Buffer。也就是说，应用所使用的画布是在前三帧被分配出来的，从第四帧开始进入稳定上帧期，这时会重复循环利用前三次分配的 Buffer。</p>
<p>看一下 BufferSlot 管理的场景：</p>
<p><img src="https://img.gejiba.com/images/b3cdbe68645fb6318967137011253082.webp" alt="" /></p>
<p><strong>Time 1</strong>：如图所示，初始状态下有 0、1、2 三个 BufferSlot，由于它们没有分配过 GraphicBuffer，所以都在 mFreeSlots 列表中。当应用 dequeueBuffer 时，SF 会先检查在 mFreeBuffers 队列中是否有 Slot，如果有则直接分配给应用。而显然此时 mFreeBuffers 是空的，这时 SF 会去 mFreeSlots 里找出第一个 Slot，也就是 0 号 Slot，所以在 dequeueBuffer 结束时应用就拿到了 0 号 Slot 的使用权，于此同时 SF 也会为 0 号 Slot 分配 GraphicBuffer，之后应用将通过 requestBuffer 和 importBuffer 来获取到该 Slot 的实际内存空间。</p>
<p>应用 dequeueBuffer 之后 0 号 Slot 切换到 DEQUEUED 状态，并被放入 mActiveBuffers 列表。</p>
<p><strong>Time 2</strong>：应用完成绘制后通过 queueBuffer 来提交绘制好的画面，完成后 0 号 Slot 状态变为 QUEUED 状态，（从 mActiveBuffers 取出）放入 mQueue 队列，此时 1、2 号 Slot 还停留在 mFreeSlots 队列中。（**图中每个 Time 中每种颜色的 Buffer 都只会有一个！**这里有两个 0 号 Buffer 只是将两步合并了）</p>
<p><strong>Time 3</strong>：上面这个状态会一直持续到下一个 Vsync-sf 信号到来。当 Vsync-sf 信号到来时，SF 主线程会检查 mQueue 队列中是否有 Slot，有就意味着有应用上帧。这时它会通过 acquireBuffer 把该 Slot（0 号 Slot）从 mQueue 中取出放入 mActiveBuffers 中，并将 Slot 的状态切换到 ACQUIRED，代表这个 Slot 已经被拿去做画面合成。</p>
<p><strong>Time 4</strong>：接下来应用继续调用 dequeueBuffer 申请 buffer，此时 0 号 Slot 在 mActiveBuffers 里，1、2 号在 mFreeSlots 里，SF 仍然是先检查 mFreeBuffers 里有没有 Slot，再检查 mFreeSlots，于是取出了 1 号 Slot 给到应用侧，同时 1 号 Slot 状态切换到 DEQUEUED 状态， 放入 mActiveBuffers 里。</p>
<p><strong>Time 5</strong>：1 号 Slot 应用绘画完毕，通过 queueBuffer 提交上来，这时 1 号 Slot 状态由 DEQUEUED 状态切换到了 QUEUED 状态，进入 mQueue 队列，之后将维持该状态直到下一个 Vsync-sf 信号到来。</p>
<p><strong>Time 6</strong>：此时 Vsync-sf 信号到来，发现 mQueue 中有个 Slot 1，这时 SF 主线程会把它取出，然后把状态切换到 ACQUIRED，并放入 mActiveBuffers 里。</p>
<p><strong>Time 7</strong>：这时 0 号 Slot 已经被 HWC Service 使用完毕，通过 releaseBuffer 还了回来，0 号 Slot 的状态将从 ACQUIRED 切换回 FREE，SF 会把它从 mActivieBuffers 里拿出来放入 mFreeBuffers 里。注意这时放入的是 mFreeBuffers 而不是 mFreeSlots ，因为此时 0 号 Slot 是有 GraphicBuffer 的。</p>
<p>在上述过程中，SF 收到应用 dequeueBuffer 请求时处在 FREE 状态的 Slot 都还没有分配过 GraphicBuffer。这通常发生在一个 Surface 的前几帧时间内，如在三个 Buffer 时的前三帧。之后的 mFreeBuffers 里已经有了 Slot，继续看下此时申请 Buffer 的情况：</p>
<p><img src="https://img.gejiba.com/images/6563fdf526783a7007d9fc10e53d52ff.webp" alt="" /></p>
<p><strong>Time 11</strong>：当下的状态是 0、1 两个 Slot 都在 mFreeBuffers 中，2 号 Slot 在 mActiveBuffers 中，这时应用过来 dequeueBuffer。</p>
<p><strong>Time 12</strong>：SF 仍然会先查看 mFreeBuffers，发现 0 号可用，于是该 Slot 的状态由 FREE 切换到 DEQUEUED 状态，并被放入 mActiveBuffers 中。</p>
<p><strong>Time 13</strong>：应用对 0 号 Slot 的绘图完成后通过 queueBuffer 提交绘制好的画面，这时状态从 DEQUEUED 切换到 QUEUED，0 号 Slot 被放入 mQueue 队列中，之后会维持该状态直到下一个 Vsync-sf 信号到来。</p>
<p><strong>Time 14</strong>：这时 Vsync-sf 信号到来，SF 主线程中检查 mQueue 队列中是否有 Slot，发现有 0 号 Slot，于是放入 mActiveBuffers 中，并通过 aquireBuffer 将其状态切换到 ACQUIRED，代表这个 Slot 已经被拿去做画面合成。</p>
<p>这个过程中应用申请 Buffer 时已经有处于 FREE 状态的 Slot 是分配过 GraphicBuffer 的，这种情况多发生在 Surface 的稳定上帧期。</p>
<p>再来关注一下 acquireBuffer 和 releaseBuffer 的过程：</p>
<p><img src="https://img.gejiba.com/images/e1509e9dd23678529a6b08491f41723f.webp" alt="" /></p>
<p><strong>Time 23</strong>：当前 mQueue 中有两个 Buffer。</p>
<p><strong>Time 24</strong>：Vsync-sf 信号到达，SF 通过 acquireBuffer 从 mQueue 队列取走 0 号 Slot。</p>
<p><strong>Time 25</strong>：再一次 Vsync-sf 到来，这时 SF 会先查看 mQueue 中是否有 Buffer，发现有 2 号 Slot，于是通过 acquireBuffer 取走 2 号 Slot。</p>
<p><strong>Time 26</strong>：此时 0 号 Slot 已经被 HWC Service 使用完毕，通过 releaseBuffer 把 Slot 还了回来，0 号 Slot 在此刻进入 mFreeBuffers。</p>
<p>这里需要注意两个时序：</p>
<ul>
<li><strong>每次 Vsync-sf 信号到来时总是先查看 mQueue 队列看是否有 Layer 上帧，然后才会走到 releaseBuffer 把 HWC Service 使用完的 Slot 回收回来。</strong></li>
<li><strong>本次 Vsync-sf 被 aquireBuffer 取走的 Slot 总是会在下一个 Vsync-sf 时才会被 release 回来。</strong></li>
</ul>
<p>由上述过程不难看出，如果应用上帧速度较慢，比如其上帧周期时长大于两倍屏幕刷新周期时，每次应用来 dequeueBuffer 时前一次 queueBuffer 的 BufferSlot 都已经被 release 回来了，这时总会在 mFreeBuffers 里找到可用的，那么就不需要三个 Slot 都分配出 GraphicBuffer。</p>
<p>releaseBuffer 是在 postComposition 里调用的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::postComposition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; layer: mLayersWithQueuedFrames) &#123;</span><br><span class="line">        ...</span><br><span class="line">        layer-&gt;<span class="built_in">releasePendingBuffer</span>(<span class="comment">/*dequeueReadyTime*/</span> now);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要主线程执行到这个 <code>postComposition()</code> 函数就一定会让集合中的 layer 去执行 <code>releasePendingBuffer()</code>，该函数会调用到 <code>releaseBuffer()</code>。</p>
<p>mLayersWithQueuedFrames 里的 Layer 是在这里被加入进来的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SurfaceFlinger::latchBuffers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mDrawingState.<span class="built_in">traverse</span>([&amp;](Layer* layer) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;<span class="built_in">hasReadyFrame</span>()) &#123;</span><br><span class="line">            ...</span><br><span class="line">            mLayersWithQueuedFrames.<span class="built_in">emplace</span>(layer);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Layer 的 <code>releasePendingBuffer()</code> 里会把对应的 Slot 的状态切换为 FREE，之后该 Slot 是很可能被应用通过 <code>dequeueBuffer()</code> 获取到的。那么怎么能确定 Buffer 已经被 HWC Service 使用完了呢？如果 HWC Service 还没使用完，而应用却申请到了这个 Buffer，那 Buffer 中的数据极有可能会出错。该怎么解决这个问题呢？这就要靠 Fence 了，这个我们稍后再来介绍。</p>
<p>我们再从帧数据更新的流程上来看下 BufferSlot 的管理，从 Systrace（屏幕刷新率为 90 Hz）上可以观察到的应用上帧的全景图：</p>
<p><img src="https://img.gejiba.com/images/2c9a66e0ffc67b0447374b9c799ade34.webp" alt="" /></p>
<p>这里是以一个 SurfaceView（自主）上帧为例：</p>
<ul>
<li>
<p>首先应用通过 dequeueBuffer 拿到了 BufferSlot 0，开始第 1 步绘图；</p>
</li>
<li>
<p>绘图完成后通过 queueBuffer 将 Slot 0 提交到 SF，下一个 Vsync-sf 信号到达后，开始第 2 步图层处理；</p>
</li>
<li>
<p>这时 SF 通过 aquireBuffer 把 Slot 0 拿去给到 HWC Service，与此同时进入第 3 步；</p>
</li>
<li>
<p>HWC Service 开始对多个图层做合成，合成后通知 DRM 模块传输给 DDIC，Panel 再把图像显示到屏幕。</p>
</li>
</ul>
<h3 id="代码接口"><a class="markdownIt-Anchor" href="#代码接口"></a> 代码接口</h3>
<p>以 App 为生产者、SF 为消费者为例，BufferQueue 的 Slot 管理核心代码由 BufferQueueCore、BufferQueueProducer 和 BufferQueueConsumer 组成。生产者这边还有一个 Surface，它是应用侧操作 BufferQueue 的接口。Android 规定，BufferQueue 的 Buffer 必须在 Consumer 侧分配，因此 BufferQueue 的核心 Slot 管理代码是在 SF 进程中执行的。它们之间的关系如下：</p>
<p><img src="https://img.gejiba.com/images/825eebf6745858ef87f844d2bc696828.webp" alt="" /></p>
<p>IGraphicBufferProducer 规定了 BufferQueue 向生产者提供的接口有哪些，比如请求 Buffer 用到的 dequeueBuffer、提交 Buffer 用到的 queueBuffer 等等。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/include/gui/IGraphicBufferProducer.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IGraphicBufferProducer</span> : <span class="keyword">public</span> IInterface &#123;</span><br><span class="line">    <span class="comment">// connect会将客户端API与IGraphicBufferProducer建立连接</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">connect</span><span class="params">(<span class="type">const</span> sp&lt;IProducerListener&gt;&amp; listener, <span class="type">int</span> api, <span class="type">bool</span> producerControlledByApp, QueueBufferOutput* output)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">requestBuffer</span><span class="params">(<span class="type">int</span> slot, sp&lt;GraphicBuffer&gt;* buf)</span> </span>= <span class="number">0</span>; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">dequeueBuffer</span><span class="params">(<span class="type">int</span>* slot, sp&lt;Fence&gt;* fence, <span class="type">uint32_t</span> w, <span class="type">uint32_t</span> h, PixelFormat format, <span class="type">uint64_t</span> usage, <span class="type">uint64_t</span>* outBufferAge, FrameEventHistoryDelta* outTimestamps)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">queueBuffer</span><span class="params">(<span class="type">int</span> slot, <span class="type">const</span> QueueBufferInput&amp; input, QueueBufferOutput* output)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// disconnect会断开客户端API与IGraphicBufferProducer的连接</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">disconnect</span><span class="params">(<span class="type">int</span> api, DisconnectMode mode = DisconnectMode::Api)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>connect()</code> 接口在开始上帧前调用一次，主要用来让生产者和消费者沟通一些参数，比如 API 版本、Buffer 的大小和个数等。</p>
<p><code>disconnect()</code> 用于在生产者不再生产时断开连接，以通知消费端清理一些资源。</p>
<p>IGraphicBufferConsumer 则规定了 BufferQueue 向消费者提供的接口有哪些，比如从 mQueue 队列中取出 Buffer、归还 Buffer 到 BufferQueue 等等。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/include/gui/IGraphicBufferConsumer.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IGraphicBufferConsumer</span> : <span class="keyword">public</span> IInterface &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">acquireBuffer</span><span class="params">(BufferItem* buffer, <span class="type">nsecs_t</span> presentWhen, <span class="type">uint64_t</span> maxFrameNumber = <span class="number">0</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">releaseBuffer</span><span class="params">(<span class="type">int</span> buf, <span class="type">uint64_t</span> frameNumber, EGLDisplay display, EGLSyncKHR fence, <span class="type">const</span> sp&lt;Fence&gt;&amp; releaseFence)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3>
<p>用一张图来总结一下在 Triple Buffer 下应用连续上帧过程中三个 Buffer 的使用情况，以及在此过程中应用和 SF 是如何配合的：</p>
<p><img src="https://img.gejiba.com/images/e2e2adf29bd3187d48bf4c994014188e.webp" alt="" /></p>
<p>应用在每个 Vsync 信号到来后都会通过 dequeueBuffer/queueBuffer 来申请 Buffer 和提交绘图数据；</p>
<p>SF 会在 Vsync 信号到来时取走 Buffer 去做合成和显示， 并在下一个 Vsync 到来时归还 Buffer。如此循环。</p>
<h2 id="fence"><a class="markdownIt-Anchor" href="#fence"></a> Fence</h2>
<p>Fence 是内核提供的不同硬件之间的同步机制，在用户空间我们可以将它视为一把锁，它代表了某个硬件对共享资源的占用情况。</p>
<h3 id="为什么要有fence"><a class="markdownIt-Anchor" href="#为什么要有fence"></a> 为什么要有Fence</h3>
<p>一般凡是共享的资源都要建立一个同步机制来管理。比如在多线程编程中对临界资源通过加锁实现互斥访问，BufferQueue 中 SF 和应用对共享内存（帧缓冲）的访问中有 BufferState 来标识共享内存控制权的方法来做同步。没有同步机制的无序访问极可能造成数据混乱。</p>
<p>BufferState 的方式只是解决了在 CPU 管理之下，当下共享内存的控制权归属问题。当共享资源是在两个硬件中时，情况就不同了。比如当一个帧缓冲区共享内存给到 GPU 时，GPU 并不清楚 CPU 还有没有在使用它；同样地，当 GPU 在使用共享内存时，CPU 也不清楚 GPU 是否已使用完毕。</p>
<blockquote>
<p>以 CPU 调用 OpenGL 函数进行绘图为例：首先 CPU 侧调用 <code>glClear()</code> 清空画布，再调用 <code>glXXX()</code> 绘制各种画面。对于 CPU 来说，在 <code>glXXX()</code> 执行完毕后，它的绘图工作已经完成了，但其实 <code>glXXX()</code> 的具体工作是由 GPU 来完成的，CPU 侧的 <code>glXXX()</code> 只是在向 GPU 传达任务而已。任务传达完并不意味着任务已经完成了，真正的任务完成是要等 GPU 做完 <code>glXXX()</code> 所对应的工作。</p>
<p>从 CPU 下达完任务到 GPU 完成任务之间存在时差，这个时差受 GPU 工作频率的影响，并且不是一个定值。在 OpenGL 的语境中，CPU 可以通过 <code>glFilish()</code> 来等待 GPU 完成所有工作，但这显然浪费了 CPU 本可以并行工作的时间。</p>
<p>在本例中，CPU 下达了要在画布上绘画的指令给 GPU，而 GPU 什么时候画完是不确定的。这里的画布就是共享资源，CPU 和 GPU 的工作完全是异步的。Fence 提供了一种方式来处理不同硬件对共享资源的访问控制。</p>
</blockquote>
<p>我们可以这样理解 Fence 的工作原理：</p>
<p>Fence 是一个内核 Driver，对一个 Fence 对象的操作有两种：signal 和 wait。当生产者（App）向 GPU 下达完很多绘图指令后 GPU 开始工作，这时 CPU 就认为绘图工作已经完成了。之后把创建的 Fence 对象通过 Binder 通知给消费者（SF）。消费者收到通知后，并不知道 GPU 是否已经绘图完毕，即 GPU 是否已对共享资源访问完毕，于是先通过 Fence 对象的 wait 方法等待，直到 GPU 绘图完成后调用 Fence 的 signal 方法， 才会从 wait 中跳出。这个 signal 是由内核 Driver 来完成的。有了 Fence 的情况下，CPU 在完成自已的工作后就可以继续做其他事情，到了真正要使用共享资源时再通过 Fence wait 来和 GPU 同步，尽最大可能做到了让不同硬件并行工作。</p>
<h3 id="与bufferqueue的协作方式"><a class="markdownIt-Anchor" href="#与bufferqueue的协作方式"></a> 与BufferQueue的协作方式</h3>
<p>以 App（生产者）和 SF（消费者）间的交互来看下 Fence 在其中的作用：</p>
<p><img src="https://img.gejiba.com/images/2e4f2033e4b51e2d94ba75fdbe1f3ae2.webp" alt="" /></p>
<p>首先 App 通过 dequeueBuffer 获得某一 Slot 的使用权，这时 Slot 的状态切换为 DEQUEUED。随着 dequeueBuffer 返回的还有一个 releaseFence 对象，此时 releaseFence 还没有 signal， 这意味着虽然在 CPU 这边已经拿到了 Buffer 的使用权，但别的硬件还在使用这个 Buffer。因此 GPU 还不能直接在上面绘画，它要等 releaseFence 收到 signal 信号后才可以绘画。</p>
<p>releaseFence 收到 signal 信号之后，我们假设 GPU 工作时间较长，在它完成之前 CPU 侧 APP 已经完成了 queueBuffer 动作，这时 Slot 的状态已切换为 QUEUED，并且下一个 vsync 已经到来，Slot 状态变为 ACQUIRED。这在 CPU 侧代表该 Buffer 给 HWC 去合成了，但这时 HWC 还不能去读里面的数据，它还需要等待 acauireFence 的 signal 信号，只有等到该信号才代表 GPU 的绘画工作真正做完了。</p>
<p>acauireFence 收到 signal 信号之后，HWC 就可以去读帧缓冲区的数据，完成图层的合成工作。</p>
<p>同样地，当 SF 执行到 releaseBuffer 时，并不能代表 HWC 已经完成合成工作了，但这不妨碍 releaseBuffer 流程继续执行。虽然 HWC 还在使用缓冲区做合成，但帧缓冲区的 Slot 有可能已经被应用申请走变成 DEQUEUED 状态了。 这意味着虽然在 CPU 这边已经拿到了 Buffer 的使用权，但别的硬件还在使用这个 Buffer。因此 GPU 还不能直接在上面绘画，它要等 releaseFence 收到 signal 信号后才可以绘画。</p>
<h4 id="相关代码"><a class="markdownIt-Anchor" href="#相关代码"></a> 相关代码</h4>
<p>应用侧申请 Buffer 的同时会获取到一个 Fence 对象（releaseFence）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/Surface.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Surface::dequeueBuffer</span><span class="params">(<span class="type">android_native_buffer_t</span>** buffer, <span class="type">int</span>* fenceFd)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    sp&lt;Fence&gt; fence;</span><br><span class="line">    <span class="type">status_t</span> result = mGraphicBufferProducer-&gt;<span class="built_in">dequeueBuffer</span>(&amp;buf, &amp;fence, dqInput.width, dqInput.height, dqInput.format, dqInput.usage, &amp;mBufferAge, dqInput.getTimestamps ? &amp;frameTimestamps : <span class="literal">nullptr</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SF 侧去读取 Slot 中的 Fence 对象并返回给应用侧：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/BufferQueueProducer.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BufferQueueProducer::dequeueBuffer</span><span class="params">(<span class="type">int</span>* outSlot, sp&lt;android::Fence&gt;* outFence, <span class="type">uint32_t</span> width, <span class="type">uint32_t</span> height, PixelFormat format, <span class="type">uint64_t</span> usage, <span class="type">uint64_t</span>* outBufferAge, FrameEventHistoryDelta* outTimestamps)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 把Slot里记录的mFence对象返回出去，就是应用侧拿到的releaseFence</span></span><br><span class="line">    *outFence = (mCore-&gt;mSharedBufferMode &amp;&amp; mCore-&gt;mSharedBufferSlot == found) ? Fence::NO_FENCE : mSlots[found].mFence;</span><br><span class="line">    mSlots[found].mEglFence = EGL_NO_SYNC_KHR;</span><br><span class="line">    mSlots[found].mFence = Fence::NO_FENCE;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用侧上帧时要创建一个 Fence 对象（acquireFence）来代表 GPU 的功能还在进行中，并在提交 Buffer 的同时把 Fence 对象传给 SF：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/Surface.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Surface::queueBuffer</span><span class="params">(<span class="type">android_native_buffer_t</span>* buffer, <span class="type">int</span> fenceFd)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    IGraphicBufferProducer::QueueBufferInput input;</span><br><span class="line">    <span class="built_in">getQueueBufferInputLocked</span>(buffer, fenceFd, mTimestamp, &amp;input);</span><br><span class="line">    <span class="type">status_t</span> err = mGraphicBufferProducer-&gt;<span class="built_in">queueBuffer</span>(i, input, &amp;output);</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Surface::getQueueBufferInputLocked</span><span class="params">(<span class="type">android_native_buffer_t</span>* buffer, <span class="type">int</span> fenceFd,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">nsecs_t</span> timestamp, IGraphicBufferProducer::QueueBufferInput* out)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">sp&lt;Fence&gt; <span class="title">fence</span><span class="params">(fenceFd &gt;= <span class="number">0</span> ? <span class="keyword">new</span> Fence(fenceFd) : Fence::NO_FENCE)</span></span>;</span><br><span class="line">    <span class="function">IGraphicBufferProducer::QueueBufferInput <span class="title">input</span><span class="params">(timestamp, isAutoTimestamp, <span class="keyword">static_cast</span>&lt;android_dataspace&gt;(mDataSpace), crop, mScalingMode, mTransform ^ mStickyTransform, fence, mStickyTransform, mEnableFrameTimestamps)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先通过 <code>getQueueBufferInputLocked()</code> 创建 Fence 对象（13 行），再将其放入 input 参数中（14 行）并返回到 <code>queueBuffer()</code>（4 行），最后将包含了这个 Fence 对象的 input 传给 SF（6 行）。</p>
<p>SF 侧从 Binder 中获取应用侧传来的 Fence 对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/BufferQueueProducer.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BufferQueueProducer::queueBuffer</span><span class="params">(<span class="type">int</span> slot, <span class="type">const</span> QueueBufferInput &amp;input, QueueBufferOutput *output)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    sp&lt;Fence&gt; acquireFence;</span><br><span class="line">    input.<span class="built_in">deflate</span>(&amp;requestedPresentTimestamp, &amp;isAutoTimestamp, &amp;dataSpace, &amp;crop, &amp;scalingMode, &amp;transform, &amp;acquireFence, &amp;stickyTransform, &amp;getFrameTimestamps);</span><br><span class="line">    ...</span><br><span class="line">    mSlots[slot].mFence = acquireFence; <span class="comment">// 将Slot中的mFence置位acquireFence</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过 systrace 观察一个因 GPU 工作时间太长，从而让 DRM 工作线程卡在等 Fence 的情况：</p>
<p><img src="https://img.gejiba.com/images/25bbb4caed4025625e9e958270b6fc97.webp" alt="" /></p>
<p>如上图所示，complete_commit 函数执行时前面有一段时间陷于等待状态了。那它在等谁呢？从图中我们可以看出它在等 73026 号 fence 的 signal 信号。这种情况说明 DRM 内部的 dma 要去读这 miHoYo.yuanshen 这个应用的 Buffer 时发现应用的 GPU 还没有把画面画完，因此不得不等它画完才能开始读取。但既然都已经送到 crtc_commit（图中左上角）了，至少在 CPU 这侧，该 Slot 的 BufferState 已经是 ACQUIRED 状态了。</p>
<h2 id="画面更新流程"><a class="markdownIt-Anchor" href="#画面更新流程"></a> 画面更新流程</h2>
<p>在前面的介绍中，我们从最底层的显示硬件到 APP 与 SF、HWC service 三者的关系，了解了帧数据流动所经过的关键节点，并重点讨论了帧 Buffer 是如何管理的，以及在流动过程中不同硬件之间是如何同步的。接下来我们从应用侧角度从上到下看一下应用所绘制的画面是如何使用到我们上面所设计的流程的。</p>
<h3 id="画布的申请"><a class="markdownIt-Anchor" href="#画布的申请"></a> 画布的申请</h3>
<p>应用侧对图层的操作是以 Surface 为接口的，它包含了一些更新画面相关的核心 API：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/include/gui/Surface.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Surface</span> : <span class="keyword">public</span> ANativeObjectBase&lt;ANativeWindow, Surface, RefBase&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">dequeueBuffer</span><span class="params">(ANativeWindowBuffer** buffer, <span class="type">int</span>* fenceFd)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">cancelBuffer</span><span class="params">(ANativeWindowBuffer* buffer, <span class="type">int</span> fenceFd)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">queueBuffer</span><span class="params">(ANativeWindowBuffer* buffer, <span class="type">int</span> fenceFd)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">perform</span><span class="params">(<span class="type">int</span> operation, va_list args)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">disconnect</span><span class="params">(<span class="type">int</span> api, IGraphicBufferProducer::DisconnectMode mode = IGraphicBufferProducer::DisconnectMode::Api)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用要想画出它的画面，首要解决的问题就是 <strong>应用侧的 Surface 对象如何创建，以及如何与 SF 建立联系</strong>。下面我们将从代码中寻找问题的答案。</p>
<p>在 Android 系统中每个 Activity 都有一个独立的画布（在应用侧称为 Surface，在 SF 侧称为 Layer），Activity 中的各种 View 就是画在了这块画布上。当然也有一个例外，SurfaceView 拥有自已独立的画布，但这里我们先只讨论 Activity 画布的创建过程。</p>
<p>首先每个应用都会创建自已的 Activity，进而 Android 会为 Activity 创建一个 ViewRootImpl，并调用到它的 <code>performTraversals()</code> 这个函数。该函数里会调用到 <code>relayoutWindow()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/view/ViewRootImpl.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">relayoutWindow</span><span class="params">(WindowManager.LayoutParams params, <span class="type">int</span> viewVisibility, <span class="type">boolean</span> insetsPending)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    ...</span><br><span class="line">    relayoutResult = mWindowSession.relayout(mWindow, params, requestedWidth, requestedHeight, viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : <span class="number">0</span>, mTmpFrames, mPendingMergedConfiguration, mSurfaceControl, mTempInsets, mTempControls, mRelayoutBundle);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mSurfaceControl.isValid()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!useBLAST()) &#123;</span><br><span class="line">            mSurface.copyFrom(mSurfaceControl);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>relayoutWindow()</code> 会通过 WindowSession 跨进程调用到 WMS 的 <code>relayout()</code> 函数，mWindowSession 可以看作是 WMS 在应用侧的代表。之后程序会进入到 WMS 所在的 system_server 进程，执行其 <code>relayoutWindow()</code> 函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">relayoutWindow</span><span class="params">(Session session, IWindow client, LayoutParams attrs,</span></span><br><span class="line"><span class="params">         <span class="type">int</span> requestedWidth, <span class="type">int</span> requestedHeight, <span class="type">int</span> viewVisibility, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">         ClientWindowFrames outFrames, MergedConfiguration mergedConfiguration,</span></span><br><span class="line"><span class="params">         SurfaceControl outSurfaceControl, InsetsState outInsetsState,</span></span><br><span class="line"><span class="params">         InsetsSourceControl[] outActiveControls, Bundle outSyncIdBundle)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    result = createSurfaceControl(outSurfaceControl, result, win, winAnimator);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数会通过 <code>createSurfaceControl()</code> 去创建一个 SurfaceControl 对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">createSurfaceControl</span><span class="params">(SurfaceControl outSurfaceControl, <span class="type">int</span> result, WindowState win, WindowStateAnimator winAnimator)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    surfaceController = winAnimator.createSurfaceLocked();</span><br><span class="line">    ...</span><br><span class="line">    surfaceController.getSurfaceControl(outSurfaceControl);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 SurfaceControl 的创建工作是由 WindowStateAnimator 完成的，并且在创建完成之后会通过 <strong>outSurfaceControl</strong> 传出去。这里分别看一下这两个方法：</p>
<h4 id="createsurfacelocked"><a class="markdownIt-Anchor" href="#createsurfacelocked"></a> createSurfaceLocked()</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/wm/WindowStateAnimator.java</span></span><br><span class="line">WindowSurfaceController <span class="title function_">createSurfaceLocked</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    mSurfaceController = <span class="keyword">new</span> <span class="title class_">WindowSurfaceController</span>(attrs.getTitle().toString(), format, flags, <span class="built_in">this</span>, attrs.type);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法创建了一个 WindowSurfaceController 对象，进而再去创建 SurfaceControl 对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/wm/WindowSurfaceController.java</span></span><br><span class="line">WindowSurfaceController(String name, <span class="type">int</span> format, <span class="type">int</span> flags, WindowStateAnimator animator, <span class="type">int</span> windowType) &#123;</span><br><span class="line">    ...</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, <span class="string">&quot;new SurfaceControl&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> SurfaceControl.<span class="type">Builder</span> <span class="variable">b</span> <span class="operator">=</span> win.makeSurface()</span><br><span class="line">        .setParent(win.getSurfaceControl())</span><br><span class="line">        .setName(name)</span><br><span class="line">        .setFormat(format)</span><br><span class="line">        .setFlags(flags)</span><br><span class="line">        .setMetadata(METADATA_WINDOW_TYPE, windowType)</span><br><span class="line">        .setMetadata(METADATA_OWNER_UID, mWindowSession.mUid)</span><br><span class="line">        .setMetadata(METADATA_OWNER_PID, mWindowSession.mPid)</span><br><span class="line">        .setCallsite(<span class="string">&quot;WindowSurfaceController&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一下 SurfaceControl 对象的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/view/SurfaceControl.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">SurfaceControl</span><span class="params">(SurfaceSession session, String name, <span class="type">int</span> w, <span class="type">int</span> h, <span class="type">int</span> format, <span class="type">int</span> flags, SurfaceControl parent, SparseIntArray metadata, WeakReference&lt;View&gt; localOwnerView, String callsite)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    mNativeObject = nativeCreate(session, name, w, h, format, flags, parent != <span class="literal">null</span> ? parent.mNativeObject : <span class="number">0</span>, metaParcel);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Java 层创建出了 SurfaceControl 对象，它会通过 JNI 去创建 Native 层的 Surface 对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/android_view_SurfaceControl.cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">nativeCreate</span><span class="params">(JNIEnv* env, jclass clazz, jobject sessionObj, jstring nameStr, jint w, jint h, jint format, jint flags, jlong parentObject, jobject metadataParcel)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    sp&lt;SurfaceComposerClient&gt; client;</span><br><span class="line">    <span class="type">status_t</span> err = client-&gt;<span class="built_in">createSurfaceChecked</span>(<span class="built_in">String8</span>(name.<span class="built_in">c_str</span>()), w, h, format, &amp;surface, flags, parentHandle, std::<span class="built_in">move</span>(metadata));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Surface 的创建在 Native 层会调用 SurfaceComposerClient 的 <code>createSurfaceChecked()</code> 方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/SurfaceConposerClient.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">SurfaceComposerClient::createSurfaceChecked</span><span class="params">(<span class="type">const</span> String8&amp; name, <span class="type">uint32_t</span> w, <span class="type">uint32_t</span> h, PixelFormat format, sp&lt;SurfaceControl&gt;* outSurface, <span class="type">uint32_t</span> flags, <span class="type">const</span> sp&lt;IBinder&gt;&amp; parentHandle, LayerMetadata metadata, <span class="type">uint32_t</span>* outTransformHint)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    err = mClient-&gt;<span class="built_in">createSurface</span>(name, w, h, format, flags, parentHandle, std::<span class="built_in">move</span>(metadata), &amp;handle, &amp;gbp, &amp;id, &amp;transformHint);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 mClient 是 <code>sp&lt;ISurfaceComposerClient&gt;</code> 类型，因此继续往下看：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/ISurfaceConposerClient.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">createSurface</span><span class="params">(<span class="type">const</span> String8&amp; name, <span class="type">uint32_t</span> width, <span class="type">uint32_t</span> height, PixelFormat format, <span class="type">uint32_t</span> flags, <span class="type">const</span> sp&lt;IBinder&gt;&amp; parent, LayerMetadata metadata, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp, <span class="type">int32_t</span>* outLayerId, <span class="type">uint32_t</span>* outTransformHint)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">callRemote</span>&lt;<span class="keyword">decltype</span>(&amp;ISurfaceComposerClient::createSurface)&gt;(Tag::CREATE_SURFACE, name, width, height, format, flags, parent, std::<span class="built_in">move</span>(metadata), handle, gbp, outLayerId, outTransformHint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>callRemote()</code> 会通过 Binder 跨进程调用到 SurfaceFlinger 进程中 <code>Client.cpp</code> 中的 <code>createSurface()</code> 方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/Client.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Client::createSurface</span><span class="params">(<span class="type">const</span> String8&amp; name, <span class="type">uint32_t</span> <span class="comment">/* w */</span>, <span class="type">uint32_t</span> <span class="comment">/* h */</span>, PixelFormat <span class="comment">/* format */</span>, <span class="type">uint32_t</span> flags, <span class="type">const</span> sp&lt;IBinder&gt;&amp; parentHandle, LayerMetadata metadata, sp&lt;IBinder&gt;* outHandle, sp&lt;IGraphicBufferProducer&gt;* <span class="comment">/* gbp */</span>, <span class="type">int32_t</span>* outLayerId, <span class="type">uint32_t</span>* outTransformHint)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> mFlinger-&gt;<span class="built_in">createLayer</span>(args, outHandle, parentHandle, outLayerId, <span class="literal">nullptr</span>, outTransformHint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 SF 支持很多不同类型的 Layer，这里我们只以 BufferQueueLayer 为例进行介绍。当 SF 收到这个远程调用后会 new 一个 BufferQueueLayer 出来：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">SurfaceFlinger::createLayer</span><span class="params">(LayerCreationArgs&amp; args, sp&lt;IBinder&gt;* outHandle, <span class="type">const</span> sp&lt;IBinder&gt;&amp; parentHandle, <span class="type">int32_t</span>* outLayerId, <span class="type">const</span> sp&lt;Layer&gt;&amp; parentLayer, <span class="type">uint32_t</span>* outTransformHint)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceBufferQueue:</span><br><span class="line">    <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceBufferState: &#123;</span><br><span class="line">        result = <span class="built_in">createBufferStateLayer</span>(args, outHandle, &amp;layer);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，BufferQueue 与 BufferState 所对应的 Layer 都是 BufferStateLayer。</p>
<p>简单梳理一下上述过程：为了申请一块画布，应用先创建了一个 ViewRoot 对象出来用于跟 WMS 进行通信，然后 WMS 创建出了 SurfaceControl 对象。在该对象的创建过程中经过层层调用，最终又在 SurfaceFlinger 进程中创建出了一个 Layer。那 Surface 对象又是在哪里创建出来的呢？继续看另一条分支：</p>
<h4 id="getsurfacecontrol"><a class="markdownIt-Anchor" href="#getsurfacecontrol"></a> getSurfaceControl()</h4>
<p>WMS 的 <code>createSurfaceControl()</code> 方法中是通过 <code>getSurfaceControl()</code> 将 outSurfaceControl 传出去的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/wm/WindowSurfaceController.java</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">getSurfaceControl</span><span class="params">(SurfaceControl outSurfaceControl)</span> &#123;</span><br><span class="line">    outSurfaceControl.copyFrom(mSurfaceControl, <span class="string">&quot;WindowSurfaceController.getSurfaceControl&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyFrom</span><span class="params">(<span class="meta">@NonNull</span> SurfaceControl other, String callsite)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    assignNativeObject(nativeCopyFromSurfaceControl(other.mNativeObject), callsite);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>nativeCopyFromSurfaceControl()</code> 会调用到 JNI 层代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/android_view_SurfaceControl.cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">nativeCopyFromSurfaceControl</span><span class="params">(JNIEnv* env, jclass clazz, jlong surfaceControlNativeObj)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    sp&lt;SurfaceControl&gt; newSurface = <span class="keyword">new</span> <span class="built_in">SurfaceControl</span>(surface);</span><br><span class="line">    newSurface-&gt;<span class="built_in">incStrong</span>((<span class="type">void</span> *)nativeCreate);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(newSurface.<span class="built_in">get</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数主要是通过 Native 层 SurfaceControl 的拷贝构造函数重新深拷贝了一个 SurfaceControl。拿到这个新的 SurfaceControl 对象后，会被作为参数传入 <code>assignNativeObject()</code> 函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/view/SurfaceControl.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">assignNativeObject</span><span class="params">(<span class="type">long</span> nativeObject, String callsite)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    mNativeObject = nativeObject;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数将深拷贝的 SurfaceControl 对象赋值给传入的 outSurfaceControl 的成员变量 mNativeObject。函数执行完后层层返回，跨进程调用回到 WMS，一直到 <a href="#%E7%94%BB%E5%B8%83%E7%9A%84%E7%94%B3%E8%AF%B7"><code>ViewRootImpl.java</code></a> 中的 <a href="#%E7%94%BB%E5%B8%83%E7%9A%84%E7%94%B3%E8%AF%B7"><code>relayoutWindow()</code></a> 函数，在第 19 行中通过 Surface 的 <code>copyFrom()</code> 方法从 SurfaceControl 中创建出了 Surface。</p>
<p>这里在 Java 层创建的 Surface 是如何拿到帧 Buffer 的操作接口的呢？我们来看下 Surface 的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/view/Surface.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Surface</span> <span class="keyword">implements</span> <span class="title class_">Parcelable</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">nativeLockCanvas</span><span class="params">(<span class="type">long</span> nativeObject, Canvas canvas, Rect dirty)</span> <span class="keyword">throws</span> OutOfResourcesException;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeUnlockCanvasAndPost</span><span class="params">(<span class="type">long</span> nativeObject, Canvas canvas)</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Surface 内部有两个关键函数：<code>nativeLockCanvas()</code> 和 <code>nativeUnlockCanvasAndPost()</code>，它们其实对应了 <code>dequeueBuffer()</code> 和 <code>queueBuffer()</code>。这两个函数对应了 JNI 层的实现，接下来就分别看下其实现过程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/android_view_Surface.cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">nativeLockCanvas</span><span class="params">(JNIEnv* env, jclass clazz, jlong nativeObject, jobject canvasObj, jobject dirtyRectObj)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">status_t</span> err = surface-&gt;<span class="built_in">lock</span>(&amp;buffer, dirtyRectPtr);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">nativeUnlockCanvasAndPost</span><span class="params">(JNIEnv* env, jclass clazz, jlong nativeObject, jobject canvasObj)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">status_t</span> err = surface-&gt;<span class="built_in">unlockAndPost</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应 Native 层 Surface 中的方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/gui/Surface.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Surface::lock</span><span class="params">(ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">status_t</span> err = <span class="built_in">dequeueBuffer</span>(&amp;out, &amp;fenceFd);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Surface::dequeueBuffer</span><span class="params">(<span class="type">android_native_buffer_t</span>** buffer, <span class="type">int</span>* fenceFd)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">status_t</span> result = mGraphicBufferProducer-&gt;<span class="built_in">dequeueBuffer</span>(&amp;buf, &amp;fence, dqInput.width, dqInput.height, dqInput.format, dqInput.usage, &amp;mBufferAge, dqInput.getTimestamps ? &amp;frameTimestamps : <span class="literal">nullptr</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Surface::unlockAndPost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    err = <span class="built_in">queueBuffer</span>(mLockedBuffer.<span class="built_in">get</span>(), fd);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Surface::queueBuffer</span><span class="params">(<span class="type">android_native_buffer_t</span>* buffer, <span class="type">int</span> fenceFd)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">status_t</span> err = mGraphicBufferProducer-&gt;<span class="built_in">queueBuffer</span>(i, input, &amp;output);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 Java 层中 Surface 的 lock 和 unlock 方法分别对应了 Native 层中 mGraphicBufferProducer 的 dequeueBuffer 和 queueBuffer。前面我们详细介绍过 dequeueBuffer 在获取一个 Slot 后，如果 Slot 没有分配 GraphicBuffer，会在这时给它分配 GraphicBuffer，并会返回一个带有 <code>BUFFER_NEEDS_REALLOCATION</code> 标记的 flag，应用侧看到这个 flag 后会通过 requestBuffer 和 importBuffer 把 GraphicBuffer 映射到自已的进程空间。至此应用拿到了它绘制界面所需的画布。</p>
<h4 id="小结-2"><a class="markdownIt-Anchor" href="#小结-2"></a> 小结</h4>
<p>最后用一张图来概括一下上述流程：</p>
<p><img src="https://img.gejiba.com/images/8725430d07763f3b47513da4c9432f7d.webp" alt="" /></p>
<p>在这个过程中涉及到三个进程：APP、system_server 和 SurfaceFlinger。从应用执行 <code>performTraversals()</code> 中调用的 <code>relayoutWindow()</code> 这个函数开始，它跨进程调用到了 system_server 进程中的 WMS 模块，这个模块的 <code>relayoutWindow()</code> 经过一系列过程又创建了一个 SurfaceContorl 对象，并且在其创建过程中跨进程调用 SF 让它创建了一个 Layer 出来。之后 SurfaceControl 对象会跨进程通过参数回传给应用，应用根据 SurfaceControl 创建出应用侧的 Surface 对象，而 Surface 对象通过一些 API 封装向上层提供了拿画布（dequeueBuffer）和提交画布（queueBuffer）的操作接口。这样应用就完成了对画布的申请操作。</p>
<h3 id="帧数据的绘制过程"><a class="markdownIt-Anchor" href="#帧数据的绘制过程"></a> 帧数据的绘制过程</h3>
<p>现在我们已经知道了应用是如何拿到画布的，接下来我们看下应用是如何在绘画完一帧后来提交数据的。</p>
<p>上节中应用的主线程在 <code>performTraversals()</code> 函数中获取到了操作帧缓冲区的 Surface 对象，这个 Surface 对象会通过 RenderProxy 传递给 RenderThread。一些关健代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/view/ViewRootImpl.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    hwInitialized = mAttachInfo.mThreadedRenderer.initialize(mSurface);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数中初始化时会把 Surface 对象传过去：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/view/ThreadedRenderer.java</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">initialize</span><span class="params">(Surface surface)</span> <span class="keyword">throws</span> OutOfResourcesException &#123;</span><br><span class="line">    ...</span><br><span class="line">    setSurface(surface);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终会调用到 JNI 层的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/libs/hwui/jni/android_graphics_HardwareRenderer.cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">android_view_ThreadedRenderer_setSurface</span><span class="params">(JNIEnv* env, jobject clazz,</span></span></span><br><span class="line"><span class="params"><span class="function">        jlong proxyPtr, jobject jsurface, jboolean discardBuffer)</span> </span>&#123;</span><br><span class="line">    RenderProxy* proxy = <span class="built_in">reinterpret_cast</span>&lt;RenderProxy*&gt;(proxyPtr);</span><br><span class="line">    ...</span><br><span class="line">    proxy-&gt;<span class="built_in">setSurface</span>(window, enableTimeout);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/libs/hwui/renderthread/RenderProxy.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderProxy::setSurface</span><span class="params">(ANativeWindow* window, <span class="type">bool</span> enableTimeout)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mRenderThread.<span class="built_in">queue</span>().<span class="built_in">post</span>([<span class="keyword">this</span>, win = window, enableTimeout]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        mContext-&gt;<span class="built_in">setSurface</span>(win, enableTimeout); <span class="comment">// mContext是CanvasContext*类型</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CanvasContext::setSurface</span><span class="params">(ANativeWindow* window, <span class="type">bool</span> enableTimeout)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mNativeSurface = std::<span class="built_in">make_unique</span>&lt;ReliableSurface&gt;(window);</span><br><span class="line">    mNativeSurface-&gt;<span class="built_in">init</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>setSurface()</code> 最终是通过 RenderProxy 对象向 RenderThread 的消息队列中 post 了一个消息，在这个消息处理的过程中又会调用 CanvasContext 的 <code>setSurface()</code> 方法。上述过程如图所示：</p>
<p><img src="https://img.gejiba.com/images/1b88289ed75ddbf1d39025c8132c3322.webp" alt="" /></p>
<p>接下来应用主线程收到 vsync 信号后开始绘图流程，它会遍历 ViewTree 对所有 View完成 measure、layout 和 draw 的工作。我们知道 Android 的应用界面是由很多 View 按树状结构组织起来的，以微信主界面为例，但无论界面多么复杂它都有一个根 View 叫 DecorView。</p>
<p><img src="https://img.gejiba.com/images/b81c5d4abe6f4e0627438219d1bca1f2.webp" alt="" /></p>
<p>我们这里不讨论 UI 线程的 measure 和 layout 部分，只看下 draw。</p>
<p>App 每次绘画都是收到一个 vsync 信号才会开始的（这里暂不讨论 SurfaceView 自主上帧的情况）。应用通过 Choreographer 感知 vsync 信号, 在 ViewRootImpl 中向 Choreographer 注册一个 callback，每当有 vsync 信号来时会执行 mTraversalRunnable：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/view/ViewRootImpl.java</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">TraversalRunnable</span> <span class="variable">mTraversalRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TraversalRunnable</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">scheduleTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    mChoreographer.postCallback(</span><br><span class="line">        Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="literal">null</span>); <span class="comment">// 注册vsync的回调</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        doTraversal(); <span class="comment">// 每次vsync到来时调用该函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看一下 Vsync 信号到来时 <code>doTraversal()</code> 函数都做了什么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/view/ViewRootImpl.java</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doTraversal</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    performTraversals();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!performDraw() &amp;&amp; mSyncBufferCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">performDraw</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">canUseAsync</span> <span class="operator">=</span> draw(fullRedrawNeeded, usingAsyncReport &amp;&amp; mSyncBuffer);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">draw</span><span class="params">(<span class="type">boolean</span> fullRedrawNeeded, <span class="type">boolean</span> forceDraw)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 这里传入的mView是DecorView</span></span><br><span class="line">    mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, <span class="built_in">this</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>draw()</code> 又进一步调用到了 ThreadedRenderer 中的 <code>draw()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/view/ThreadedRenderer.java</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(View view, AttachInfo attachInfo, DrawCallbacks callbacks)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    updateRootDisplayList(view, callbacks);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateRootDisplayList</span><span class="params">(View view, DrawCallbacks callbacks)</span> &#123;</span><br><span class="line">    <span class="comment">// 可以在systrace中看到这个字符串</span></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">&quot;Record View#draw()&quot;</span>);</span><br><span class="line">    updateViewTreeDisplayList(view); <span class="comment">// 更新ViewTree</span></span><br><span class="line">    ...</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateViewTreeDisplayList</span><span class="params">(View view)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    view.updateDisplayListIfDirty();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会调用到 DecorView 中的更新方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/view/View.java</span></span><br><span class="line"><span class="keyword">public</span> RenderNode <span class="title function_">updateDisplayListIfDirty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这里开始记录Displaylist</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">RecordingCanvas</span> <span class="variable">canvas</span> <span class="operator">=</span> renderNode.beginRecording(width, height);</span><br><span class="line">    ...</span><br><span class="line">    draw(canvas);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的 RecordingCanvas 扮演了一个绘图指令记录员的角色，它会根据 <code>draw()</code> 中绘制的指令将这个 View 以 DisplayList 的形式记录下来。</p>
<p>那么上面的 RenderNode 又是什么呢？</p>
<p>Web 中有 DOM Tree 和 Render Tree 的概念，Android 里的 View 和 RenderNode 是类似的概念。View 代表的是实体在空间结构上的存在，而 RenderNode 代表它在界面呈现上的存在。这样的设计可以让存在和呈现分离，便于实现同一存在在不同状态下的呈现不同。</p>
<p>在 Android 的设计中 View 会对应一个 RenderNode，RenderNode 里的一个重要数据结构是 DisplayList，每个 DisplayList 都会包含一系列 DisplayListData。这些 DisplayList 也会同样以树形结构组织在一起。</p>
<p>当 UI 线程完成它的绘制工作以后，它的产物是一堆 DisplayListData。可以将其理解为是一堆绘图指令的集合，每一个 DisplayListData 都是在描绘这个 View 长什么样子，所以一棵 View 树的样子是由它对应的 DisplayListData 构成的树来描述的：</p>
<p><img src="https://img.gejiba.com/images/9dddda45539d60f9fdebcdd208ebc3d3.webp" alt="" /></p>
<p>我们看下 DisplayListData 到底长什么样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/libs/hwui/RecordingCanvas.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DisplayListData</span> <span class="keyword">final</span> &#123;</span><br><span class="line"> ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">drawPath</span><span class="params">(<span class="type">const</span> SkPath&amp;, <span class="type">const</span> SkPaint&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">drawRect</span><span class="params">(<span class="type">const</span> SkRect&amp;, <span class="type">const</span> SkPaint&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">drawArc</span><span class="params">(<span class="type">const</span> SkRect&amp;, SkScalar, SkScalar, <span class="type">bool</span>, <span class="type">const</span> SkPaint&amp;)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">push</span><span class="params">(<span class="type">size_t</span>, Args&amp;&amp;...)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    SkAutoTMalloc&lt;<span class="type">uint8_t</span>&gt; fBytes;</span><br><span class="line">    <span class="type">size_t</span> fUsed = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中：以 draw 打头的函数是最基本的绘图指令，比如画一条线、一个矩形、一段圆弧等等；<code>push()</code> 模板函数我们稍后会分析；fBytes 是一块存储区，它会根据需要扩大存储区的大小。</p>
<p>这里以绘制一个矩形为例看下其实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/libs/hwui/RecordingCanvas.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DisplayListData::drawRect</span><span class="params">(<span class="type">const</span> SkRect&amp; rect, <span class="type">const</span> SkPaint&amp; paint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">push</span>&lt;DrawRect&gt;(<span class="number">0</span>, rect, paint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 push 了一个 DrawRect 的相关参数，那 DrawRect 又是什么呢？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/libs/hwui/RecordingCanvas.cpp</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DrawRect</span> <span class="keyword">final</span> : Op &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Op</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> type : <span class="number">8</span>;</span><br><span class="line">    <span class="type">uint32_t</span> skip : <span class="number">24</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以发现，DrawRect 代表的是一段内存布局，这段内存的第一个字节存储了它是哪种类型，后面部分存储了画这个 Rect 所需要的参数信息。</p>
<p>再来看下 <code>push()</code> 方法的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/libs/hwui/RecordingCanvas.cpp</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">DisplayListData::push</span><span class="params">(<span class="type">size_t</span> pod, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">auto</span> op = (T*)(fBytes.<span class="built_in">get</span>() + fUsed);</span><br><span class="line">    fUsed += skip;</span><br><span class="line">    <span class="keyword">new</span> (op) T&#123;std::forward&lt;Args&gt;(args)...&#125;;</span><br><span class="line">    op-&gt;type = (<span class="type">uint32_t</span>)T::kType;</span><br><span class="line">    op-&gt;skip = skip;</span><br><span class="line">    <span class="keyword">return</span> op + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 <code>push()</code> 方法就是在 fBytes 后面放入这个 DrawRect 的内存布局。所以回到 <code>DisplayListData::drawRect()</code> 方法，它其实就是把绘制这个 Rect 的方法和参数存入了 fBytes 这块内存中，因此最后 fBytes 中就存放了一条条的绘制指令。</p>
<p>经过上面的介绍，我们知道了 UI 线程并没有将应用设计的 View 转换成像素点数据，而是将每个 View 的绘图指令存入了内存中，我们通常称这些绘图指令为 <strong>DisplayList</strong>。下面让我们跳出这些细节，再次回到宏观的角度。</p>
<p>当所有 View 的 DisplayList 建立完成后，代码会来到 <code>RenderProxy::syncAndDrawFrame()</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/libs/hwui/renderthread/RenderProxy.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RenderProxy::syncAndDrawFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDrawFrameTask.<span class="built_in">drawFrame</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/libs/hwui/renderthread/DrawFrameTask.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DrawFrameTask::drawFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">postAndWait</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawFrameTask::postAndWait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mRenderThread-&gt;<span class="built_in">queue</span>().<span class="built_in">post</span>([<span class="keyword">this</span>]() &#123; <span class="built_in">run</span>(); &#125;);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，UI 线程的工作已经结束，它丢了一个叫 DrawFrameTask 的任务到 RenderThread 线程中，之后画面绘制的工作 <code>run()</code> 就转移到了 RenderThread 线程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/libs/hwui/renderthread/DrawFrameTask.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawFrameTask::run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    dequeueBufferDuration = context-&gt;<span class="built_in">draw</span>(); <span class="comment">// context是CanvasContext*类型</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/libs/hwui/renderthread/CanvasContext.cpp</span></span><br><span class="line"><span class="function"><span class="type">nsecs_t</span> <span class="title">CanvasContext::draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Frame frame = mRenderPipeline-&gt;<span class="built_in">getFrame</span>(); <span class="comment">// 会调用到Surface的dequeueBuffer()</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 这里的mRenderPipeline是std::unique_ptr&lt;IRenderPipeline&gt;类型</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> drawResult = mRenderPipeline-&gt;<span class="built_in">draw</span>(frame, windowDirty, dirty, mLightGeometry, &amp;mLayerUpdateQueue, mContentDrawBounds, mOpaque, mLightInfo, mRenderNodes, &amp;(<span class="built_in">profiler</span>()));</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">waitOnFences</span>();</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">bool</span> didSwap = mRenderPipeline-&gt;<span class="built_in">swapBuffers</span>(frame, drawResult.success, windowDirty, mCurrentFrameInfo, &amp;requireSwap);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数中完成了三个重要的动作：</p>
<ul>
<li>通过 <code>getFrame()</code> 调到了 Surface 的 <code>dequeueBuffer()</code> 向 SurfaceFlinger 申请了画布。</li>
<li>通过 <code>mRenderPipeline-&gt;draw()</code> 将画面画到申请到的画布上。</li>
<li>通过 <code>mRenderPipeline-&gt;swapBuffers()</code> 把画布提交到 SurfaceFlinger 去显示。</li>
</ul>
<p>我们看一下在 <code>mRenderPipeline-&gt;draw()</code> 里是如何将 DisplayList 翻译成画布上的像素点颜色的呢？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/libs/hwui/pipelinw/skia/SkiaPipeline.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SkiaPipeline</span> : <span class="keyword">public</span> renderthread::IRenderPipeline &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/libs/hwui/pipelinw/skia/SkiaOpenGLPipeline.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SkiaOpenGLPipeline</span> : <span class="keyword">public</span> SkiaPipeline, <span class="keyword">public</span> IGpuContextCallback &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/libs/hwui/pipelinw/skia/SkiaOpenGLPipeline.cpp</span></span><br><span class="line"><span class="function">IRenderPipeline::DrawResult <span class="title">SkiaOpenGLPipeline::draw</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> Frame&amp; frame, <span class="type">const</span> SkRect&amp; screenDirty, <span class="type">const</span> SkRect&amp; dirty,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> LightGeometry&amp; lightGeometry, LayerUpdateQueue* layerUpdateQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> Rect&amp; contentDrawBounds, <span class="type">bool</span> opaque, <span class="type">const</span> LightInfo&amp; lightInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::vector&lt;sp&lt;RenderNode&gt;&gt;&amp; renderNodes, FrameInfoVisualizer* profiler)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">renderFrame</span>(*layerUpdateQueue, dirty, renderNodes, opaque, contentDrawBounds, surface, SkMatrix::<span class="built_in">I</span>());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/libs/hwui/pipelinw/skia/SkiaPipeline.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SkiaPipeline::renderFrame</span><span class="params">(<span class="type">const</span> LayerUpdateQueue&amp; layers, <span class="type">const</span> SkRect&amp; clip,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> std::vector&lt;sp&lt;RenderNode&gt;&gt;&amp; nodes, <span class="type">bool</span> opaque,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> Rect&amp; contentDrawBounds, sk_sp&lt;SkSurface&gt; surface,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> SkMatrix&amp; preTransform)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    SkCanvas* canvas = <span class="built_in">tryCapture</span>(surface.<span class="built_in">get</span>(), nodes[<span class="number">0</span>].<span class="built_in">get</span>(), layers);</span><br><span class="line">    <span class="built_in">renderFrameImpl</span>(clip, nodes, opaque, contentDrawBounds, canvas, preTransform);</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">renderOverdraw</span>(clip, nodes, contentDrawBounds, surface, preTransform);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的 <code>renderFrameImpl()</code> 中会把在 UI 线程中记录的 DisplayList 绘制到 SkSurface 中，然后通过 SkCanvas 将其转化为 gl 指令，最后 <code>renderOverdraw()</code> 会将这些指令翻译成画布上的像素点颜色。</p>
<p>最后总结一下 APP 通过 View 绘制出第一帧的总流程，如图：</p>
<p><img src="https://img.gejiba.com/images/6122c4d282043186f9a020f4fbcd0b9c.webp" alt="" /></p>
<p>首先是 UI 线程进行 Measure、Layout，然后开始 Draw。在 Draw 的过程中会建立 DisplayList 树，将每个 View 应该怎么画记录下来，再通过 RenderProxy 把后续任务下达给 RenderThread。</p>
<p>RenderThread 主要完成三个动作：首先通过 Surface 接口向 SF 申请 Buffer；然后通过 SkiaOpenGLPipline 的 <code>draw()</code> 方法把 DisplayList 翻译成 GPU 指令， 并指挥 GPU 把指令变成像素点数据；最后通过 <code>swapBuffers()</code> 把数据提交给 SF，完成一帧数据的绘制和提交。</p>
<h3 id="帧数据的提交过程"><a class="markdownIt-Anchor" href="#帧数据的提交过程"></a> 帧数据的提交过程</h3>
<p>接下来看一下应用 queueBuffer 之后 SurfaceFlinger 是如何处理，又是如何提交到 HWC Service 去合成的。</p>
<p>在 Vsync-sf 信号到来后，SurfaceFlinger 主线程会先后执行 <code>commit()</code> 和 <code>composite()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SurfaceFlinger::commit</span><span class="params">(<span class="type">nsecs_t</span> frameTime, <span class="type">int64_t</span> vsyncId, <span class="type">nsecs_t</span> expectedVsyncTime)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mustComposite |= <span class="built_in">latchBuffers</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SurfaceFlinger::latchBuffers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (layer-&gt;<span class="built_in">latchBuffer</span>(visibleRegions, latchTime, expectedPresentTime))</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/BufferLayer.cpp</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferLayer::latchBuffer</span><span class="params">(<span class="type">bool</span>&amp; recomputeVisibleRegions, <span class="type">nsecs_t</span> latchTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">nsecs_t</span> expectedPresentTime)</span> </span>&#123;</span><br><span class="line"> ...</span><br><span class="line">    <span class="type">status_t</span> err = <span class="built_in">updateTexImage</span>(recomputeVisibleRegions, latchTime, expectedPresentTime);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/BufferQueueLayer.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BufferQueueLayer::updateTexImage</span><span class="params">(<span class="type">bool</span>&amp; recomputeVisibleRegions, <span class="type">nsecs_t</span> latchTime, <span class="type">nsecs_t</span> expectedPresentTime)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">status_t</span> updateResult = mConsumer-&gt;<span class="built_in">updateTexImage</span>(&amp;r, expectedPresentTime, &amp;autoRefresh, &amp;queuedBuffer, maxFrameNumberToAcquire);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/BufferLayerConsumer.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BufferLayerConsumer::updateTexImage</span><span class="params">(BufferRejecter* rejecter, <span class="type">nsecs_t</span> expectedPresentTime, <span class="type">bool</span>* autoRefresh, <span class="type">bool</span>* queuedBuffer, <span class="type">uint64_t</span> maxFrameNumber)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">status_t</span> err = <span class="built_in">acquireBufferLocked</span>(&amp;item, expectedPresentTime, maxFrameNumber);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/native/libs/gui/ConsumerBase.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">ConsumerBase::acquireBufferLocked</span><span class="params">(BufferItem *item, <span class="type">nsecs_t</span> presentWhen, <span class="type">uint64_t</span> maxFrameNumber)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">status_t</span> err = mConsumer-&gt;<span class="built_in">acquireBuffer</span>(item, presentWhen, maxFrameNumber);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>commit()</code> 函数的处理中，SurfaceFlinger 主要检查每个 Layer 是否有新提交的 Buffer，如果有则调用 <code>latchBuffer()</code> 将每个 BufferQueue 中的 Slot 通过 <code>acquireBuffer()</code> 拿走。</p>
<p>拿走的 Buffer 会被交由 HWC Service 处理，这部分是在 <code>composite()</code> 中进行的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::composite</span><span class="params">(<span class="type">nsecs_t</span> frameTime, <span class="type">int64_t</span> vsyncId)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mCompositionEngine-&gt;<span class="built_in">present</span>(refreshArgs);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/CompositionEngine/src/CompositionEngine.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CompositionEngine::present</span><span class="params">(CompositionRefreshArgs&amp; args)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; output : args.outputs) &#123;</span><br><span class="line">        output-&gt;<span class="built_in">present</span>(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/CompositionEngine/src/Output.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Output::present</span><span class="params">(<span class="type">const</span> compositionengine::CompositionRefreshArgs&amp; refreshArgs)</span> </span>&#123;</span><br><span class="line"> ...</span><br><span class="line">    <span class="built_in">postFramebuffer</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Output::postFramebuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">auto</span> frame = <span class="built_in">presentAndGetFrameFences</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">HWComposer::presentAndGetReleaseFences</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        HalDisplayId displayId, std::chrono::steady_clock::time_point earliestPresentTime, <span class="type">const</span> std::shared_ptr&lt;FenceTime&gt;&amp; previousPresentFence)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 送去HWC Service合成</span></span><br><span class="line">    <span class="keyword">auto</span> error = hwcDisplay-&gt;<span class="built_in">present</span>(&amp;displayData.lastPresentFence);</span><br><span class="line">    ...</span><br><span class="line">    std::unordered_map&lt;HWC2::Layer*, sp&lt;Fence&gt;&gt; releaseFences;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后就进入 HWC Service 的处理流程，这部分的处理流程和芯片厂商 HAL 层实现紧密相关，这里不再介绍。</p>
<h3 id="小结-3"><a class="markdownIt-Anchor" href="#小结-3"></a> 小结</h3>
<p>我们沿着代码逻辑介绍了应用是如何申请到画布、如何使用 Android 的 View 系统绘图、绘图完成后如何提交 Buffer 以及 Surfaceflinger 如何处理。但本章所述的逻辑均是指通 Android 的 View 系统绘图的过程，也可以称其为 <strong>hwui 绘图</strong>。</p>
<p>从上面代码流程可以知道，hwui 的绘图流程是被 vsync 信号触发的，开始于 vsync 信号到达 UI 线程调用 <code>performTraversals()</code> 函数，hwui 的画面更新是被 vsync 信号驱动的。</p>
<p>在 Android 系统中也有提供不依赖 vsync 信号的自主上帧接口，比如 App 可以使用 SurfaceView 这个特殊的 View 来申请一个独立于 Activity 的画布。接下来我们通过几个示例来看下这些接口是如何使用的。</p>
<h2 id="应用是如何绘图的"><a class="markdownIt-Anchor" href="#应用是如何绘图的"></a> 应用是如何绘图的</h2>
<p>目前很多游戏类应用都是借由 SurfaceView 申请到画布，然后自主上帧的，并不依赖 Vsync 信号，所以我们通过几个示例来看下应用侧是如何绘图和上帧的。由于 Java 层很多接口是对 Native 层接口的 JNI 封装，这里我们只看一些 Native 层接口的用法。</p>
<p>以下代码去除了一些异常处理代码，只保留了重要部分，如需执行可自行补充完整。</p>
<h3 id="无图形库支持下的绘图"><a class="markdownIt-Anchor" href="#无图形库支持下的绘图"></a> 无图形库支持下的绘图</h3>
<p>下面的示例中演示的是如何使用 Native 层接口向 SF 申请一块画布，然后不使用任何图形库直接修改画布上的像素值，最后提交给 SF 进行显示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">sp&lt;ProcessState&gt; <span class="title">proc</span><span class="params">(ProcessState::self())</span></span>;</span><br><span class="line">    <span class="comment">// 在应用和SF沟通过程中要使用到Binder, 所以这里要先初始化Binder线程池</span></span><br><span class="line">    ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">startThreadPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SurfaceComposerClient是SF在应用侧的代表，SF的接口通过它来提供</span></span><br><span class="line">    sp&lt;SurfaceComposerClient&gt; client = <span class="keyword">new</span> <span class="built_in">SurfaceComposerClient</span>();</span><br><span class="line">    client-&gt;<span class="built_in">initCheck</span>();</span><br><span class="line">    <span class="comment">// 先通过createSurface()申请一块画布，参数包含为画布起的名字、大小、位深信息</span></span><br><span class="line">    sp&lt;SurfaceControl&gt; surfaceControl = client-&gt;<span class="built_in">createSurface</span>(</span><br><span class="line">        <span class="built_in">String8</span>(<span class="string">&quot;Console Surface&quot;</span>),<span class="number">800</span>, <span class="number">600</span>, PIXEL_FORMAT_RGBA_8888);</span><br><span class="line"></span><br><span class="line">    SurfaceComposerClient::Transaction t;</span><br><span class="line">    t.<span class="built_in">setLayer</span>(surfaceControl, <span class="number">0x40000000</span>).<span class="built_in">apply</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过getSurface()从surfaceControl中获取到Surface对象</span></span><br><span class="line">    sp&lt;Surface&gt; surface = surfaceControl-&gt;<span class="built_in">getSurface</span>();</span><br><span class="line">    </span><br><span class="line">    ANativeWindow_Buffer buffer;</span><br><span class="line">    <span class="comment">// 通过lock()调用到dequeueBuffer()获取到一个BufferQueue可用的Slot</span></span><br><span class="line">    <span class="type">status_t</span> err = surface-&gt;<span class="built_in">lock</span>(&amp;buffer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* addr = buffer.bits;</span><br><span class="line">    <span class="type">ssize_t</span> len = buffer.stride * <span class="number">4</span> * buffer.height;</span><br><span class="line">    <span class="comment">// 绘图。由于没有使用任何图形库，所以这里把内存填成255画一个纯色画面</span></span><br><span class="line">    <span class="built_in">memset</span>(addr, <span class="number">255</span>, len);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里会调用到queueBuffer()把我们绘制好的画面提交给SF</span></span><br><span class="line">    surface-&gt;<span class="built_in">unlockAndPost</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sleep...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">5</span> * <span class="number">1000</span> * <span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">    surface.<span class="built_in">clear</span>();</span><br><span class="line">    surfaceControl.<span class="built_in">clear</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;complete. CTRL+C to finish.\n&quot;</span>);</span><br><span class="line">    IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">joinThreadPool</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该示例中的几个关键步骤是：</p>
<ul>
<li>创建一个 SurfaceComposerClient，它是应用与 SF 沟通的桥梁。</li>
<li>通过 SurfaceComposerClient 的 <code>createLayer()</code> 方法创建出 SurfaceControl，再通过其 <code>getSurface()</code> 方法获取到 Surface 对象，这是我们操作 BufferQueue 的接口。</li>
<li>有了 Surface 对象，就可以调用它的 <code>lock()</code> 方法来 dequeueBuffer，调用 <code>unlockAndPost()</code> 来 queueBuffer 了。如此循环，就可以对画布进行连续绘制和提交数据了。</li>
</ul>
<h3 id="有图形库支持下的绘图"><a class="markdownIt-Anchor" href="#有图形库支持下的绘图"></a> 有图形库支持下的绘图</h3>
<p>在上面的示例中我们并没有去画复杂的图案，只是使用内存填充的方式画了一个纯色画面。在本节中我们将尝试使用 Skia 图形库在给定的画布上让 CPU 去画一些复杂的图案，比如画一张图片上去。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> android;</span><br><span class="line"><span class="comment">// 把图片转成Bitmap</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">status_t</span> <span class="title">initBitmap</span><span class="params">(SkBitmap* bitmap, <span class="type">const</span> <span class="type">char</span>* fileName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fileName == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    sk_sp&lt;SkData&gt; data = SkData::<span class="built_in">MakeFromFileName</span>(fileName);</span><br><span class="line">    sk_sp&lt;SkImage&gt; image = SkImage::<span class="built_in">MakeFromEncoded</span>(data);</span><br><span class="line">    <span class="type">bool</span> result = image-&gt;<span class="built_in">asLegacyBitmap</span>(bitmap, SkImage::kRO_LegacyBitmapMode);</span><br><span class="line">    <span class="keyword">if</span>(!result )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;decode picture fail!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">sp&lt;ProcessState&gt; <span class="title">proc</span><span class="params">(ProcessState::self())</span></span>;</span><br><span class="line">    ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">startThreadPool</span>(); <span class="comment">// 开启Binder线程池</span></span><br><span class="line"></span><br><span class="line">    sp&lt;SurfaceComposerClient&gt; client = <span class="keyword">new</span> <span class="built_in">SurfaceComposerClient</span>();</span><br><span class="line">    client-&gt;<span class="built_in">initCheck</span>();</span><br><span class="line">    sp&lt;SurfaceControl&gt; surfaceControl = client-&gt;<span class="built_in">createSurface</span>(</span><br><span class="line">        <span class="built_in">String8</span>(<span class="string">&quot;Consoleplayer Surface&quot;</span>),<span class="number">800</span>, <span class="number">600</span>, PIXEL_FORMAT_RGBA_8888);</span><br><span class="line"></span><br><span class="line">    SurfaceComposerClient::Transaction t;</span><br><span class="line">    t.<span class="built_in">setLayer</span>(surfaceControl, <span class="number">0x40000000</span>).<span class="built_in">apply</span>();</span><br><span class="line"></span><br><span class="line">    sp&lt;Surface&gt; surface = surfaceControl-&gt;<span class="built_in">getSurface</span>();</span><br><span class="line"> </span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; graphicBufferProducer = </span><br><span class="line">           surface-&gt;<span class="built_in">getIGraphicBufferProducer</span>();</span><br><span class="line">    ANativeWindow_Buffer buffer;</span><br><span class="line">    <span class="type">status_t</span> err = surface-&gt;<span class="built_in">lock</span>(&amp;buffer, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">ssize_t</span> bpr = buffer.stride * <span class="built_in">bytesPerPixel</span>(buffer.format);</span><br><span class="line">    SkColorType config = <span class="built_in">convertPixelFormat</span>(buffer.format);</span><br><span class="line">    SkBitmap* bitmapDevice = <span class="keyword">new</span> SkBitmap;</span><br><span class="line">    bitmapDevice-&gt;<span class="built_in">setInfo</span>(SkImageInfo::<span class="built_in">Make</span>(buffer.width, buffer.height, </span><br><span class="line">                          config, kPremul_SkAlphaType), bpr);</span><br><span class="line">    <span class="keyword">if</span> (buffer.width &gt; <span class="number">0</span> &amp;&amp; buffer.height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里把帧缓冲区buffer的地址设给了bitmapDevice</span></span><br><span class="line">        <span class="comment">// 这时向bitmapDevice绘制就是在向buffer绘制</span></span><br><span class="line">        bitmapDevice-&gt;<span class="built_in">setPixels</span>(buffer.bits);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bitmapDevice-&gt;<span class="built_in">setPixels</span>(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;to create canvas..\n&quot;</span>);</span><br><span class="line">    SkCanvas* nativeCanvas = <span class="keyword">new</span> <span class="built_in">SkCanvas</span>(*bitmapDevice);</span><br><span class="line">    SkRect sr;</span><br><span class="line">    SkIRect* updateRect = <span class="keyword">new</span> SkIRect;</span><br><span class="line">    sr.<span class="built_in">set</span>(*updateRect);</span><br><span class="line">    nativeCanvas-&gt;<span class="built_in">clipRect</span>(sr);</span><br><span class="line">    nativeCanvas-&gt;<span class="built_in">clear</span>(SK_ColorBLACK);</span><br><span class="line">    SkPaint paint;</span><br><span class="line">    paint.<span class="built_in">setAlpha</span>(<span class="number">255</span>);</span><br><span class="line">    <span class="type">const</span> SkRect dst = SkRect::<span class="built_in">MakeXYWH</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line">    SkBitmap* bitmap = <span class="keyword">new</span> SkBitmap;</span><br><span class="line">    <span class="built_in">initBitmap</span>(bitmap, <span class="string">&quot;/sdcard/picture.png&quot;</span>); <span class="comment">// 从文件中读一个Bitmap出来</span></span><br><span class="line">    <span class="type">const</span> SkIRect src1 = SkIRect::<span class="built_in">MakeXYWH</span>(<span class="number">0</span>, <span class="number">0</span>, bitmap-&gt;<span class="built_in">width</span>(), bitmap-&gt;<span class="built_in">height</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;draw ....\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 调用SkCanvas的drawBitmapRect把图片画到bitmapDevice</span></span><br><span class="line">    <span class="comment">// 也就是画到了从Surface申请到的帧缓冲区buffer中</span></span><br><span class="line">    nativeCanvas-&gt;<span class="built_in">drawBitmapRect</span>((*bitmap), src1, dst, &amp;paint);</span><br><span class="line">    </span><br><span class="line">    surface-&gt;<span class="built_in">unlockAndPost</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sleep...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">10</span> * <span class="number">1000</span> * <span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">    surface.<span class="built_in">clear</span>();</span><br><span class="line">    surfaceControl.<span class="built_in">clear</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test complete. CTRL+C to finish.\n&quot;</span>);</span><br><span class="line">    IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">joinThreadPool</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该示例中获取帧缓冲区 buffer 的方式和上一个例子是一样的，不同的是我们把申请到的 buffer 的地址空间给了 Skia 库，然后通过 Skia 提供的接口把一张图片画到了 buffer 中。由此可以看出我们想使用图形库来操作帧缓冲区的关键是要把帧缓冲区 buffer 的地址对接到图形库提供的接口上。</p>
<p>在 Android 平台上，我们通常不会直接使用 CPU 去绘图，而是调用 OpenGL 或其他图形库去指挥 GPU 绘图。那么使用 OpenGL 库又是如何完成绘图的呢？</p>
<h3 id="使用openglegl的绘图"><a class="markdownIt-Anchor" href="#使用openglegl的绘图"></a> 使用OpenGL&amp;EGL的绘图</h3>
<p>由第二个例子可知，要想使用图形库来向帧缓冲区 buffer 绘图，关建是要把对应的 buffer 给到图形库。但 OpenGL 是一套与平台无关的 API 接口，跟 Surface 接口的任务是由 EGL 完成的，所以帧缓冲区 buffer 要和 EGL 库去对接。</p>
<p>EGL 库会提供一个 EGLSurface 对象，它是对 Surface 的封装，提供了两个重要的接口：dequeue 和 queue，分别对应 Surface 的 dequeueBuffer 和 queueBuffer。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> android;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">sp&lt;ProcessState&gt; <span class="title">proc</span><span class="params">(ProcessState::self())</span></span>;</span><br><span class="line">    ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">startThreadPool</span>();</span><br><span class="line"></span><br><span class="line">    sp&lt;SurfaceComposerClient&gt; client = <span class="keyword">new</span> <span class="built_in">SurfaceComposerClient</span>();</span><br><span class="line">    client-&gt;<span class="built_in">initCheck</span>();</span><br><span class="line">    sp&lt;SurfaceControl&gt; surfaceControl = client-&gt;<span class="built_in">createSurface</span>(</span><br><span class="line">        <span class="built_in">String8</span>(<span class="string">&quot;Consoleplayer Surface&quot;</span>),<span class="number">800</span>, <span class="number">600</span>, PIXEL_FORMAT_RGBA_8888);</span><br><span class="line"></span><br><span class="line">    SurfaceComposerClient::Transaction t;</span><br><span class="line">    t.<span class="built_in">setLayer</span>(surfaceControl, <span class="number">0x40000000</span>).<span class="built_in">apply</span>();</span><br><span class="line"></span><br><span class="line">    sp&lt;Surface&gt; surface = surfaceControl-&gt;<span class="built_in">getSurface</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化EGL属性</span></span><br><span class="line">    <span class="type">const</span> EGLint attribs[] = &#123;</span><br><span class="line">        EGL_RED_SIZE,   <span class="number">8</span>,</span><br><span class="line">        EGL_GREEN_SIZE, <span class="number">8</span>,</span><br><span class="line">        EGL_BLUE_SIZE,  <span class="number">8</span>,</span><br><span class="line">        EGL_DEPTH_SIZE, <span class="number">0</span>,</span><br><span class="line">        EGL_NONE</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化EGL库</span></span><br><span class="line">    EGLint numConfigs;</span><br><span class="line">    EGLConfig config;</span><br><span class="line">    EGLDisplay display = <span class="built_in">eglGetDisplay</span>(EGL_DEFAULT_DISPLAY);</span><br><span class="line">    <span class="built_in">eglInitialize</span>(display, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">eglChooseConfig</span>(display, attribs, &amp;config, <span class="number">1</span>, &amp;numConfigs);</span><br><span class="line">    <span class="comment">// 创建eglSurface</span></span><br><span class="line">    EGLSurface eglSurface;</span><br><span class="line">    eglSurface = <span class="built_in">eglCreateWindowSurface</span>(display, config, surface.<span class="built_in">get</span>(), <span class="literal">NULL</span>);</span><br><span class="line">    EGLContext context;</span><br><span class="line">    context = <span class="built_in">eglCreateContext</span>(display, config, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    EGLint w, h;</span><br><span class="line">    <span class="built_in">eglQuerySurface</span>(display, eglSurface, EGL_WIDTH, &amp;w);</span><br><span class="line">    <span class="built_in">eglQuerySurface</span>(display, eglSurface, EGL_HEIGHT, &amp;h);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里会调用dequeue以获取帧缓冲区buffer</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">eglMakeCurrent</span>(display, eglSurface, eglSurface, context) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glShadeModel</span>(GL_FLAT);</span><br><span class="line">    <span class="built_in">glDisable</span>(GL_DITHER);</span><br><span class="line">    <span class="built_in">glDisable</span>(GL_SCISSOR_TEST);</span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>); <span class="comment">// 这里用OpenGL库来绘制一个纯红的画面</span></span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里会调用到Surface的queueBuffer方法提交画好的帧缓冲区数据</span></span><br><span class="line">    <span class="built_in">eglSwapBuffers</span>(display, eglSurface);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sleep...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">10</span> * <span class="number">1000</span> * <span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">    surface.<span class="built_in">clear</span>();</span><br><span class="line">    surfaceControl.<span class="built_in">clear</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test complete. CTRL+C to finish.\n&quot;</span>);</span><br><span class="line">    IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">joinThreadPool</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟前面一样，需要先获取到 Surface，只是这里我们不再直接获取 buffer，而是把 Surface 对象给到 EGL 库，由 EGL 去使用它。我们使用 OpenGL 的 API 来间接操作帧缓冲区 buffer，这些操作包括申请新的 BufferQueue Slot 和提交绘制好的 BufferQueue slot。</p>
<h2 id="应用画面更新总结"><a class="markdownIt-Anchor" href="#应用画面更新总结"></a> 应用画面更新总结</h2>
<p>通过上述介绍，APP 的画面要显示到屏幕上大致上要经过如下步骤：</p>
<p>首先 App 向 SF 申请画布（通过 <code>dequeueBuffer()</code> 接口）。SF 内部有一个 BufferQueue 的管理实体，它会分配一个 GraphicBuffer 给到 APP，App 拿到 Buffer 后调用图形库在这块 Buffer 上绘画。</p>
<p>APP 绘画完成后向 SF 提交绘制完成的 Buffer（通过 <code>queueBuffer()</code> 接口)。当然这时候只是在 CPU 侧绘制完成，GPU 可能还在该 Buffer 上作画，因此这时向 SF 提交的数据还会带上一个 acquireFence，使得后续使用者能够知道该 Buffer 什么时候使用完毕了。</p>
<p>SF 收到应用提交的 Buffer 后在下一个 Vsync-sf 信号到来时做处理。首先遍历所有的 Layer，找到哪些 Layer 有上帧，通过 <code>acquireBuffer()</code> 把 Buffer 拿出来，再通知给 HWC Service 去合成，最后调用 HWC Service 的 <code>presentDisplay()</code> 接口来告知 HWC Service 其工作已完成。</p>
<p>HWC Service 收到合成任务后开始合成数据，调用 DRM 接口去将这帧画面显示到屏幕上。</p>
<p>至此，一帧画面的更新过程就完成了。</p>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
  </entry>
  <entry>
    <title>Binder机制</title>
    <url>/posts/2031896266.html</url>
    <content><![CDATA[<p>Binder 是 Android 提供的跨进程通信机制。Android 系统是基于 Linux 内核的，Linux 已经拥有 FIFO、管道、信号，到后来的信号量、消息队列、共享内存，再到 eventfd、mmap 内存映射、Socket 等等，但是 Android 却采用了 Binder 这种不同上述几种类型的特有机制，原因有很多，比如性能优化、安全、可扩展性等等。</p>
<h2 id="binder的优势"><a class="markdownIt-Anchor" href="#binder的优势"></a> Binder的优势</h2>
<h3 id="性能优化"><a class="markdownIt-Anchor" href="#性能优化"></a> 性能优化</h3>
<p>在传统的Linux IPC方式中：</p>
<ul>
<li>
<p>socket 作为一款通用接口，其传输效率低、开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。</p>
</li>
<li>
<p>消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。</p>
</li>
<li>
<p>共享内存虽然无需拷贝，但控制复杂，难以使用。</p>
</li>
</ul>
<p>例如，Client 要将一块内存数据传递给 Server，一般的做法是，Client 将这块数据从它的进程空间拷贝到内核空间中，然后内核再将这个数据从内核空间拷贝到 Server 的进程空间，这样，Server 就可以访问这个数据了。但是在这种方法中，执行了两次内存拷贝操作。</p>
<p>为了性能考虑，Binder 在设计时，采用了 mmap 内存映射这种方式来进行数据的传输。只需要把 Client 进程空间的数据拷贝一次到内核空间，然后 Server 与内核共享这个数据就可以了，整个过程只需要执行一次内存拷贝，提高了效率。同时这样更有C/S架构的模型，方便管理。</p>
<h3 id="安全性"><a class="markdownIt-Anchor" href="#安全性"></a> 安全性</h3>
<p>Android 作为一个开放式、拥有众多开发者的的平台，应用程序的来源广泛，确保智能终端的安全是非常重要的。终端用户不希望从网上下载的程序在不知情的情况下偷窥隐私数据、连接无线网络、长期操作底层设备导致电池很快耗尽等等。传统IPC没有任何安全措施，完全依赖上层协议来确保。</p>
<p>首先传统 IPC 的接收方无法获得对方进程可靠的 UID/PID（用户ID/进程ID），从而无法鉴别对方身份。Android 为每个安装好的应用程序分配了自己的 UID，故进程的 UID 是鉴别进程身份的重要标志。使用传统 IPC 只能由用户在数据包里填入 UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标记只能由 IPC 机制本身在内核中添加。</p>
<p>其次传统 IPC 访问接入点是开放的，无法建立私有通道。比如命名管道的名称、system V 的键值、socket 的 ip 地址或文件名都是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。</p>
<p>基于以上原因，Android 需要建立一套新的 IPC 机制来满足系统对通信方式的安全性，这就是 Binder。Binder 为发送方添加 UID/PID 身份，这样在进程间通信时，可以通过进程 ID 进行相应的权限控制，既支持实名 Binder 也支持匿名 Binder，安全性高。</p>
<h3 id="可扩展和低耦合"><a class="markdownIt-Anchor" href="#可扩展和低耦合"></a> 可扩展和低耦合</h3>
<p>Binder 的可扩展和低耦合体现在两个方面的架构上：一是它的 C/S 架构设计，Clinet 和 Server 都容易扩展，想要扩展通信，只需要增加 Client 或者 Server 就可以了，而不用去管中间的通信流程。二是基于驱动的架构设计，只需要新增一个虚拟设备，就可以很容易的实现扩展 Binder 通信的范围。</p>
<h2 id="binder的通信方式"><a class="markdownIt-Anchor" href="#binder的通信方式"></a> Binder的通信方式</h2>
<p>与其它 IPC 不同，Binder 使用了面向对象的思想：Binder 是一个实体位于 Server 中的对象，该对象提供了一套方法用以实现对服务的请求，就像类的成员函数。遍布于 Client 中的入口可以看成指向这个 Binder 对象的指针，一旦获得了这个指针就可以调用该对象的方法访问 Server。在 Client 看来，通过 Binder 指针调用其提供的方法和通过指针调用其它任何本地对象的方法并无区别，尽管前者的实体位于远端 Server 中，而后者实体位于本地内存中。</p>
<p><strong>指针</strong>是 Native 的术语，换成 Java 的说法是<strong>引用</strong>，即 Client 通过 Binder 的引用访问 Server。</p>
<p>如果借用 Windows 系统开发的一个术语<strong>句柄</strong>也可以用来表述 Binder 在 Client 中的存在方式。</p>
<p>从通信的角度看，Client 中的 Binder 也可以看作是 Server Binder 的<strong>代理</strong>，在本地代表远端 Server 为 Client 提供服务。</p>
<blockquote>
<p>面向对象思想的引入将进程间通信转化为通过对某个 Binder 对象的引用调用该对象的方法，其独特之处在于 Binder 对象是一个可以跨进程引用的对象，它的实体位于一个进程中，而它的引用却遍布于系统的各个进程之中。</p>
<p>最诱人的是，这个引用和 Java 里引用一样既可以是强类型，也可以是弱类型，而且可以从一个进程传给其它进程，让大家都能访问同一 Server，就像将一个对象或引用赋值给另一个引用一样。</p>
<p>Binder 模糊了进程边界，淡化了进程间通信过程，整个系统仿佛运行于同一个面向对象的程序之中。形形色色的 Binder 对象以及星罗棋布的引用仿佛粘合各个应用程序的胶水，这也是 Binder 在英文里的原意。</p>
</blockquote>
<p>当然面向对象只是针对应用程序而言，对于 Binder 驱动和内核其它模块来说需要使用 C 语言实现，没有类和对象的概念。Binder 驱动为面向对象的进程间通信提供底层支持。</p>
<h2 id="binder通信模型"><a class="markdownIt-Anchor" href="#binder通信模型"></a> Binder通信模型</h2>
<p>从英文字面意思来看，Binder 是粘合剂。那么它把什么东西粘合在一起呢？在 Android 系统的 Binder 机制中，由一系列组件组成，分别是 Client、Server、Service Manager 和 Binder 驱动程序，其中 Client、Server 和 Service Manager 运行在用户空间，Binder 驱动程序运行内核空间。Binder 就是一种把这四个组件粘合在一起的粘合剂了。其中，核心组件便是 Binder 驱动程序了，Service Manager 提供了辅助管理的功能，Client 和 Server 正是在 Binder 驱动和 ServiceManager 提供的基础设施上进行通信。这四个角色的关系和互联网类似：Server 是服务器，Client 是客户终端，Service Manager 是域名服务器（DNS），Binder 驱动是路由器。</p>
<p><img src="https://img.gejiba.com/images/4019127953f3663aef32e0b5de3b20c4.webp" alt="image-20220924224900315" /></p>
<ul>
<li>
<p>Client、Server 和 ServiceManager 存在于用户空间中，Binder 驱动在内核空间中。</p>
</li>
<li>
<p>Binder 驱动提供设备文件 <code>/dev/binder</code> 与用户空间进行交互。</p>
</li>
<li>
<p>Client、Server 和 ServiceManager 通过系统调用 <code>open()</code> 和 <code>ioctl()</code> 等操作与 Binder 驱动进行通信。</p>
</li>
<li>
<p>ServiceManager 是一个守护进程，用来管理 Server，并向 Client 提供查询 Server 接口的能力。</p>
<p><img src="https://img.gejiba.com/images/a305e1812fbf394de7429b547b41fe37.webp" alt="img" /></p>
</li>
</ul>
<blockquote>
<p><code>open()</code> 用来打开设备文件；<code>ioctl()</code> 用于对设备文件实现读、写等一些扩展功能。</p>
</blockquote>
<h3 id="binder驱动"><a class="markdownIt-Anchor" href="#binder驱动"></a> Binder驱动</h3>
<p>Binder 驱动设备是真正分配内存空间用来存放通信数据的部分。Binder 是虚拟设备的驱动，因此不是对物理设备的操作，而是功能逻辑操作：它工作于内核态，提供 <code>open()</code>、<code>mmap()</code>、<code>poll()</code>、<code>ioctl()</code> 等标准文件操作，以字符驱动设备中的misc设备注册在设备目录 <code>/dev</code> 下，用户可以通过 <code>/dev/binder</code> 访问到它。</p>
<p>驱动负责进程之间 Binder 通信的建立、Binder 在进程之间的传递、Binder 引用计数管理、数据包在进程之间的传递和交互等一系列底层支持。驱动和应用程序之间定义了一套接口协议，主要功能由 <code>ioctl()</code> 接口实现。</p>
<p>Binder IPC 正是基于 mmap 来实现的。Client 要向 Server 发送数据时：</p>
<ul>
<li>Client 进程通过 <code>copy_from_user()</code> 将数据从用户空间拷贝到内核空间；</li>
<li>Server 进程通过 mmap 将内核空间的内存地址映射到其用户空间；</li>
<li>只要 Client 将数据拷贝到内核空间，那么 Server 进程就可以直接读取到内核空间的数据，无需再次拷贝。</li>
</ul>
<p><img src="https://img.gejiba.com/images/982d38b5a067fc6f395d1f7e9fe391de.webp" alt="image-20220924225149023" /></p>
<h3 id="servicemanager和实名binder"><a class="markdownIt-Anchor" href="#servicemanager和实名binder"></a> ServiceManager和实名Binder</h3>
<p>Server 创建了 Binder 实体，为其取一个字符形式的可读易记的名字（张三），将这个 Binder 连同名字以数据包的形式发送给 ServiceManager，通知其注册一个名叫张三的 Binder，并且位于某个 Server 中。驱动为这个 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字及新建的引用打包传递给 ServiceManager。ServiceManager 收到数据包后，从中取出名字和引用填入一张查找表中。</p>
<p>与 DNS 类似，ServiceManager 的作用就是将字符形式的 Binder 名字（张三）转化成 Client 中对该 Binder 的引用，使得 Client 能够通过 Binder 名字获得对 Server 中 Binder 实体的引用。注册了名字的 Binder 叫<strong>实名 Binder</strong>。</p>
<p>这里存在的问题就是：ServiceManager 是一个进程，Server 是另一个进程，Server 向 ServiceManager 注册 Binder 必然会涉及进程间通信。当前实现的是进程间通信却要用到进程间通信，这就出现了鸡生蛋蛋生鸡的问题。</p>
<p>Binder 的解决比较巧妙：预先创造一只鸡用来生蛋：ServiceManager 和其它进程同样采用 Binder 通信，ServiceManager 是 Server 端，有自己的 Binder 对象（预先造好的鸡），其它进程都是 Client，需要通过这个 Binder 的引用来实现 Binder 的注册、查询和获取。</p>
<p>ServiceManager 提供的 Binder 比较特殊，它没有名字也不需要注册，当一个进程使用 <code>BINDER_SET_CONTEXT_MGR</code> 命令将自己注册成 ServiceManager 时，Binder 驱动会自动为它创建 Binder 实体（预先造好的鸡）；其次这个 Binder 的引用在所有 Client 中都固定为 0 而无须通过其它手段获得。也就是说，一个 Server 若要向 ServiceManager 注册自己的 Binder 就必需通过 0（即 NULL 指针）这个引用号与 ServiceManager 的 Binder 通信。注意这里说的 Client 是相对 ServiceManager 而言的，一个应用程序可能是个提供服务的 Server，但对 ServiceManager 来说它仍然是个 Client。</p>
<h3 id="client获得实名binder的引用"><a class="markdownIt-Anchor" href="#client获得实名binder的引用"></a> Client获得实名Binder的引用</h3>
<p>Server 向 ServiceManager 注册了 Binder 实体及其名字后，Client 就可以通过名字获得该 Binder 的引用了。Client 也利用保留的 0 号引用向 ServiceManager 请求访问某个 Binder：我申请获得名字叫张三的 Binder 的引用。ServiceManager 收到这个连接请求，从请求数据包里获得 Binder 的名字，在查找表里找到该名字对应的条目，从条目中取出 Binder 对应 Server 地址，作为回复发送给发起请求的 Client。</p>
<h3 id="匿名binder"><a class="markdownIt-Anchor" href="#匿名binder"></a> 匿名Binder</h3>
<p>并不是所有 Binder 都需要注册到 ServiceManager 中广而告之的。Server 端可以通过已经建立的 Binder 连接将创建的 Binder 实体传给 Client，当然这条已经建立的 Binder 连接必须通过实名 Binder 实现。由于这个 Binder 实体没有向 ServiceManager 注册名字，所以是个匿名 Binder。Client 将会收到这个匿名 Binder 的引用，通过这个引用向位于 Server 中的实体发送请求。匿名 Binder 为通信双方建立一条私密通道，只要 Server 没有把匿名 Binder 发给别的进程，别的进程就无法通过穷举或猜测等任何方式获得该 Binder 的引用，向该 Binder 发送请求。</p>
<h2 id="binder机制跨进程原理"><a class="markdownIt-Anchor" href="#binder机制跨进程原理"></a> Binder机制跨进程原理</h2>
<p>我们已经知道了 Binder 通信过程中的四个角色: Client、Server、ServiceManager 和 Driver，但还不清楚 Client 到底是如何与 Server 完成通信的。</p>
<p>虽然 Binder 用到了面向对象的思想，但并不限制应用程序一定要使用面向对象的语言，无论 C 还是 C++ 都可以很容易的使用Binder来通信。Binder 本质上只是一种底层通信方式，和具体服务没有关系。为了提供具体服务，Server 必须提供一套接口函数以便 Client 通过远程访问使用各种服务。这时通常采用 Proxy 设计模式：将接口函数定义在一个抽象类中，Server 和 Client 都会以该抽象类为基类实现所有接口，所不同的是 Server 端是真正的功能实现，而 Client 端是对这些函数远程调用请求的包装。</p>
<p>Client、Server、ServiceManager 位于用户空间的不同进程，不可进行进程间交互，所以它们都通过是 Binder 驱动进行交互的，所以真正的交互过程为：</p>
<p><img src="https://img.gejiba.com/images/a9df5661d5916527714c6dcabaf0a824.webp" alt="img" /></p>
<p>下面再详细说一下 Client 进程和 Server 进程是如何通过 Binder 驱动进行交互的。</p>
<ol>
<li>Server 进程启动之后，会进入中断等待状态，等待 Client 的请求。</li>
<li>当 Client 需要和 Server 通信时，会将请求发送给 Binder 驱动。</li>
<li>Binder 驱动收到请求之后，会唤醒 Server 进程。</li>
<li>同时，Binder 驱动会返回消息给 Client，告诉 Client：它发送给 Binder 驱动的请求，Binder 驱动已经接收到了。</li>
<li>Client 将请求发送成功后，就进入等待状态，等待 Server 的回复。</li>
<li>Binder 驱动唤醒 Server 后，就将请求转发给 Server 进程。</li>
<li>Server 进程解析出请求的内容，并将回复内容发送给 Binder 驱动。</li>
<li>Binder 驱动收到回复之后，唤醒 Client 进程。</li>
<li>同时，Binder 驱动会返回消息给 Server，告诉 Server：它发送给 Binder 驱动的回复，Binder 驱动已经收到。</li>
<li>Server 将回复发送成功后，就再次进入等待状态，继续等待 Client 的请求。</li>
<li>最终，Binder 驱动将回复转发给 Client。</li>
</ol>
<p><img src="https://img.gejiba.com/images/b19d47ea42337f28d23e24114a388e73.webp" alt="img" /></p>
<h2 id="环境初始化"><a class="markdownIt-Anchor" href="#环境初始化"></a> 环境初始化</h2>
<p>Binder 机制要运行起来，必须先进行环境的初始化工作。</p>
<h3 id="binder驱动初始化"><a class="markdownIt-Anchor" href="#binder驱动初始化"></a> Binder驱动初始化</h3>
<p>这个过程是在 kernel 的 <code>binder.c</code> 中完成的，这里就不展开了。经历完这个步骤之后，Client 和 Server 才能使用 Binder 实现跨进程通信。</p>
<h3 id="servicemanager服务初始化"><a class="markdownIt-Anchor" href="#servicemanager服务初始化"></a> ServiceManager服务初始化</h3>
<p>开机启动时由 init 进程 解析 <code>init.rc</code> 启动 <code>servicemanager.rc</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># frameworks/native/cmds/servicemanager/servicemanager.rc</span></span><br><span class="line">service servicemanager /system/bin/servicemanager</span><br><span class="line">    ...</span><br><span class="line">    onrestart class_restart --only-enabled main</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>该文件的启动会调用当前目录下的 main 函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/cmds/servicemanager/main.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 打开/dev/binder设备，并通过mmap将该设备的内存空间映射到ServiceManager进程中</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* driver = argc == <span class="number">2</span> ? argv[<span class="number">1</span>] : <span class="string">&quot;/dev/binder&quot;</span>;</span><br><span class="line">    sp&lt;ProcessState&gt; ps = ProcessState::<span class="built_in">initWithDriver</span>(driver);</span><br><span class="line">    ...</span><br><span class="line"> <span class="comment">// 创建ServiceManager对象，然后将其注册到ServiceManager服务中</span></span><br><span class="line">    sp&lt;ServiceManager&gt; manager = sp&lt;ServiceManager&gt;::<span class="built_in">make</span>(std::<span class="built_in">make_unique</span>&lt;Access&gt;());</span><br><span class="line">    <span class="keyword">if</span> (!manager-&gt;<span class="built_in">addService</span>(<span class="string">&quot;manager&quot;</span>, manager, <span class="literal">false</span> <span class="comment">/*allowIsolated*/</span>,</span><br><span class="line">                             IServiceManager::DUMP_FLAG_PRIORITY_DEFAULT).<span class="built_in">isOk</span>()) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Could not self register servicemanager&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">setTheContextObject</span>(manager);</span><br><span class="line">    <span class="comment">// 将ServiceManager设置为ContextManager</span></span><br><span class="line">    ps-&gt;<span class="built_in">becomeContextManager</span>();</span><br><span class="line"></span><br><span class="line">    sp&lt;Looper&gt; looper = Looper::<span class="built_in">prepare</span>(<span class="literal">false</span> <span class="comment">/*allowNonCallbacks*/</span>);</span><br><span class="line">    BinderCallback::<span class="built_in">setupTo</span>(looper);</span><br><span class="line">    ClientCallbackCallback::<span class="built_in">setupTo</span>(looper, manager);</span><br><span class="line"> <span class="comment">// ServiceManager服务进入循环，等待接收数据来处理</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        looper-&gt;<span class="built_in">pollAll</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Binder 驱动已经初始化好了，因此该函数会直接打开 Binder 设备，并通过 <code>mmap()</code> 将 Binder 的内存空间映射到 ServiceManager 进程中。这里还将 ServiceManager 设置为了 ContextManager，然后进入循环等待接收数据。</p>
<p>第 6 行会触发 ProcessState 对象的创建，先看下其构造函数：</p>
<h4 id="processstate构造"><a class="markdownIt-Anchor" href="#processstate构造"></a> ProcessState构造</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/ProcessState.cpp</span></span><br><span class="line">ProcessState::<span class="built_in">ProcessState</span>(<span class="type">const</span> <span class="type">char</span>* driver)</span><br><span class="line">      : <span class="built_in">mDriverName</span>(<span class="built_in">String8</span>(driver)),</span><br><span class="line">        ...,</span><br><span class="line">        <span class="built_in">mCallRestriction</span>(CallRestriction::NONE) &#123;</span><br><span class="line">    base::Result&lt;<span class="type">int</span>&gt; opened = <span class="built_in">open_driver</span>(driver);</span><br><span class="line">    ...</span><br><span class="line">    mVMStart = <span class="built_in">mmap</span>(<span class="literal">nullptr</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, opened.<span class="built_in">value</span>(), <span class="number">0</span>);</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到构造函数中调用了 <code>open_driver()</code> 和 <code>mmap()</code> 这两个函数。<code>open_driver()</code> 的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/ProcessState.cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> base::Result&lt;<span class="type">int</span>&gt; <span class="title">open_driver</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* driver)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(driver, O_RDWR | O_CLOEXEC);</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">status_t</span> result = <span class="built_in">ioctl</span>(fd, BINDER_VERSION, &amp;vers);</span><br><span class="line">    ...</span><br><span class="line">    result = <span class="built_in">ioctl</span>(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数通过 <code>open()</code> 打开 Binder 设备文件，并通过 <code>ioctl()</code> 向 Binder 驱动查询或设置了一些信息，比如 <code>BINDER_VERSION</code>、<code>BINDER_SET_MAX_THREADS</code> 等操作。<code>ioctl()</code> 是用户空间与 Binder 内核空间交互的主要接口，其中一些重要的命令如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">BINDER_WRITE_READ</td>
<td style="text-align:left">该命令由用户空间向 Binder 驱动写入或者读取数据，里面包含写和读两个部分。当 write_size 不为 0 时，表示要将 write_buffer 里面的数据写入 Binder 驱动；当 read_size 不为 0 时，表示要从 Binder 驱动中读取数据到 read_buffer 中</td>
</tr>
<tr>
<td style="text-align:left">BINDER_SET_MAX_THREADS</td>
<td style="text-align:left">设置 Server 端线程池中支持的最大线程数，保存在 Binder 驱动的 binder_proc 结构体中。由于 Client 端是并发向 Server 发送请求的，所以 Server 端必须有线程池来处理并发请求。Binder 驱动中会记录 Client 端请求的线程数，若超过最大线程数，则不再处理 Client 端发来的请求</td>
</tr>
<tr>
<td style="text-align:left">BINDER_SET_CONTEXT_MGR</td>
<td style="text-align:left">该命令将当前进程设置为 ContextManager，最终会保存到 Binder 驱动的 binder_context 结构体中的变量 binder_context_mgr_node 中。由于系统中有且只能有一个 Context Manager，当 ServiceManager 服务在开机时启动并通过此命令将自己设置为 ContextManager 时，就可以保证 ServiceManager 是唯一且正确的 ContextManager</td>
</tr>
<tr>
<td style="text-align:left">BINDER_THREAD_EXIT</td>
<td style="text-align:left">Client 通知 Binder 驱动当前线程退出时发送此命令。如果 Client 端线程执行结束了，就会由线程 IPCThreadState 发送此命令来通知 Binder 驱动释放对应线程</td>
</tr>
<tr>
<td style="text-align:left">BINDER_VERSION</td>
<td style="text-align:left">获取 Binder 驱动的版本号。从用户空间打开 Binder 驱动时，会先获取该驱动的版本号，如果和用户空间中 Binder 驱动协议的版本号不一致，则驱动无法打开</td>
</tr>
</tbody>
</table>
<p><code>open()</code> 与 <code>mmap()</code> 都是 kernel 中的函数，这里就不展开分析了。</p>
<h4 id="becomecontextmanager"><a class="markdownIt-Anchor" href="#becomecontextmanager"></a> becomeContextManager()</h4>
<p>再回到 <a href="#ServiceManager%E6%9C%8D%E5%8A%A1%E5%88%9D%E5%A7%8B%E5%8C%96"><code>main()</code></a> 函数，第 17 行通过调用 ProcessState 的 <code>becomeContextManager()</code> 将 ServiceManager 设置为 ContextManager，下面就来看下这个函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/ProcessState.cpp</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ProcessState::becomeContextManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> unused = <span class="number">0</span>;</span><br><span class="line">    result = <span class="built_in">ioctl</span>(mDriverFD, BINDER_SET_CONTEXT_MGR, &amp;unused);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数通过 <code>ioctl()</code> 进行设置，具体细节这里不再展开。</p>
<h4 id="bindercallback"><a class="markdownIt-Anchor" href="#bindercallback"></a> BinderCallback</h4>
<p>在 <a href="#ServiceManager%E6%9C%8D%E5%8A%A1%E5%88%9D%E5%A7%8B%E5%8C%96"><code>main()</code></a> 函数中继续往下走，第 19 行创建了 Looper 对象，然后在第 20 行将该对象传入了 BinderCallback 的 <code>setupTo()</code> 中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sp&lt;Looper&gt; looper = Looper::<span class="built_in">prepare</span>(<span class="literal">false</span> <span class="comment">/*allowNonCallbacks*/</span>);</span><br><span class="line">BinderCallback::<span class="built_in">setupTo</span>(looper);</span><br></pre></td></tr></table></figure>
<p>先来看一下 BinderCallback 的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/cmds/servicemanager/main.cpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinderCallback</span> : <span class="keyword">public</span> LooperCallback &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> sp&lt;BinderCallback&gt; <span class="title">setupTo</span><span class="params">(<span class="type">const</span> sp&lt;Looper&gt;&amp; looper)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">int</span> ret = looper-&gt;<span class="built_in">addFd</span>(binder_fd,</span><br><span class="line">                                Looper::POLL_CALLBACK,</span><br><span class="line">                                Looper::EVENT_INPUT,</span><br><span class="line">                                cb,</span><br><span class="line">                                <span class="literal">nullptr</span> <span class="comment">/*data*/</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> cb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">handleEvent</span><span class="params">(<span class="type">int</span> <span class="comment">/* fd */</span>, <span class="type">int</span> <span class="comment">/* events */</span>, <span class="type">void</span>* <span class="comment">/* data */</span>)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">handlePolledCommands</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// Continue receiving callbacks.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>setupTo()</code> 会将 Binder 的文件描述符 binder_fd 添加到 Looper 中，从而 Looper 可以监听 Binder 的消息，有消息到来时会触发 Looper 的 <code>POLL_CALLBACK</code>，进而会触发 <code>handleEvent()</code> 函数。</p>
<h2 id="解析binder框架"><a class="markdownIt-Anchor" href="#解析binder框架"></a> 解析Binder框架</h2>
<p>经过环境初始化后，Binder 驱动已经就绪，ServiceServer 服务也启动起来了，正在等待 Client 的请求。同时，ServiceManager 在 Binder 驱动中对应有一个 binder_proc 对象，以及一个 binder_node 结构体。</p>
<h3 id="框架中的主要结构体"><a class="markdownIt-Anchor" href="#框架中的主要结构体"></a> 框架中的主要结构体</h3>
<p>那么，用户进程是怎样跟 Binder 驱动进行沟通的？具体又是哪些类或者对象在其中起作用呢？</p>
<p>用户进程中跟 Binder 驱动离得最近的其实是 Native 层的 ProcessState 和 IPCThreadState。</p>
<ul>
<li>ProcessState 代表用户进程中的对象，每个用户进程有且只有一个 ProcessState 对象，属于单例。</li>
<li>IPCThreadState 代表用户进程中操作 Binder 的线程对象，主要通过 <code>transact()</code> 函数进行系统调用以实现与 Binder 驱动的沟通。其中系统调用主要使用的是 <code>ioctl()</code>，它承担了读和写的任务。</li>
</ul>
<p>当 ProcessState 对象创建时，会通过系统调用 <code>open()</code> 打开 Binder 驱动，并且在 Binder 驱动中创建对应的 <code>binder_proc</code> 结构体对象。如果有多个用户进程，在 Binder 驱动中就会存在多个 binder_proc 结构体对象，这些 binder_proc 对象保存在 binder_procs 链表中。</p>
<p>由于 Binder 驱动中可以并发处理用户进程的请求，所以每一个 binder_proc 对象中都有多个线程来处理请求业务。这些线程结构体为 binder_thread，它们以红黑树的形式保存在 threads 对象中。</p>
<p>每个 binder_proc 中的 todo 列表代表将要做的工作，同样地，每一个 binder_thread 结构体中也有一个 todo 列表。</p>
<p>不论是 ServiceManager 服务还是 Client 进程，它们跟 Binder 驱动交互都是使用的这些对象。</p>
<p><img src="https://img.gejiba.com/images/7d9898015516ee104153ac83e18cc640.webp" alt="img" /></p>
<h3 id="框架中传输的数据"><a class="markdownIt-Anchor" href="#框架中传输的数据"></a> 框架中传输的数据</h3>
<p>前面提到，<code>ioctl()</code> 既承担了写任务又承担了读任务，这主要依赖于传入它的参数 binder_write_read：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sys/bionic/libc/kernel/uapi/linux/android/binder.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binder_write_read</span> &#123;</span><br><span class="line"> <span class="type">binder_size_t</span> write_size;</span><br><span class="line"> <span class="type">binder_size_t</span> write_consumed;</span><br><span class="line"> <span class="type">binder_uintptr_t</span> write_buffer;</span><br><span class="line"> <span class="type">binder_size_t</span> read_size;</span><br><span class="line"> <span class="type">binder_size_t</span> read_consumed;</span><br><span class="line">    <span class="type">binder_uintptr_t</span> read_buffer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果 Client 要向 Binder 驱动发送数据，那么 Client 就会填充 binder_write_read 中的 write_size 和 write_buffer。当通过 <code>ioctl()</code> 调用到 Binder 驱动中时，Binder 驱动会先通过 <code>copy_from_user()</code> 将 Client 的 binder_write_read 数据拷贝到 Binder 驱动中的 binder_write_read，然后进行判断：如果其中的 write_size 大于 0，就说明 Client 要向 Binder 驱动发送数据，这时 Binder 驱动就会从 write_buffer 中将数据读出来进行处理，完成一次数据传递。</p>
<p>接下来再补充 Binder 中的一些重要概念。</p>
<h4 id="binder实体"><a class="markdownIt-Anchor" href="#binder实体"></a> Binder实体</h4>
<p>Binder 实体是各个 Server 和 ServiceManager 在内核中的表现形式，对应内核中的 binder_node。它的作用是在内核中保存 Server 和 ServiceManager 的信息，比如 Server 对象在用户空间的地址。</p>
<h4 id="binder引用"><a class="markdownIt-Anchor" href="#binder引用"></a> Binder引用</h4>
<p>Binder 引用是是 Client 在内核中的表现形式，对应内核中的 binder_ref，是对 Binder 实体的引用，通过它可以在内核中找到对应的 Binder 实体。</p>
<p>binder_node 和 binder_ref 都是内核中的数据结构，每个 Server 在内核中表现为一个 Binder 实体，而每一个 Client 则表现为一个 Binder 引用。这样，每个 Binder 引用都对应一个 Binder 实体，而每个 Binder 实体可以对应多个 Binder 引用。</p>
<h4 id="binder代理远程服务"><a class="markdownIt-Anchor" href="#binder代理远程服务"></a> Binder代理（远程服务）</h4>
<p>Binder 代理，也可叫做远程服务。Server 都是以服务的形式注册到 ServiceManager 中进行管理的。如果将 Server 看作本地服务的话，那么它在 Client 中的代理就是远程服务。通过该远程服务 Client 就能和 Server 进行通信。</p>
<p>Binder 框架中各对象之间的关系如下：</p>
<p><img src="https://img.gejiba.com/images/5bc62371edd39e975d25ce270b353204.webp" alt="img" /></p>
<h3 id="server在servicemanager中的存储"><a class="markdownIt-Anchor" href="#server在servicemanager中的存储"></a> Server在ServiceManager中的存储</h3>
<p>接下来看一下 Server 是如何在 ServiceManager 中存储的，以及 Client 是如何拿到 Server 进行调用的。</p>
<p>Server 通过 ServiceManager 的 <code>addService()</code> 保存到其列表中。ServiceManager 里面存储了很多服务，这些服务通过一个叫做 ServiceMap 的集合来保存：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/cmds/servicemanager/ServiceManager.h</span></span><br><span class="line"><span class="keyword">using</span> ServiceMap = std::map&lt;std::string, Service&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    sp&lt;IBinder&gt; binder; <span class="comment">// not null</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中 std::string 表示服务的名字，Service 是服务本身，这样在 map 中就将服务名字和对应的服务映射起来了。</p>
<p>在 Service 结构体中，我们重点关注一下 binder。它是一个 IBinder 接口类型，那我们 Service 中的 binder 都是 IBinder 的实现吗？</p>
<p>接下来就以 ActivityManagerService 为例来看一下（注意：ManagerService 是 Service，ServiceManager 才是 Manager）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActivityManagerService</span> <span class="keyword">extends</span> <span class="title class_">IActivityManager</span>.Stub implements ... &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>ActivityManagerService 继承自 <code>IActivityManager.Stub</code>，而系统中没有 IActivityManager 的 Java 文件，只有 <code>IActivityManager.aidl</code>，因此需要通过系统编译来生成 <code>IActivityManager.java</code>。看下最终生成的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IActivityManager</span> <span class="keyword">extends</span> <span class="title class_">android</span>.os.IInterface&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Stub</span> <span class="keyword">extends</span> <span class="title class_">android</span>.os.Binder <span class="keyword">implements</span> <span class="title class_">android</span>.app.IActivityManager&#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>IActivityManager.Stub</code> 这个内部类继承自 <code>android.os.Binder</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/os/Binder.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Binder</span> <span class="keyword">implements</span> <span class="title class_">IBinder</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/core/java/android/os/IBinder.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IBinder</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p><code>android.os.Binder</code> 又实现了 <code>android.os.IBinder</code> 接口。继承关系如下：</p>
<p><img src="https://img.gejiba.com/images/1fa71e39b3cef33b9f494d96cae880bd.webp" alt="image-20220924225739466" /></p>
<p>其实，整个 Binder 架构在 Java、JNI、Native 层都有设计，如果按照 Client 和 Server 划分：</p>
<p>&lt; img src=&quot;…/…/Image/webp-166393380683522.webp&quot; alt=“img” style=“zoom:55%;” /&gt;</p>
<ul>
<li>在 Java 层，Client 要访问 Server，持有的是 BinderProxy 代理，在 Server 端是Binder。</li>
<li>在 Native 层，Client 端是 BpBinder 代理，在 Server 端是 BBinder。</li>
<li>Java 层和 Native 层之间通过 JNI 进行衔接。</li>
</ul>
<h3 id="对象传递方式"><a class="markdownIt-Anchor" href="#对象传递方式"></a> 对象传递方式</h3>
<p>我们知道，同进程内对象间的传递一般是传递引用，引用本质上是一个内存地址，但是对于跨进程通信，引用传递就不能使用了。因为虚拟内存的存在，不同的进程都有自己独立的内存空间，所以进程间传递地址值是无效的。这里就是涉及序列化与反序列化了。在 Android 中，最常用的就是 Parcel 了。在 Binder 进行跨进程通信时，通常会将数据打包到 Parcel 对象中，然后通过 Binder 驱动进行传递。</p>
<p>Parcel 的字面意思是打包，对于基本数据类型，如 string、int 等，可以直接写入到 Parcel 中，但实际传输过程并不会将这些基本数据类型传递过去，仍然是值传递。对于复杂的数据类型，则需要序列化和反序列化。例如，我们用一个传真机发送一个纸盒子到远方，先是将三维纸盒子展开成二维平面纸盒子，再通过传真机传真到远端，远端再将二维平面的纸盒子还原成一个三维的纸盒子，如下图所示：</p>
<p><img src="https://img.gejiba.com/images/de763593a38156944d5ddc70a41ca1b1.png" alt="img" /></p>
<p>具体实现的话，flatten 过程就是 Parcel 的 <code>writeStrongBinder()</code> 实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/Parcel.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::writeStrongBinder</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">flattenBinder</span>(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应地，在远端需要有 unflatten 过程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/Parcel.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::readNullableStrongBinder</span><span class="params">(sp&lt;IBinder&gt;* val)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unflattenBinder</span>(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象打包好之后，在用户空间和内核空间之间传输，主要使用如下两个系统调用：</p>
<ul>
<li><code>copy_from_user()</code>：将数据包从用户空间复制到内核空间。</li>
<li><code>copy_to_user()</code>：将数据包从内核空间复制到用户空间。</li>
</ul>
<h2 id="ams注册到servicemanager"><a class="markdownIt-Anchor" href="#ams注册到servicemanager"></a> AMS注册到ServiceManager</h2>
<p>ServiceManager 服务启动后将自己设置为 ContextManager，即 Service 的大管家，这样后续启动的服务就可以通过 ServiceManager 来管理。每当 Client 需要使用 Server 的功能时，首先需要通过 ServiceManager 获取到这个 Server 服务，然后才能使用该 Server 的相关功能。</p>
<p>这里就以 ActivityManagerService（AMS） 这个 Service 为例，看下它是如何注册到 ServiceManager 中的，以及 Client 是如何调用它的。</p>
<p>AMS 是开机启动的系统服务，因此在开机阶段就已经将自己创建好，并设置到了 ServiceManager 中。</p>
<p>SystemServer 中的 <code>run()</code> 方法会启动系统的一些服务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/java/com/android/server/SystemServer.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SystemServer</span> <span class="keyword">implements</span> <span class="title class_">Dumpable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SystemServer</span>().run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        startBootstrapServices(t);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startBootstrapServices</span><span class="params">(<span class="meta">@NonNull</span> TimingsTraceAndSlog t)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        mActivityManagerService = ActivityManagerService.Lifecycle.startService(</span><br><span class="line">                mSystemServiceManager, atm);</span><br><span class="line">        mActivityManagerService.setSystemProcess();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>startBootstrapServices()</code> 方法中首先创建了 AMS 实例，该实例最终的创建是在 <code>SystemServiceManager</code> 中进行的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActivityManagerService</span> <span class="keyword">extends</span> <span class="title class_">IActivityManager</span>.Stub &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Lifecycle</span> <span class="keyword">extends</span> <span class="title class_">SystemService</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> ActivityManagerService <span class="title function_">startService</span><span class="params">(</span></span><br><span class="line"><span class="params">                SystemServiceManager ssm, ActivityTaskManagerService atm)</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> ssm.startService(ActivityManagerService.Lifecycle.class).getService();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/SystemServiceManager.java</span></span><br><span class="line"><span class="keyword">public</span> SystemService <span class="title function_">startService</span><span class="params">(String className)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;SystemService&gt; serviceClass = loadClassFromLoader(className,</span><br><span class="line">            <span class="built_in">this</span>.getClass().getClassLoader());</span><br><span class="line">    <span class="keyword">return</span> startService(serviceClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">SystemService</span>&gt; T <span class="title function_">startService</span><span class="params">(Class&lt;T&gt; serviceClass)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    service = constructor.newInstance(mContext);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AMS 最终是通过 <code>newInstance()</code> 创建的。创建了 AMS 之后，接着调用了其 <a href="#AMS%E6%B3%A8%E5%86%8C%E5%88%B0ServiceManager"><code>setSystemProcess()</code></a> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSystemProcess</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    ServiceManager.addService(Context.ACTIVITY_SERVICE, <span class="built_in">this</span>, <span class="comment">/* allowIsolated= */</span> <span class="literal">true</span>,</span><br><span class="line">            DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PRIORITY_NORMAL | DUMP_FLAG_PROTO);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该方法中，将 ActivityManagerService 自身实例通过 <code>addService()</code> 注册到了 ServiceManager 中。</p>
<h2 id="两个进程间的通信"><a class="markdownIt-Anchor" href="#两个进程间的通信"></a> 两个进程间的通信</h2>
<p>在 Client 端，真正发起通信的是 <code>BinderProxy.transact()</code>，而 Server 端接收消息的是 <code>Binder.onTransact()</code>，因此我们从 <code>BinderProxy.transact()</code> 方法开始分析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/os/BinderProxy.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">BinderProxy</span> <span class="keyword">implements</span> <span class="title class_">IBinder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">transact</span><span class="params">(<span class="type">int</span> code, Parcel data, Parcel reply, <span class="type">int</span> flags)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> transactNative(code, data, reply, flags);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 JNI 方法 <code>transactNative()</code> 进入 Native 层：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/android_util_Binder.cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> jboolean <span class="title">android_os_BinderProxy_transact</span><span class="params">(JNIEnv* env, jobject obj,</span></span></span><br><span class="line"><span class="params"><span class="function">        jint code, jobject dataObj, jobject replyObj, jint flags)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 从BinderProxyNativeData中获取IBinder指针（BpBinder）</span></span><br><span class="line">    IBinder* target = <span class="built_in">getBPNativeData</span>(env, obj)-&gt;mObject.<span class="built_in">get</span>();</span><br><span class="line">    <span class="type">status_t</span> err = target-&gt;<span class="built_in">transact</span>(code, *data, reply, flags);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里调用了 BpBinder 的 <code>transact()</code> 方法，进去看一下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/BpBinder.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BpBinder::transact</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data, Parcel* reply, <span class="type">uint32_t</span> flags)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    status = IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">transact</span>(<span class="built_in">binderHandle</span>(), code, data, reply, flags);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">BpBinder::binderHandle</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">get</span>&lt;BinderHandle&gt;(mHandle).handle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/native/libs/binder/IPCThreadState.cpp</span></span><br><span class="line"><span class="function">IPCThreadState* <span class="title">IPCThreadState::self</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存在则返回</span></span><br><span class="line">    <span class="keyword">if</span> (gHaveTLS.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">restart:</span><br><span class="line">        <span class="type">const</span> <span class="type">pthread_key_t</span> k = gTLS;</span><br><span class="line">        IPCThreadState* st = (IPCThreadState*)<span class="built_in">pthread_getspecific</span>(k);</span><br><span class="line">        <span class="keyword">if</span> (st) <span class="keyword">return</span> st;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IPCThreadState;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 不存在则创建</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;gTLSMutex);</span><br><span class="line">    <span class="keyword">if</span> (!gHaveTLS.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">        <span class="type">int</span> key_create_value = <span class="built_in">pthread_key_create</span>(&amp;gTLS, threadDestructor);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;gTLSMutex);</span><br><span class="line">    <span class="keyword">goto</span> restart;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里调用了 IPCThreadState 的 <code>transact()</code> 方法，其中传入的 <code>binderHandle()</code> 是接收端 BBinder 的句柄。</p>
<p><code>IPCThreadState::self()</code> 用来获取当前线程的 IPCThreadState 单例，不存在则创建。我们先看一下 IPCThreadState 的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/IPCThreadState.cpp</span></span><br><span class="line">IPCThreadState::<span class="built_in">IPCThreadState</span>()</span><br><span class="line">      : <span class="built_in">mProcess</span>(ProcessState::<span class="built_in">self</span>()),</span><br><span class="line">        ...,</span><br><span class="line">        <span class="built_in">mCallRestriction</span>(mProcess-&gt;mCallRestriction) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ProcessState 是一个进程内的单例对象，同样地 <code>ProcessState::self()</code> 获取该对象，不存在则创建。实际上此处的 ProcessState 单例已经存在了，每个 App 进程在被 Zygote 进程 fork 出以后会调用到 <code>app_main.cpp</code> 中的 <code>onZygoteInit()</code> 函数，在这里会创建该进程的 ProcessState 并开启 Binder 线程池。下面我们从 <code>onZygoteInit()</code> 看下 Binder 的初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/cmds/app_process/app_main.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onZygoteInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建ProcessState单例</span></span><br><span class="line">    sp&lt;ProcessState&gt; proc = ProcessState::<span class="built_in">self</span>();</span><br><span class="line">    <span class="comment">// 启动Binder线程池</span></span><br><span class="line">    proc-&gt;<span class="built_in">startThreadPool</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建processstate"><a class="markdownIt-Anchor" href="#创建processstate"></a> 创建ProcessState</h4>
<p>这里通过单例模式创建了一个 ProcessState 对象，直接看下其构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/ProcessState.cpp</span></span><br><span class="line">ProcessState::<span class="built_in">ProcessState</span>(<span class="type">const</span> <span class="type">char</span>* driver)</span><br><span class="line">      : <span class="built_in">mDriverName</span>(<span class="built_in">String8</span>(driver)),</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">mCallRestriction</span>(CallRestriction::NONE) &#123;</span><br><span class="line">    ...</span><br><span class="line">    base::Result&lt;<span class="type">int</span>&gt; opened = <span class="built_in">open_driver</span>(driver);</span><br><span class="line">    mVMStart = <span class="built_in">mmap</span>(<span class="literal">nullptr</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE,</span><br><span class="line">                        opened.<span class="built_in">value</span>(), <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先调用 <code>open_driver()</code> 打开 Binder 驱动，然后通过 mmap 系统调用开启 Binder 驱动中用于接收数据的内存映射。</p>
<h4 id="开启binder线程池"><a class="markdownIt-Anchor" href="#开启binder线程池"></a> 开启Binder线程池</h4>
<p>由于每次完整的 Binder 通讯都需要循环读写驱动，在此过程中会阻塞当前线程，所以开启多个线程处理多任务是必然的选择。</p>
<p>ProcessState 创建时会开启一个新线程作为 Binder 主线程无限循环读 Binder 驱动，每当读到一个来自其他进程的通讯请求时，当前线程处理该请求，然后再创建一个线程作为 Binder 普通线程继续循环处理后续请求（不能超过 Binder 进程中的最大线程数），提高响应速度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/ProcessState.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ProcessState::startThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">spawnPooledThread</span>(<span class="literal">true</span>); <span class="comment">// 创建一个新线程</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ProcessState::spawnPooledThread</span><span class="params">(<span class="type">bool</span> isMain)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    sp&lt;Thread&gt; t = sp&lt;PoolThread&gt;::<span class="built_in">make</span>(isMain);</span><br><span class="line">    t-&gt;<span class="built_in">run</span>(name.<span class="built_in">string</span>()); <span class="comment">// 最终会调用到PoolThread::threadLoop()</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此时运行在新线程中，将新线程注册为Binder主线程</span></span><br><span class="line">    IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">joinThreadPool</span>(mIsMain);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>PoolThread::run()</code> 经过一系列调用最后会调用到 <code>PoolThread::threadLoop()</code>。看下其中的 <code>joinThreadPool()</code> 方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/cmds/app_process/app_main.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onZygoteInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建ProcessState单例</span></span><br><span class="line">    sp&lt;ProcessState&gt; proc = ProcessState::<span class="built_in">self</span>();</span><br><span class="line">    <span class="comment">// 启动Binder线程池</span></span><br><span class="line">    proc-&gt;<span class="built_in">startThreadPool</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无限循环调用 <code>getAndExecuteCommand()</code> 来读取并处理命令，这里会进入 <code>BR_SPAWN_LOOPER</code> 分支：</p>
<h6 id="锚点1"><a class="markdownIt-Anchor" href="#锚点1"></a> 锚点1</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/IPCThreadState.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::getAndExecuteCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"> <span class="comment">// 与Driver通信</span></span><br><span class="line">    result = <span class="built_in">talkWithDriver</span>();</span><br><span class="line">    <span class="keyword">if</span> (result &gt;= NO_ERROR) &#123;</span><br><span class="line">        ...</span><br><span class="line">        cmd = mIn.<span class="built_in">readInt32</span>();</span><br><span class="line">        result = <span class="built_in">executeCommand</span>(cmd); <span class="comment">// 执行命令</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;BBinder&gt; the_context_object;</span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::executeCommand</span><span class="params">(<span class="type">int32_t</span> cmd)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> ((<span class="type">uint32_t</span>)cmd) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> BR_SPAWN_LOOPER:</span><br><span class="line">        <span class="comment">// 创建一个新线程，开启对Driver的循环监听</span></span><br><span class="line">        <span class="comment">// 这里isMain为false，所以会被注册为普通Binder线程</span></span><br><span class="line">        mProcess-&gt;<span class="built_in">spawnPooledThread</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BR_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">            binder_transaction_data&amp; tr = tr_secctx.transaction_data;</span><br><span class="line">            <span class="comment">// binder_transaction_data.cookie转为BBinder指针</span></span><br><span class="line">            <span class="comment">// 并调用BBinder的transact()方法将数据回传给Java层</span></span><br><span class="line">            error = <span class="built_in">reinterpret_cast</span>&lt;BBinder*&gt;(tr.cookie)-&gt;<span class="built_in">transact</span>(tr.code, buffer,</span><br><span class="line">                                                                    &amp;reply, tr.flags);</span><br><span class="line">            <span class="comment">// 向客户端发送reply</span></span><br><span class="line">            <span class="built_in">sendReply</span>(reply, (tr.flags &amp; kForwardReplyFlags));</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"> ...</span><br><span class="line">    &#125;</span><br><span class="line"> ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#%E9%94%9A%E7%82%B92">返回</a></p>
<p>分析了Binder的初始化，我们接着看 <code>IPCThreadState.transact()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/IPCThreadState.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::transact</span><span class="params">(<span class="type">int32_t</span> handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  Parcel* reply, <span class="type">uint32_t</span> flags)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 对将要发送的数据进行封装</span></span><br><span class="line">    err = <span class="built_in">writeTransactionData</span>(BC_TRANSACTION, flags, handle, code, data, <span class="literal">nullptr</span>);</span><br><span class="line">    ...</span><br><span class="line">    err = <span class="built_in">waitForResponse</span>(reply); <span class="comment">// 向接收端发送数据并等待响应</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先来看下 <code>writeTransactionData()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/IPCThreadState.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::writeTransactionData</span><span class="params">(<span class="type">int32_t</span> cmd, <span class="type">uint32_t</span> binderFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int32_t</span> handle, <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data, <span class="type">status_t</span>* statusBuffer)</span> </span>&#123;</span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">    tr.target.ptr = <span class="number">0</span>;</span><br><span class="line">    tr.target.handle = handle; <span class="comment">// 服务端BBinder对应的句柄</span></span><br><span class="line">    tr.code = code;</span><br><span class="line">    tr.data.ptr.buffer = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(statusBuffer);</span><br><span class="line">    tr.data.ptr.offsets = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    mOut.<span class="built_in">writeInt32</span>(cmd); <span class="comment">// cmd是传入的BC_TRANSACTION</span></span><br><span class="line">    mOut.<span class="built_in">write</span>(&amp;tr, <span class="built_in">sizeof</span>(tr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里将 Parcel、handle 等数据封装为 binder_transaction_data 结构体，然后将 <code>BC_TRANSACTION</code> 和此结构体写入 mOut（Parcel 类型），mOut 用于写入内核。再来看下 <code>waitForResponse()</code>：</p>
<h6 id="锚点3"><a class="markdownIt-Anchor" href="#锚点3"></a> 锚点3</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/IPCThreadState.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="type">status_t</span> *acquireResult)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> cmd;</span><br><span class="line">    <span class="type">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用talkWithDriver()</span></span><br><span class="line">        <span class="keyword">if</span> ((err=<span class="built_in">talkWithDriver</span>()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        err = mIn.<span class="built_in">errorCheck</span>();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.<span class="built_in">dataAvail</span>() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        cmd = (<span class="type">uint32_t</span>)mIn.<span class="built_in">readInt32</span>();</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            <span class="comment">// 这里reply为true，表示需要等待接收端的响应BR_TRANSACTION（即还没有等到）</span></span><br><span class="line">            <span class="comment">// 因此会走break跳出switch，但跳不出while(1)循环</span></span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BR_REPLY:</span><br><span class="line">            &#123;</span><br><span class="line">                binder_transaction_data tr;</span><br><span class="line">                err = mIn.<span class="built_in">read</span>(&amp;tr, <span class="built_in">sizeof</span>(tr));</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">finish:</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (acquireResult) *acquireResult = err;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;<span class="built_in">setError</span>(err);</span><br><span class="line">        mLastError = err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>talkWithDriver()</code> 函数真正与 Driver 进行通信：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/IPCThreadState.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::talkWithDriver</span><span class="params">(<span class="type">bool</span> doReceive)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 将mIn、mOut中的数据封装到binder_write_read结构体</span></span><br><span class="line">    binder_write_read bwr;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> outAvail = (!doReceive || needRead) ? mOut.<span class="built_in">dataSize</span>() : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (<span class="type">uintptr_t</span>)mOut.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        bwr.read_size = mIn.<span class="built_in">dataCapacity</span>();</span><br><span class="line">        bwr.read_buffer = (<span class="type">uintptr_t</span>)mIn.<span class="built_in">data</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 通过ioctl调用Driver层的读写函数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ioctl</span>(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Driver 层处理完返回，<code>talkWithDriver()</code> 处理完此次通讯也返回，回到 <code>IPCThreadState::waitForResponse()</code>，读取处理 mIn 中 Driver 写入的 <code>BR_TRANSACTION_COMPLETE</code> 对应的数据。</p>
<p>处理完 <code>BR_TRANSACTION_COMPLETE</code> 后，由于需要等待接收端的 reply，所以会继续循环 <code>talkWithDriver()</code>，等待 reply。</p>
<h6 id="锚点2"><a class="markdownIt-Anchor" href="#锚点2"></a> 锚点2</h6>
<p>当 Driver 层处理完返回时，会回到 <a href="#%E9%94%9A%E7%82%B91"><code>IPCThreadState::getAndExecuteCommand()</code></a>，接着 <code>talkWithDriver()</code> 往下执行，读取 mIn 中来自 Driver 的数据，调用 <a href="#%E9%94%9A%E7%82%B91"><code>executeCommand()</code></a> 进行处理。</p>
<p>此时会进入 <code>BR_TRANSACTION</code> 这个分支，调用 <code>BBinder.transact()</code> 将数据回传给 Java 层，最后调用 <code>sendReply()</code> 向客户端发送 reply。</p>
<p>这里的 BBinder 实际上是 JavaBBinder，前者是后者的父类。</p>
<blockquote>
<p>Java 层 Binder 初始化过程中会调用到 Native 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/os/Binder.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Binder</span><span class="params">(<span class="meta">@Nullable</span> String descriptor)</span> &#123;</span><br><span class="line">mObject = getNativeBBinderHolder();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看下其相应的 Native 方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/android_util_Binder.cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">android_os_Binder_getNativeBBinderHolder</span><span class="params">(JNIEnv* env, jobject clazz)</span> </span>&#123;</span><br><span class="line">JavaBBinderHolder* jbh = <span class="keyword">new</span> <span class="built_in">JavaBBinderHolder</span>();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JavaBBinderHolder</span> &#123; <span class="comment">// 其中包含了JavaBBinder类型的成员变量</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">wp&lt;JavaBBinder&gt; mBinder;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JavaBBinder</span> : <span class="keyword">public</span> BBinder &#123;&#125;; <span class="comment">// JavaBBinder继承自BBinder</span></span><br></pre></td></tr></table></figure>
<p>所以最终效果就是，Java 层初始化 Binder 时，会在 Native 层创建相应的 JavaBBinder 对象。</p>
</blockquote>
<p>由于 JavaBBinder 中没有实现了 <code>transact()</code> 方法，所以会调用其父类 BBinder 中的方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/Binder.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BBinder::transact</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data, Parcel* reply, <span class="type">uint32_t</span> flags)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            err = <span class="built_in">onTransact</span>(code, data, reply, flags);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> ...</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JavaBBinder 中实现了 <code>onTransact()</code> 方法，所以这里实际会调用到 JavaBBinder 中的方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/android_util_Binder.cpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JavaBBinder</span> : <span class="keyword">public</span> BBinder &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">status_t</span> <span class="title">onTransact</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data, Parcel* reply, <span class="type">uint32_t</span> flags = <span class="number">0</span>)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        JNIEnv* env = <span class="built_in">javavm_to_jnienv</span>(mVM);</span><br><span class="line">        <span class="comment">// 反射调用到Java层的execTransact()这个boolean方法</span></span><br><span class="line">        jboolean res = env-&gt;<span class="built_in">CallBooleanMethod</span>(mObject, gBinderOffsets.mExecTransact,</span><br><span class="line">            code, <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(&amp;data), <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(reply), flags);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> res != JNI_FALSE ? NO_ERROR : UNKNOWN_TRANSACTION;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>回到 Java 层，看下 Binder 的 <code>execTransact()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/os/Binder.java</span></span><br><span class="line"><span class="comment">// Entry point from android_util_Binder.cpp&#x27;s onTransact.</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">execTransact</span><span class="params">(<span class="type">int</span> code, <span class="type">long</span> dataObj, <span class="type">long</span> replyObj,</span></span><br><span class="line"><span class="params">                             <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> execTransactInternal(code, dataObj, replyObj, flags, callingUid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">execTransactInternal</span><span class="params">(<span class="type">int</span> code, <span class="type">long</span> dataObj, <span class="type">long</span> replyObj, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                                     <span class="type">int</span> callingUid)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    res = onTransact(code, data, reply, flags);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里调用了 Binder 的 <code>onTransact()</code> 方法，这实际上最后又会调用到 AIDL 层的相应方法。</p>
<p>现在客户端还在等待响应，回到 <a href="#%E9%94%9A%E7%82%B91"><code>IPCThreadState::sendReply()</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/IPCThreadState.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::sendReply</span><span class="params">(<span class="type">const</span> Parcel&amp; reply, <span class="type">uint32_t</span> flags)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 写入BC_REPLY，一路传送到Driver层进行处理</span></span><br><span class="line">    err = <span class="built_in">writeTransactionData</span>(BC_REPLY, flags, <span class="number">-1</span>, <span class="number">0</span>, reply, &amp;statusBuffer);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">waitForResponse</span>(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后来个函数调用的简化图：</p>
<p><img src="https://img.gejiba.com/images/f55a9189c2220d323b0f2c5640f990ae.webp" alt="image-20220924230904431" /></p>
<p>至此，整个通讯过程结束。</p>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
  </entry>
  <entry>
    <title>JNI学习</title>
    <url>/posts/2872386792.html</url>
    <content><![CDATA[<h2 id="jni的作用"><a class="markdownIt-Anchor" href="#jni的作用"></a> JNI的作用</h2>
<p>JNI 是 Java Native Interface（Java 本地接口）的缩写，能使 Java 和 Native 实现互调。</p>
<p>Android 作为一种嵌入式系统，有大量跟驱动、硬件相关的功能必须在 Native 层实现，还有一些注重性能、功耗的功能使用 Native 实现也要优于 Java。在 Android 中，Java 主要负责 UI 功能的实现，而 Native 则完成一些复杂的算法以及与底层交互的，因此二者的交互特别频繁，JNI 的重要性不言而喻。</p>
<p>Java 的执行离不开虚拟机，因此当需要在 Java 中调用 Native 层函数时，需要告诉虚拟机哪个方法代表 Native 函数，以及在哪里能找到这个函数，反之亦然。二者之间的区别是：</p>
<ul>
<li>从 Java 到 Native 建立的是函数关联。</li>
<li>从 Native 到 Java 必须先得到 Java 对象的引用，才能调用该对象的方法。</li>
</ul>
<p>需要注意的是，二者之间的交互并没有跨线程调用，它们都在同一个线程中运行。但它们打印出的线程 ID 值是不同的，这仅仅是因为二者所使用的线程 ID 的表示方法不同。</p>
<img src="https://img.gejiba.com/images/bc2c347a75bed0e4ba8a9c82329b9942.webp" alt="Snipaste_2022-09-21_23-12-34" style="zoom:40%;" />
<blockquote>
<p>Dalvik 虚拟机（Dalvik Virtual Machine，DVM）不同于 JVM，它是 Google 公司自己设计的用于 Android 平台的 Java 虚拟机。</p>
</blockquote>
<h2 id="jni的用法"><a class="markdownIt-Anchor" href="#jni的用法"></a> JNI的用法</h2>
<h3 id="java调用native"><a class="markdownIt-Anchor" href="#java调用native"></a> Java调用Native</h3>
<p><strong>1. 编写 Java 文件 <code>HelloJni.java</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloJni</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// System.load()和System.loadLibrary()都可以在加载Native所在库</span></span><br><span class="line">        <span class="comment">// 区别在于，前者需要指定库的绝对路径和文件扩展名</span></span><br><span class="line">        <span class="comment">// 后者只需指定动态库文件名，并且要去掉lib前缀和.so后缀</span></span><br><span class="line">        <span class="comment">// 系统会直接从配置的Java环境变量中查找该库</span></span><br><span class="line">        System.load(<span class="string">&quot;/work/oppo_80378568/myCode/jni/j2n/hellojni.so&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HelloJni</span> <span class="variable">helloJni</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloJni</span>();</span><br><span class="line">        helloJni.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为了从加载库中访问native方法，必须使用native关键字来声明</span></span><br><span class="line">    <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了保证调用 native 方法前所需要的动态库已经装载到进程的内存空间，加载方法一般会放在 static 中，这样进程初始化时就能执行装载语句了。</p>
<p><strong>2. 编译生成 <code>HelloJni.class</code></strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javac HelloJni.java</span><br></pre></td></tr></table></figure>
<p><strong>3. 根据 class 文件生成 C 头文件 <code>HelloJni.h</code></strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javah HelloJni</span><br></pre></td></tr></table></figure>
<p>看一下生成的头文件内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Header for class HelloJni */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _Included_HelloJni</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Included_HelloJni</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     HelloJni</span></span><br><span class="line"><span class="comment"> * Method:    sayHello</span></span><br><span class="line"><span class="comment"> * Signature: ()V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT <span class="type">void</span> JNICALL <span class="title function_">Java_HelloJni_sayHello</span></span><br><span class="line">  <span class="params">(JNIEnv *, jobject)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><strong>4. 创建 C 文件 <code>HelloJni.c</code></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HelloJni.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法在HelloJni.h头文件中声明</span></span><br><span class="line"><span class="comment">  JNIEXPORT和JNICALL都是JNI中的关键字</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">JNIEXPORT <span class="type">void</span> JNICALL <span class="title function_">Java_HelloJni_sayHello</span><span class="params">(JNIEnv *env, jobject obj)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world from Native.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5. 编译生成动态库 <code>hellojni.so</code></strong></p>
<p>在生成的 <code>HelloJni.h</code> 头文件中包含了 <code>jni.h</code> 头文件，<code>jni.h</code> 中又包括了 <code>jni_md.h</code> 头文件，但这两个头文件只是在 jdk 的安装目录中，却不在系统的头文件目录中，gcc 不知道该去哪里找这两个文件，因此需要指定这两个头文件所在的路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc HelloJni.c -fPIC -shared -o hellojni.so -I /usr/lib/jvm/java-8-openjdk-amd64/include/ -I /usr/lib/jvm/java-8-openjdk-amd64/include/linux/</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看 jdk 路径的方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">which</span> java</span><br><span class="line">/usr/bin/java</span><br><span class="line">$ <span class="built_in">ls</span> -lrt /usr/bin/java</span><br><span class="line">lrwxrwxrwx 1 root root 22 Apr  9  2021 /usr/bin/java -&gt; /etc/alternatives/java</span><br><span class="line">$ <span class="built_in">ls</span> -lrt /etc/alternatives/java</span><br><span class="line">lrwxrwxrwx 1 root root 46 Apr  9  2021 /etc/alternatives/java -&gt; /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java</span><br></pre></td></tr></table></figure>
<p>其中 <code>ls -lrt</code> 会按修改时间倒序列出指定目录下的所有文件信息。</p>
<p>所以，jdk 的路径就是 <code>/usr/lib/jvm/java-8-openjdk-amd64</code>。</p>
</blockquote>
<p><strong>6. 执行 class 文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java HelloJni</span><br></pre></td></tr></table></figure>
<p>可以看到打印出了字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello world from Native.</span><br></pre></td></tr></table></figure>
<h3 id="native调用java"><a class="markdownIt-Anchor" href="#native调用java"></a> Native调用Java</h3>
<p>在上面的基础上再增加 Native 对 Java 层的调用。将 <code>j2n</code> 目录拷贝一份到 <code>n2j</code>，并在此基础上增加代码。</p>
<p><strong>1. 编写 Java 文件 <code>HelloJni.java</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloJni</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.load(<span class="string">&quot;/work/oppo_80378568/myCode/jni/n2j/hellojni.so&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新增Java层方法，供Native调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world from Java.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HelloJni</span> <span class="variable">helloJni</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloJni</span>();</span><br><span class="line">        helloJni.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Java 中新增了 <code>sayHi()</code> 方法，之后会在 native 函数 <code>sayHello()</code> 中调用。</p>
<p><strong>2. 编译生成 <code>HelloJni.class</code></strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javac HelloJni.java</span><br></pre></td></tr></table></figure>
<p><strong>3. 根据 class 文件生成 C 头文件 <code>HelloJni.h</code></strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javah HelloJni</span><br></pre></td></tr></table></figure>
<p>文件内容跟之前是一样的，因为在 Java 中没有新增 native 方法。</p>
<p><strong>4. 创建 C 文件 <code>HelloJni.c</code></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HelloJni.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// env对应Java线程中调用的JNI环境，通过这个参数可以调用一些JNI函数</span></span><br><span class="line"><span class="comment">// obj对应当前Java线程中调用本地方法的对象</span></span><br><span class="line">JNIEXPORT <span class="type">void</span> JNICALL <span class="title function_">Java_HelloJni_sayHello</span><span class="params">(JNIEnv *env, jobject obj)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world from Native.\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里在调用Java中的sayHi()方法</span></span><br><span class="line">    jclass clazz = (*env)-&gt;FindClass(env, <span class="string">&quot;HelloJni&quot;</span>); <span class="comment">// 获取Java Class</span></span><br><span class="line">    jmethodID sayHiId = (*env)-&gt;GetMethodID(env, clazz, <span class="string">&quot;sayHi&quot;</span>, <span class="string">&quot;()V&quot;</span>); <span class="comment">// 获取Java中sayHi()方法所对应的ID</span></span><br><span class="line">    (*env)-&gt;CallVoidMethod(env, obj, sayHiId); <span class="comment">// 调用Java中的sayHi()方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JNIEnv 是一个代表 JNI 环境的结构体，定义在 <code>sys/libnativehelper/include_jni/jni.h</code> 文件中，通过它可以调用一些 JNI 函数。jobject 是正在调用当前方法的 Java 对象。</p>
<blockquote>
<p>GetMethodID 的最后一个参数是前一个参数（<code>sayHi()</code> 方法）在 Java 中所对应的签名，可通过 <code>javap -s -p</code> 查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ javap -s -p HelloJni.class</span><br><span class="line">Compiled from <span class="string">&quot;HelloJni.java&quot;</span></span><br><span class="line">public class HelloJni &#123;</span><br><span class="line">public HelloJni();</span><br><span class="line"> descriptor: ()V</span><br><span class="line"></span><br><span class="line">public void sayHi();</span><br><span class="line"> descriptor: ()V</span><br><span class="line"></span><br><span class="line">public static void main(java.lang.String[]);</span><br><span class="line"> descriptor: ([Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">native void sayHello();</span><br><span class="line"> descriptor: ()V</span><br><span class="line"></span><br><span class="line">static &#123;&#125;;</span><br><span class="line"> descriptor: ()V</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>5. 编译生成动态库 <code>hellojni.so</code></strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc HelloJni.c -fPIC -shared -o hellojni.so -I /usr/lib/jvm/java-8-openjdk-amd64/include/ -I /usr/lib/jvm/java-8-openjdk-amd64/include/linux/</span><br></pre></td></tr></table></figure>
<p><strong>6. 执行 class 文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java HelloJni</span><br></pre></td></tr></table></figure>
<p>可以看到打印出了字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello world from Native.</span><br><span class="line">Hello world from Java.</span><br></pre></td></tr></table></figure>
<h3 id="综合"><a class="markdownIt-Anchor" href="#综合"></a> 综合</h3>
<p>最后再看个稍微复杂点的，还是在之前的基础上做进一步扩充，实现 Java 与 Native 之间的互相调用与变量修改。</p>
<p><strong>Java 文件：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloJni</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.load(<span class="string">&quot;/work/oppo_80378568/myCode/jni/advanced/hellojni.so&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Hello world from Java.&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HelloJni</span> <span class="variable">helloJni</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloJni</span>();</span><br><span class="line">        <span class="comment">// 调用native中的sayHello()打印字符串</span></span><br><span class="line">        <span class="comment">// 同时native会调用Java中的sayHi()打印字符串</span></span><br><span class="line">        helloJni.sayHello();</span><br><span class="line">        <span class="comment">// 调用native的changeMsg()修改这里的msg</span></span><br><span class="line">        <span class="comment">// 同时会将修改之前的msg打印出来</span></span><br><span class="line">        helloJni.changeMsg();</span><br><span class="line">        <span class="comment">// Java正常调用sayHi()输出修改之后的msg</span></span><br><span class="line">        helloJni.sayHi();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">changeMsg</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>C 文件：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HelloJni.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="type">void</span> JNICALL <span class="title function_">Java_HelloJni_sayHello</span><span class="params">(JNIEnv *env, jobject obj)</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Hello world from Native.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用Java中的sayHi()方法</span></span><br><span class="line">    jclass clazz = (*env)-&gt;FindClass(env, <span class="string">&quot;HelloJni&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(clazz == <span class="literal">NULL</span>)  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    jmethodID sayHiId = (*env)-&gt;GetMethodID(env, clazz, <span class="string">&quot;sayHi&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(sayHiId == <span class="literal">NULL</span>)  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    (*env)-&gt;CallVoidMethod(env, obj, sayHiId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="type">void</span> JNICALL <span class="title function_">Java_HelloJni_changeMsg</span><span class="params">(JNIEnv *env, jobject obj)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取Java Class</span></span><br><span class="line">    jclass clazz = (*env)-&gt;FindClass(env, <span class="string">&quot;HelloJni&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(clazz == <span class="literal">NULL</span>)  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取Java中msg变量所对应的ID</span></span><br><span class="line">    jfieldID msgId = (*env)-&gt;GetFieldID(env, clazz, <span class="string">&quot;msg&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(msgId == <span class="literal">NULL</span>)  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取msg所对应的值，保存为jstring类型</span></span><br><span class="line">    jstring msg_obj = (*env)-&gt;GetObjectField(env, obj, msgId);</span><br><span class="line">    <span class="keyword">if</span>(msg_obj == <span class="literal">NULL</span>)  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jstring使用前需要进行转换，比如这里转换成了UTF-8字符串</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *msg_char = (*env)-&gt;GetStringUTFChars(env, msg_obj, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">puts</span>(msg_char); <span class="comment">// 将从Java读到的msg打印出来</span></span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env, msg_obj, msg_char); <span class="comment">// 使用完后记得释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在Native中生成新的jstring</span></span><br><span class="line">    jstring msg_new = (*env)-&gt;NewStringUTF(env, <span class="string">&quot;Hello world was changed by Native.&quot;</span>);</span><br><span class="line">    <span class="comment">// 将新的jstring赋值到Java中msgId所对应的变量上</span></span><br><span class="line">    (*env)-&gt;SetObjectField(env, obj, msgId, msg_new);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>看一下 Java 中所有变量和方法所对应的签名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ javap -s -p HelloJni.class</span><br><span class="line">Compiled from <span class="string">&quot;HelloJni.java&quot;</span></span><br><span class="line">public class HelloJni &#123;</span><br><span class="line">private java.lang.String msg;</span><br><span class="line"> descriptor: Ljava/lang/String;</span><br><span class="line">public HelloJni();</span><br><span class="line"> descriptor: ()V</span><br><span class="line"></span><br><span class="line">public void sayHi();</span><br><span class="line"> descriptor: ()V</span><br><span class="line"></span><br><span class="line">public static void main(java.lang.String[]);</span><br><span class="line"> descriptor: ([Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">native void sayHello();</span><br><span class="line"> descriptor: ()V</span><br><span class="line"></span><br><span class="line">native void changeMsg();</span><br><span class="line"> descriptor: ()V</span><br><span class="line"></span><br><span class="line">static &#123;&#125;;</span><br><span class="line"> descriptor: ()V</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>运行结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello world from Native.</span><br><span class="line">Hello world from Java.</span><br><span class="line">Hello world from Java.</span><br><span class="line">Hello world was changed by Native.</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
  </entry>
  <entry>
    <title>Android渲染的整体架构</title>
    <url>/posts/3659942439.html</url>
    <content><![CDATA[<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2>
<p>Android 渲染的整体架构是一个生产者-消费者模型：</p>
<img src="https://img.gejiba.com/images/dc7119c538dc0fc967645cc30fa096cd.webp" alt="生产者-消费者模型" style="zoom:100%;" />
<p>当用户程序刷新 UI 时，会从 从 BufferQueue 中 dequeue 一个空的 Buffer，然后把 UI 信息填入，再 queue 到 BufferQueue 中。SurfaceFlinger 从 BufferQueue 中 acquire 绘制好的 Buffer 并 release 掉空的 Buffer，然后请求 HWC 进行图像合成，最终送到显示器上进行显示。</p>
<p><strong>常见的图像生产者</strong>：</p>
<ul>
<li>
<p>OpenGL： Open Graphics Library，一种跨平台的 3D 绘图规范接口。</p>
</li>
<li>
<p>OpenGL ES： OpenGL for Embedded Systems，OpenGL 的子集，能够绘制 <strong>纹理</strong>。</p>
<blockquote>
<p>纹理即物体表面的样子。在计算机世界中，只通过几何图形并不能很好地展示现实中的物体，因此我们通常会通过纹理映射的方式将物体表面的图片贴到几何图形上面，从而更好地模拟现实世界。纹理可以理解为物体表面的图片。</p>
</blockquote>
</li>
<li>
<p>Skia：  一种跨平台的 2D 绘图规范接口。</p>
</li>
<li>
<p>Vulkan： 一种跨平台的 2D 和 3D 绘图规范接口，更轻量级。</p>
</li>
</ul>
<p><strong>常见的图像缓冲区</strong>：</p>
<ul>
<li>BufferQueue：里面存放的是 GraphicBuffer。</li>
</ul>
<p><strong>常见的图像消费者</strong>：</p>
<ul>
<li>SurfaceFlinger：用于叠加 Layer，后续会重点介绍。</li>
</ul>
<p>接下来就分别介绍一下这三者。</p>
<h2 id="图像生产者"><a class="markdownIt-Anchor" href="#图像生产者"></a> 图像生产者</h2>
<p>一切可以产生图像数据的对象都叫图像生产者。</p>
<p>这里需要强调的是，UI 组件在绘制到屏幕之前都要经过 Rasterizatioin（<strong>栅格化</strong>）操作，这个过程非常耗时，而 GPU 的引入就是为了加快这个过程的。</p>
<blockquote>
<p>所谓栅格化，就是将 UI 组件以像素的形式填充到屏幕的像素晶体管中。</p>
</blockquote>
<p>图像的绘制有两种方式：</p>
<img src="https://img.gejiba.com/images/0c93c24acdcf0377dcd7ed11f2f13241.webp" alt="image-20220904195349934" style="zoom:100%;" />
<ul>
<li>
<p>软件绘制就是使用 Skia 库，通过 CPU 指令来完成绘制的过程。</p>
</li>
<li>
<p>硬件绘制是将 CPU 不擅长的图形计算转换成 GPU 专用指令，由 GPU 来完成绘制任务，以实现更好的性能。现代的 Android 系统都默认开启了硬件加速。</p>
</li>
</ul>
<h2 id="图像缓冲区"><a class="markdownIt-Anchor" href="#图像缓冲区"></a> 图像缓冲区</h2>
<p>此时图像生产者已经生产好了数据，这些数据会放入图像缓冲区 BufferQueue 中。</p>
<p>可以思考一下，<strong><span class="p red">当只有一个缓冲区时会存在什么问题呢？</span></strong></p>
<p>此时图像的显示过程如下：</p>
<img src="https://img.gejiba.com/images/a9e6e2b4175378b3d786ac7c47f3ade0.webp" alt="image-20220904201018752" style="zoom:90%;" />
<p>显示器会将显存里的数据按照从左到右、从上到下的顺序同步到屏幕上的每一个像素晶体管，当扫描到右下角的时候，就完成了一帧的绘制，然后会重置扫描点，即再回到左上角开始绘制下一帧。</p>
<p>这时存在的问题就是，在绘制过程中，对于已经绘制好的帧数据是无法放入 FrameBuffer 去进行显示的，只能等这一帧绘制完成，这种情况下就会存在很大的效率和延时问题。</p>
<p>于是引入了双缓冲机制。</p>
<h3 id="双缓冲机制"><a class="markdownIt-Anchor" href="#双缓冲机制"></a> 双缓冲机制</h3>
<p>双缓冲机制即让绘制和显示器拥有各自的 Buffer。GPU 始终在 BackBuffer 中写入数据，而用 FrameBuffer 来显示数据。</p>
<img src="https://img.gejiba.com/images/c4cd044aa92ceb6b01ce44d0386c2aba.webp" alt="image-20220904201702821" style="zoom:100%;" />
<p>当屏幕刷新时，如果 BackBuffer 没有准备就绪，FrameBuffer 并不会发生变化；只有当其准备好后，它们才进行交换，这就是所谓的 <strong>PageFlipping</strong>（画面交换）。</p>
<p>因此，双缓冲机制基本解决了图像显示的效率问题。而在 Android 4.0 之前，Android 采用的就是这种机制。</p>
<p>但这种机制仍然存在问题。在看具体的问题之前，我们先来看一下黄油计划。</p>
<h3 id="黄油计划"><a class="markdownIt-Anchor" href="#黄油计划"></a> 黄油计划</h3>
<p>Google 在 2012 年的 I/O 大会上宣布了 Project Butter（黄油计划），并且在 Android 4.1 中正式开启了这个机制。理解黄油计划的核心就是 VSync（Vertical Synchronization）。</p>
<p>当没有 VSync 时：</p>
<img src="https://img.gejiba.com/images/07983e962643d82b88130bcff046b50c.webp" alt="image-20220904205238423" style="zoom:100%;" />
<ul>
<li>第一个 VSync 信号到来时，第 1 帧数据已准备好，因此可以正常显示第 1 帧的画面。</li>
<li>当第二个 VSync 信号到来时，第 2 帧数据还没有绘制好，因此只能继续显示第 1 帧的画面，这种情况叫做 Jank，即丢帧。</li>
</ul>
<p><strong><span class="p red">为什么会出现 Jank 呢？</span></strong></p>
<p>这是因为在第一个 VSync 信号到来的时候，CPU 还在忙其他事，直到第二个 VSync 信号到来的时候才腾出手来去进行绘制，导致之前的一大段时间都被浪费了，于是便发生了 Jank。</p>
<p>为了解决这个问题，在 Android 4.1 版本中，系统一旦收到 VSync 信号，CPU 和 GPU 就会立刻开始计算并把数据写入 Buffer。VSync 同步使得 CPU/GPU 充分利用了 16.6 ms 时间，从而减少了 Jank。</p>
<img src="https://img.gejiba.com/images/856d1d048d9402441756738bb5f75766.webp" alt="image-20220904203541079" style="zoom:100%;" />
<blockquote>
<p><strong><span class="p red">16.6 ms 是怎么来的？</span></strong></p>
<p>现在屏幕的刷新率普遍都是 60 Hz，即一秒钟刷新 60 次。这是经过科学验证是数据，由于人眼的视觉停留效应，对于每秒 60 次的刷新速率并不会感受到屏幕的闪烁。而对于 60 Hz 的刷新率，平均每次刷新的时间就近似等于 16.6 ms。</p>
</blockquote>
<p>了解了 VSync，我们再来看下双缓冲机制存在的问题。</p>
<h3 id="双缓冲机制存在的问题"><a class="markdownIt-Anchor" href="#双缓冲机制存在的问题"></a> 双缓冲机制存在的问题</h3>
<p>如果界面比较复杂，或者设备硬件的性能本身较低，CPU/GPU 的时间就可能会超过 16.6 ms：</p>
<img src="https://img.gejiba.com/images/7d1d6415df8c5d02c13f2e154e8e12fd.webp" alt="image-20220904205308950" style="zoom:100%;" />
<ul>
<li>当第一个 VSync 信号到来时，由于 B 帧数据还没准备好，因此出现了一次 Jank。</li>
<li>当第三个 VSync 信号到来时，由于 A 帧数据没准备好，又出现了一次 Jank。</li>
</ul>
<p>我们可以发现，当第一个 VSync 到来的时候，CPU 其实并没有进行绘制，而是到第二个 VSync 到来时才开始绘制，因此第二段时间其实是被浪费掉了。</p>
<p><strong><span class="p red">那为什么在第一个 VSync 到来 CPU 不能进行绘制呢？</span></strong></p>
<p>这是因为只有两个缓冲区，当第二个 VSync 到来时 GPU 还没有绘制完，因此这个缓冲区是被占用的；而显示缓冲区也还在显示 A 帧的内容，也处于被占用的状态，所以 CPU 无法进行绘制。</p>
<p>问题分析到这里，解决办法也就很明显了，那就是再增加一个缓冲区。</p>
<h3 id="三缓冲机制"><a class="markdownIt-Anchor" href="#三缓冲机制"></a> 三缓冲机制</h3>
<p>即在双缓冲的基础上又增加了一个 GraphicBuffer，使得 CPU、GPU 和 屏幕显示各占一个 Buffer，互不影响。</p>
<img src="https://img.gejiba.com/images/0b493dd3c3915f5fa55e20de2556306d.webp" alt="image-20220904205322792" style="zoom:100%;" />
<p>此时第一个 Jank 仍然是不可避免的，但后续有效利用了等待 Vsync 的时间，从而避免了 Jank 的进一步加剧。</p>
<h3 id="renderthread"><a class="markdownIt-Anchor" href="#renderthread"></a> RenderThread</h3>
<p>此时 Android 的渲染性能已经有了很大的改善。</p>
<p>但是从计算 DisplayList，到通过 GPU 将图像绘制到 FrameBuffer，整个过程都在 UI 主线程中完成，UI 线程的任务过于繁重。如果整个渲染过程比较耗时，就可能造成无法响应用户的操作，进而出现卡顿的现象。</p>
<p>因此在 Android 5.0 中引入了 RenderThread，所有 Open GL 命令的执行都放到了这个线程上，这样即便主线程有耗时操作也能保证动画流程。</p>
<h2 id="图像消费者"><a class="markdownIt-Anchor" href="#图像消费者"></a> 图像消费者</h2>
<p>当生产者把绘制好的 GraphicBuffer 数据放入 BufferQueue 中之后，接下来的工作就是以 SurfaceFlinger 为代表的图像消费者来完成了。</p>
<p>Activity 绘制的界面图像都会传递到 SurfaceFlinger，其作用主要是从 BufferQueue 中取出 GraphicBuffer 并进行合成。Android 中 Layer 的合成机制有两种：</p>
<ul>
<li>在 GPU 中合成，即利用 OpenGL ES 进行合成，适合画面基本不变的图像。</li>
<li>在显示的硬件中进行合成，即 hardware overlay 机制，会将图像直接渲染到计算机视频硬件内部的专用内存缓冲区，适合快速变化的图像。</li>
</ul>
<img src="https://img.gejiba.com/images/b56d2f4d760969dcf10a18b87c5b946c.webp" alt="image-20220904205905044" style="zoom:100%;" />
<p>而最终采用哪种机制，则由 HardwareComposer（HWC）来决定。处理流程为：</p>
<ul>
<li>SurfaceFlinger 给 HWC 提供 Layer list，询问如何处理这些 Layer。</li>
<li>HWC 将每个 Layer 标记为 overlay 或 GLES composition，然后反馈给 SurfaceFlinger。</li>
<li>SurfaceFlinger 只需处理那些 GLES 的合成，最后将 overlay 的和 GLES 合成后的 Buffer 发送给 HWC 处理和显示。</li>
</ul>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>Android 图像的渲染机制是一个生产者-消费者模型：</p>
<img src="https://img.gejiba.com/images/f18fdd095d808163febcd5f79de6ee0e.webp" alt="image-20220904210130370" style="zoom:100%;" />
<p>上层函数通过 <code>draw()</code> 方法进行绘制，该方法会调用到 Surface 的 Canvas 画布中的绘制方法。该方法也没有真正去绘制，而是把绘制指令同步到了 RenderThread。</p>
<p>RenderThread 通过 dequeue 拿到一个空的 GraphicBuffer，然后使用 OpenGL ES 的绘制接口进行绘制。绘制完成之后，还需要经过 GPU 的栅格化得到最终的 GraphicBuffer。</p>
<p>这个 GraphicBuffer 会放到图像缓冲区 BufferQueue 中，SurfaceFlinger 从中取出 GraphicBuffer 并通过硬件设备进行 Layer 的合成，最终展示到屏幕上。</p>
]]></content>
      <categories>
        <category>Android之显示服务</category>
      </categories>
  </entry>
  <entry>
    <title>「高效能人士的七个习惯」读书笔记</title>
    <url>/posts/1441608745.html</url>
    <content><![CDATA[<blockquote>
<p>人的行为总是一再重复。因此卓越不是一时的行为，而是习惯。</p>
<div style="text-align:right">—— 亚里士多德&nbsp;&nbsp;&nbsp;&nbsp;</div>
</blockquote>
<p>习惯对我们的生活有极大的影响，选择什么样的习惯，也就决定了过什么样的生活。</p>
<p>但改变习惯绝非易事，就像宇宙飞船必须摆脱强大的地心引力一样，起飞需要巨大的努力，而一旦摆脱了引力的束缚，就会迎来广阔自由的天地。</p>
<p>本书正是教我们通过改变思维方式，由内而外地实现个人效能和人际效能。这里的效能作为衡量人生的单位，是指产出与产能的比值，其关键在于二者的平衡。书中介绍的七个习惯，能够帮助我们依次经历从依赖到独立，再从独立到互赖的成熟模式。</p>
<p>接下来我将简单整理一下这七个习惯：</p>
<h2 id="个人领域的成功"><a class="markdownIt-Anchor" href="#个人领域的成功"></a> 个人领域的成功</h2>
<p>从依赖走向独立，实现个人领域的成功。</p>
<h3 id="习惯一积极主动"><a class="markdownIt-Anchor" href="#习惯一积极主动"></a> 习惯一：积极主动</h3>
<p>在外界的刺激和我们的回应之间，还存在选择的自由，这就是高效能人士在任何环境中都应具备的最基本的习惯——积极主动。</p>
<p>积极主动是要为自己过去、现在及未来的行为负责，依据原则和价值观，而非情绪或外在环境来做决定。</p>
<p>“除非你愿意，否则没人能伤害你。”说的就是这个道理。</p>
<h3 id="习惯二以终为始"><a class="markdownIt-Anchor" href="#习惯二以终为始"></a> 习惯二：以终为始</h3>
<p>以终为始的一个原则基础是：任何事情都要经过两次创造，第一次是在头脑中，第二次是在实践中。</p>
<p>要改写自己人生的剧本，就要为自己人生的第一次创造负责，从而使决定我们行为和态度的思维方式能够真正符合自己的价值观和正确的原则。</p>
<p>以终为始最有效的方法就是撰写个人使命宣言，说明自己想成为什么样的人，成就什么样的事业，并据此塑造未来，全心投入自己最重视的价值观和原则。</p>
<h3 id="习惯三要事第一"><a class="markdownIt-Anchor" href="#习惯三要事第一"></a> 习惯三：要事第一</h3>
<p>要事第一，即总是先做最重要的事。可以通过时间管理矩阵来筛选要事，将所有事情根据是否紧急和是否重要进行分类。高效能人士总是避免陷入不重要的事务。</p>
<h2 id="公众领域的成功"><a class="markdownIt-Anchor" href="#公众领域的成功"></a> 公众领域的成功</h2>
<p>从独立走向互赖，实现公众领域的成功。</p>
<h3 id="习惯四双赢思维"><a class="markdownIt-Anchor" href="#习惯四双赢思维"></a> 习惯四：双赢思维</h3>
<p>双赢思维是一种基于合作、寻求互惠的思考框架。生活中很多事情并不是非胜即败的，世界之大，人人都有足够的立足空间，他人之得不必视为自己之失。</p>
<p>要完成双赢可以采取以下四个步骤：</p>
<ol>
<li>从对方角度看问题，真正理解对方的想法和顾虑</li>
<li>认清主要问题和顾虑</li>
<li>确定大家都能接受的结果</li>
<li>找到实现这种结果的各种可能路径</li>
</ol>
<p>如果实在无法达成共识实现双赢，还可以好聚好散。正所谓买卖不成仁义在，或许日后还有合作的机会。</p>
<h3 id="习惯五知彼解己"><a class="markdownIt-Anchor" href="#习惯五知彼解己"></a> 习惯五：知彼解己</h3>
<p>知彼解己，即先寻求了解对方，再争取让对方了解自己。</p>
<p>当我们不再急于回答，而是以真诚之心去了解、聆听别人时，便开启了真正的沟通。对方获得理解后，会觉得受到尊重和认可，进而卸下防备，坦然交谈。这时我们之间的分歧不再是交流的障碍，而是通往协同效应的阶梯。</p>
<p>知彼需要仁慈心，解己需要勇气。平衡二者，就能显著提升沟通效率。</p>
<h3 id="习惯六统合综效"><a class="markdownIt-Anchor" href="#习惯六统合综效"></a> 习惯六：统合综效</h3>
<p>统合综效就是整体大于部分之和，即各个部分之间的关系也是整体的一个组成部分，并且是最具激发、分配、整合和激励作用的部分。</p>
<p>实践统合综效的人际关系会扬弃敌对的态度（<code>1 + 1 = 0.5</code>），不以妥协为目标（<code>1 + 1 = 1.5</code>），也不仅仅止于合作（<code>1 + 1 = 2</code>），他们要的是创造式的合作（<code>1 + 1 &gt; 2</code>）。</p>
<p>该习惯寻求第三种选择，即抛弃双方各自的选择，创造第三种更好的办法。它是相互尊重的成果，不仅了解了彼此，还能欣赏和称赞双方的差异。</p>
<h2 id="自我提升和完善"><a class="markdownIt-Anchor" href="#自我提升和完善"></a> 自我提升和完善</h2>
<p>时时充电，达到真正的独立与成功的互赖。</p>
<h3 id="习惯七不断更新"><a class="markdownIt-Anchor" href="#习惯七不断更新"></a> 习惯七：不断更新</h3>
<p>习惯七是指从身体（锻炼、营养、压力调节）、精神（实现价值、忠诚、学习、冥想）、智力（阅读、想象、规划、写作）和社会/情感（服务、移情、统合综效、内在安全感）四个层面不断更新自己。</p>
<p>每个层面的更新都很重要，只有平衡好四个层面的更新进度，才能取得最理想的效果。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>这七个习惯并非零落的、分散的，而是渐进的、连续的，它们密不可分、相辅相成。</p>
<p>越是积极主动（<a href="#%E4%B9%A0%E6%83%AF%E4%B8%80%EF%BC%9A%E7%A7%AF%E6%9E%81%E4%B8%BB%E5%8A%A8">习惯一</a>），就越能在生活中有效实施自我领导（<a href="#%E4%B9%A0%E6%83%AF%E4%BA%8C%EF%BC%9A%E4%BB%A5%E7%BB%88%E4%B8%BA%E5%A7%8B">习惯二</a>）和管理（<a href="#%E4%B9%A0%E6%83%AF%E4%B8%89%EF%BC%9A%E8%A6%81%E4%BA%8B%E7%AC%AC%E4%B8%80">习惯三</a>）；越是有效管理自己的生活（<a href="#%E4%B9%A0%E6%83%AF%E4%B8%89%EF%BC%9A%E8%A6%81%E4%BA%8B%E7%AC%AC%E4%B8%80">习惯三</a>），就能从事越多的重要但不紧急事务的更新活动（<a href="#%E4%B9%A0%E6%83%AF%E4%B8%83%EF%BC%9A%E4%B8%8D%E6%96%AD%E6%9B%B4%E6%96%B0">习惯七</a>）；越能先理解别人（<a href="#%E4%B9%A0%E6%83%AF%E4%BA%94%EF%BC%9A%E7%9F%A5%E5%BD%BC%E8%A7%A3%E5%B7%B1">习惯五</a>），就越能找到统合综效的双赢解决方案（<a href="#%E4%B9%A0%E6%83%AF%E5%9B%9B%EF%BC%9A%E5%8F%8C%E8%B5%A2%E6%80%9D%E7%BB%B4">习惯四</a>和<a href="#%E4%B9%A0%E6%83%AF%E5%85%AD%EF%BC%9A%E7%BB%9F%E5%90%88%E7%BB%BC%E6%95%88">习惯六</a>）；越是在培养独立性的习惯方面加以改进（<a href="#%E4%B8%AA%E4%BA%BA%E9%A2%86%E5%9F%9F%E7%9A%84%E6%88%90%E5%8A%9F">习惯一、二、三</a>），就越能在相互依赖的环境下提高效能（<a href="#%E5%85%AC%E4%BC%97%E9%A2%86%E5%9F%9F%E7%9A%84%E6%88%90%E5%8A%9F">习惯四、五、六</a>）；自我更新则是强化所有这些习惯的过程（<a href="#%E4%B9%A0%E6%83%AF%E4%B8%83%EF%BC%9A%E4%B8%8D%E6%96%AD%E6%9B%B4%E6%96%B0">习惯七</a>）。</p>
]]></content>
      <categories>
        <category>读书笔记 - 成长</category>
      </categories>
  </entry>
  <entry>
    <title>「关键对话」读书笔记</title>
    <url>/posts/1980352382.html</url>
    <content><![CDATA[<p>这绝对称得上是一本宝藏书籍！</p>
<p>书中通过翔实的研究和大量生动有趣的案例，详细介绍了掌握关键对话的方法，旨在帮助我们在对话中创建正确的心理和情绪状态，合理利用恰当的技巧模式。</p>
<p>人生中有很多大大小小的岔路口，我们的每一次选择都将改变之后的人生走向。从这个意义上来说，「关键对话」正是一部为我们提供关键指引、能够有效改变人生轨迹的伟大作品。</p>
<p>接下来我将简单梳理一下本书的主要脉络，对书中精华做一个整理归纳。</p>
<h2 id="何谓关键对话"><a class="markdownIt-Anchor" href="#何谓关键对话"></a> 何谓关键对话</h2>
<p>关键对话是指那些双方观点迥异、内容充满风险、情绪非常激烈的对话。这类对话之所以关键，是因为其结果会对我们的生活质量产生巨大的影响。</p>
<p>通常来说，对话内容越关键，我们能够正确处理问题的能力就越差。因为当我们情绪非常激动时，体内会释放大量肾上腺素，受此激素的影响，血液会从其他器官抽离，充斥到我们的四肢，以便做好战斗或逃跑的准备，而脑部负责思维的部分则因缺血导致无法正常思考。</p>
<p>那么，我们该如何处理关键对话呢？</p>
<h2 id="掌握关键对话"><a class="markdownIt-Anchor" href="#掌握关键对话"></a> 掌握关键对话</h2>
<p>掌握关键对话的思路大致可以分为以下四个步骤：</p>
<h3 id="摆脱傻瓜式选择"><a class="markdownIt-Anchor" href="#摆脱傻瓜式选择"></a> 摆脱傻瓜式选择</h3>
<p>傻瓜式选择有两种：一种是隐忍不发，一种是冲冠一怒。前者会任由情况向不利的方向发展，后者则容易说出让自己事后追悔莫及的话。要摆脱傻瓜式选择，可以利用 <strong>对比说明</strong> 的方法：</p>
<ul>
<li>阐明自己不想实现的目的</li>
<li>说明自己的真正目的</li>
<li>寻找可以同时实现上述两个目的的办法</li>
</ul>
<blockquote>
<p>约坦，我想和你谈谈关于亲热的事情（<strong>动机</strong>）。我不想让你尴尬，也不想指责这是你的问题（<strong>不是</strong>）。我很清楚，在这个问题上我也有责任。我的目的是想和你进行讨论，找到对双方都有利的解决办法（<strong>而是</strong>）。</p>
</blockquote>
<h3 id="营造安全的对话氛围"><a class="markdownIt-Anchor" href="#营造安全的对话氛围"></a> 营造安全的对话氛围</h3>
<p>人只有在安全的氛围中才能畅所欲言，要努力让双方都愿意向共享观点库中添加信息。</p>
<p>当对方出现沉默或暴力应对的情况时应当暂停对话，营造安全气氛：</p>
<ul>
<li>
<p>如果是你的做法破坏了对别人的尊重感，应当先道歉以安抚对方的情绪。</p>
</li>
<li>
<p>如果是对方误解了你的目的或意图，要利用对比说明消除误会。</p>
</li>
<li>
<p>如果是跟对方的目的不一致，要利用以下步骤营造共同目的：</p>
<ol>
<li>
<p>积极寻找共同目的</p>
<blockquote>
<p>我不希望看到任何让彼此失望的事（<strong>不是</strong>），我是想找到一种方式，能让我们都感到亲密、彼此重视和互相关爱（<strong>而是</strong>）。</p>
</blockquote>
</li>
<li>
<p>识别策略背后的目的（期望目标实际上是一种策略，策略带来的结果才是实际目的。当成功区分策略和目的之后，新的选择自然就会出现）</p>
<blockquote>
<p>你想待在家里是因为你想享受宁静的时光，而我想去看电影是因为我想躲开孩子们的纠缠。那只要找到既能躲开孩子又能让你享受安静时光的选择，我们就皆大欢喜了，是这样吗？</p>
</blockquote>
</li>
<li>
<p>开发共同目的</p>
<blockquote>
<p>看来我们得找到一个能让双方都感到关爱和受重视的相处方式才行，你是这么想的吗？</p>
</blockquote>
</li>
<li>
<p>和对方共同构思新策略</p>
<blockquote>
<p>好吧，你看这样行不行……</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h3 id="分析感受背后的想法"><a class="markdownIt-Anchor" href="#分析感受背后的想法"></a> 分析感受背后的想法</h3>
<p>实际上，行为并不会直接导致感受，在他人的行为和我们的感受之间还存在着一个中间环节——主观臆断。</p>
<p>我们会为观察到的事实赋予某种意义，猜测这种行为背后隐藏的动机，同时加入自己的判断，最后在这些想法的基础上，我们的身体才开始对情绪做出响应。</p>
<p>而正是在这个中间环节，我们很容易产生错误的思维模式：</p>
<ul>
<li>受害者思维。认为对方是邪恶的、错误的、愚蠢的，自己是善良的、正确的、聪明的。</li>
<li>大反派思维。把问题归于对方的邪恶，过度强调对方的错误或愚蠢之处。</li>
<li>无助者模式。认为自己做什么都是徒劳，索性放弃积极行动。</li>
</ul>
<p>我们要改变主观臆断，试着询问自己以下问题：</p>
<ul>
<li>我是否故意忽略自己在这个问题中的责任（受害者 -&gt; 参与者）</li>
<li>一个理智而正常的人为什么会这样做（大反派 -&gt; 正常人）</li>
<li>我的真实目的是什么？为此应该怎么做（无助者 -&gt; 行动者）</li>
</ul>
<h3 id="了解真实动机"><a class="markdownIt-Anchor" href="#了解真实动机"></a> 了解真实动机</h3>
<p>引导对方说出其真实动机：</p>
<ul>
<li>
<p>询问观点</p>
<blockquote>
<p>为什么这么说呢？我想听听你的看法。</p>
</blockquote>
</li>
<li>
<p>确认感受</p>
<blockquote>
<p>看得出来，你并不高兴。</p>
</blockquote>
</li>
<li>
<p>重新描述</p>
<blockquote>
<p>好吧，你看看我的理解是否正确。你感到紧张是因为我对你的衣着方式表达了看法，这让你感到我太专制太守旧，是这样吗？</p>
</blockquote>
</li>
<li>
<p>主动引导</p>
<blockquote>
<p>你们是不是觉得公司这么做就是为了多赚钱？觉得我们毫不关注你们的家庭生活？</p>
</blockquote>
</li>
</ul>
<h2 id="把关键对话转变成行动和结果"><a class="markdownIt-Anchor" href="#把关键对话转变成行动和结果"></a> 把关键对话转变成行动和结果</h2>
<p>对话不是决策，而是获取双方观点的过程，决策则是最后的临门一脚。对于决策，一共有四种方式：</p>
<ul>
<li>命令式。适用于权力边界分明时的决策。</li>
<li>顾问式。做决策前需要倾听他人的意见，在评估各种方案后做出最终选择。</li>
<li>投票式。在几种现成的方案中投票挑选一个，适用于强调效率的决策场合。</li>
<li>共识式。必须讨论到所有人都取得一致意见，适用场合有两种：一是高风险的复杂问题，二是每个决策者都必须支持最终选择的问题。</li>
</ul>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>其实要解决关键对话问题，只需把握好两大原则即可：一是明确自己的对话目的，二是在对话过程中始终注意维护安全感，这两大原则正是正确识别、展开和维持关键对话的基础。掌握好这两大原则，相信再遇到关键对话时我们能够更加从容。</p>
]]></content>
      <categories>
        <category>读书笔记 - 成长</category>
      </categories>
  </entry>
  <entry>
    <title>类图关系</title>
    <url>/posts/3530858630.html</url>
    <content><![CDATA[<h2 id="类图关系示例"><a class="markdownIt-Anchor" href="#类图关系示例"></a> 类图关系示例</h2>
<img src="https://img.gejiba.com/images/34d7e86718ac8044a492362d9aa211fe.webp" alt="类图关系" style="zoom:50%;" />]]></content>
      <categories>
        <category>其它</category>
      </categories>
  </entry>
  <entry>
    <title>库与运行库</title>
    <url>/posts/1155868944.html</url>
    <content><![CDATA[<h2 id="函数返回值传递"><a class="markdownIt-Anchor" href="#函数返回值传递"></a> 函数返回值传递</h2>
<p>之前在 CSAPP 中介绍过<a href="https://younghblog.gitee.io/posts/3467593604.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数传参时的栈帧结构</a>，并且假设返回值都是通过 rax 寄存器传递的。对于 32 位的系统，则是通过 eax 寄存器传递的，但 eax 本身只有 4 个字节，对于返回 5 ~ 8 字节的情况，几乎所有的调用惯例都是通过 eax 与 edx 联合返回的方式进行的。那对于超过 8 个字节的返回类型又该如何传递呢？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">big_obj</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">&#125; big_obj;</span><br><span class="line"></span><br><span class="line">big_obj <span class="title function_">return_test</span><span class="params">()</span> &#123;</span><br><span class="line">    big_obj obj;</span><br><span class="line">    obj.buf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    big_obj res = return_test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中 <code>return_test</code> 的返回类型是一个长度为 128 字节的结构，它的传递方式如下：</p>
<ul>
<li><code>main()</code> 函数在栈上额外开辟一块空间，将其中一部分作为传递返回值的临时对象 <code>temp</code>，并将该地址作为隐藏参数传递给 <code>return_test()</code> 函数。</li>
<li><code>return_test()</code> 函数将构造好的 <code>obj</code> 拷贝给 <code>temp</code> 对象，并将 <code>temp</code> 对象的地址用 eax 返回。</li>
<li><code>return_test()</code> 函数返回之后，<code>main()</code> 函数再将 eax 指向的 <code>temp</code> 对象拷贝给 <code>res</code>。</li>
</ul>
<p>由此可知，当返回类型太大时，C 语言会使用一个临时的栈上内存区域做中转，最终所返回的对象会被拷贝两次。C++ 返回对象时也是一样的过程，为了减小开销，C++ 提出了 <strong>返回值优化</strong>（RVO，Return Value Optimization），直接在 return 时构造对象（例如 <code>return cpp_obj()</code>），可以减少一次复制过程。</p>
<p>对于面向对象的程序设计，光有栈还远远不够。因为栈上的数据在函数返回时就会被释放掉，无法将数据传递至函数外部，因此还必须要有堆。</p>
<h2 id="堆与内存管理"><a class="markdownIt-Anchor" href="#堆与内存管理"></a> 堆与内存管理</h2>
<p><strong>堆</strong> 是一块巨大的内存空间，常常占据整个虚拟内存空间的绝大部分。在这块空间里，程序可以请求一块连续的内存自由使用，并且在程序主动释放该内存之前会一直有效。</p>
<p>如果每次申请或释放对空间都进行系统调用，交由内核去完成的话，性能开销将会很大。因此通常的做法是程序向操作系统申请一块适当大小的堆空间，然后由程序自己来管理这块空间。<span class="p red">管理堆空间的往往是程序的 <strong>运行库</strong>。</span></p>
<p>为了使程序能够正常运行，其背后有一套庞大的代码来支撑。这套代码至少包括入口函数及其所依赖的函数、各种标准库函数的实现等等。这样一个代码集合就称为 <strong>运行（时）库</strong>（Runtime Library），C 语言的运行库称为 <strong>C运行库</strong>（CRT）。</p>
<p>那么运行库是如何申请内存，又是如何管理内存的呢？</p>
<h3 id="linux-进程堆管理"><a class="markdownIt-Anchor" href="#linux-进程堆管理"></a> Linux 进程堆管理</h3>
<p>Linux 提供了两种堆空间分配的方式：一个是 <code>brk()</code> 系统调用，一个是 <code>mmap()</code> 系统调用。</p>
<p><code>brk()</code> 通过设置数据段的结束地址来扩大或缩小数据段，从而达到分配和释放堆空间的目的。</p>
<p><code>mmap()</code> 会向操作系统申请一段虚拟地址空间，这段虚拟地址空间不会被映射到任何文件（称为 <strong>匿名空间</strong>），用来作为堆空间。申请时以页为单位，因此对于字节数很小的请求也用 <code>mmap()</code> 的话无疑会浪费大量空间。</p>
<h3 id="堆分配算法"><a class="markdownIt-Anchor" href="#堆分配算法"></a> 堆分配算法</h3>
<p>堆的分配算法有很多，这里只介绍几种简单的方法。</p>
<h4 id="空闲链表"><a class="markdownIt-Anchor" href="#空闲链表"></a> 空闲链表</h4>
<p>空闲链表是将堆中的各个空闲块以双向链表的形式链接起来。每个空闲块都有一个头，记录了前一个与后一个空闲块的地址。当分配内存时首先查找能足够容纳请求大小的空闲块，并将其分为两部分，一部分服务请求，另一部分作为新的空闲块。</p>
<p>当释放内存时，为了确定应该释放的块大小，会在请求内存时额外分配 4 个字节的内存来记录块的大小。</p>
<p>这种方式存在的问题是，一旦链表或记录块大小的那 4 个字节因为越界读写被破坏，整个堆将无法工作。</p>
<h4 id="位图"><a class="markdownIt-Anchor" href="#位图"></a> 位图</h4>
<p>将整个堆划分成等大小的块，用户请求内存时分配整数个块给用户。在已分配的块中，第一个块称为头，其余块称为主体，每个块只有 头/主体/空闲 三种状态，因此只需两个位即可表示一个块，这也是 <strong>位图</strong>（Bitmap）这一名字的由来。可以使用一个整数数组来记录块的使用情况。</p>
<p class='div-border blue left'>假设堆的大小为 1 MB，块大小为 128 B，那么一共就有 1MB / 128 B = 8192 个块。如果用 int 来保存，一个 int 是 4 个字节，即 32 位，那就可以表示 32 / 2 = 16 个块，因此一共需要 8192 / 16 = 512 个 int。</p>
<p>这种方式的优点为：</p>
<ul>
<li>速度快。整个堆的空闲信息存储在数组中，访问速度会比较快。</li>
<li>稳定性好。为了避免越界读写破坏数据，可以备份位图。而且即便部分数据被破坏，也不会导致整个堆都无法工作。</li>
</ul>
<p>这种方式自然也存在一些缺点：</p>
<ul>
<li>容易产生碎片。每次都要分配整数个块。</li>
<li>如果堆很大，或者块很小（为了减少碎片），位图将会很大。可以使用多级位图来解决。</li>
</ul>
<h4 id="对象池"><a class="markdownIt-Anchor" href="#对象池"></a> 对象池</h4>
<p>在一些场合中，被分配对象的大小往往都是较为固定的几个值。因此对象池将每次请求分配的大小作为一个单位，把堆空间划分成大量小块，每次请求时只需找到一个小块就可以了。</p>
<p>对象池的管理方法可以采用空闲链表，也可以采用位图。</p>
<p>glibc  的 <code>malloc()</code> 函数的堆分配方式为：</p>
<ul>
<li>
<p>小于 64 B 的请求，采用类似对象池的方法；</p>
</li>
<li>
<p>64 B ~ 512 B 的请求，视情况采取上述方法中的折中策略；</p>
</li>
<li>
<p>512 B ~ 128 KB 的请求，采用最佳适配算法；</p>
</li>
<li>
<p>大于 128 KB 的请求，使用 <code>mmap()</code> 机制直接向操作系统申请空间。</p>
</li>
</ul>
<h2 id="系统调用与中断"><a class="markdownIt-Anchor" href="#系统调用与中断"></a> 系统调用与中断</h2>
<p>由于系统有限的资源有可能被多个不同的应用程序同时访问，如果不加以保护，那么各个应用程序难免会产生冲突。所以现代操作系统将可能产生冲突的系统资源（文件、网络、IO、各种设备等）都保护起来，避免应用的直接访问。为了让程序访问系统资源，每个操作系统都提供了一套接口，即 <strong>系统调用</strong>。</p>
<p>系统调用虽然可以实现相应功能，但由于接口往往过于原始，使用起来并不方便，所以系统调用并不是与程序交互的最终接口。最终接口是运行库，它是对系统调用的封装。</p>
<p>系统调用是运行在内核态的，而应用程序基本都运行在用户态，用户态的程序要运行内核态的代码，一般是通过 <strong>中断</strong> 来切换 CPU 模式的。</p>
<p>中断一般有两个属性：<strong>中断号</strong>（从 0 开始）和 <strong>中断处理程序</strong>。不同的中断具有不同的中断号，中断处理程序与中断号一一对应。那通过中断号是如何找到相应的中断处理程序的呢？答案是 <strong>中断向量表</strong>。</p>
<p>中断向量表是一个数组，保存在内核中，其中第 n 项即指向中断号为 n 的中断处理程序。发生中断时，CPU 会暂停当前执行的程序，根据中断号在中断向量表中找到相应的中断处理程序，并调用它。执行完成后，CPU 再继续执行之前的代码。</p>
<p>中断有两种类型：一种称为 <strong>硬件中断</strong>，这种中断来自硬件异常或者电源掉电、键盘被按下等其他事件的发生。另一种称为 <strong>软件中断</strong>，这种中断通常是一条指令，可以由用户手动触发。例如 Linux 中 <code>int 0x80</code> 这条指令会调用中断号为 <code>0x80</code> 的中断处理程序。<span class="p red">系统调用是一种软中断处理程序。</span></p>
<p>由于中断号是有限的，操作系统不会舍得用一个中断号来对应一个系统调用，例如 Linux 的中断号 <code>0x80</code> 对应了所有的系统调用。那这时操作系统又是如何知道该调用哪个系统调用呢？</p>
<p>与中断一样，每个系统调用也都有自己的 <strong>系统调用号</strong>，它通常就是系统调用在 <strong>系统调用表</strong> 中的位置。这个系统调用号在执行 int 指令之前会被放在某个固定的寄存器（eax）里，中断代码会获取到这个系统调用号，并调用正确的函数。</p>
<p>在实际执行中断向量表中第 <code>0x80</code> 号元素所对应的函数之前，CPU 还需进行栈的切换。在 Linux 中，用户态和内核态使用的是不同的栈，两者各自负责自己的函数调用，互不干扰。当应用程序调用 <code>0x80</code> 号中断时，程序的执行流会从用户态切换到内核态，这时程序的 <strong>当前栈</strong>（即 esp 所指向的栈空间）也必须相应地从 <strong>用户栈</strong> 切换到 <strong>内核栈</strong>。当中断处理函数返回时，程序的当前栈再切换回去。</p>
]]></content>
      <categories>
        <category>读书笔记 - 程序员的自我修养</category>
      </categories>
      <tags>
        <tag>堆管理</tag>
        <tag>系统调用</tag>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title>装载与动态链接</title>
    <url>/posts/3697966026.html</url>
    <content><![CDATA[<p>在 <a href="https://younghblog.gitee.io/posts/1093737480.html">上一篇</a> 文章中，通过静态链接我们已经得到了可执行文件。为了使其运行起来，还需要将其读取到物理内存中才能被 CPU 执行。这篇文章就重点介绍一下可执行文件是如何被装载到物理内存的，以及动态链接的过程。</p>
<h2 id="装载"><a class="markdownIt-Anchor" href="#装载"></a> 装载</h2>
<p>当 ELF 可执行文件要被执行时，系统会先建立一个进程，具体过程如下：</p>
<ol>
<li>创建一个独立的虚拟地址空间。实际上只是创建虚拟地址空间与物理地址空间映射时所需的数据结构，而具体的映射关系则会推迟到发生页错误时才进行设置。</li>
<li>读取可执行文件头，建立虚拟空间与可执行文件的映射关系。这一步的目的是为了知道在发生缺页时该加载 <strong>可执行文件</strong>（又叫 <strong>映像文件</strong>）的哪个页到物理内存。</li>
<li>将指令寄存器设置成可执行文件的入口地址。该地址也记录在可执行文件头中。</li>
</ol>
<p>以上步骤执行完后实际上只是建立起了可执行文件与进程虚拟内存空间的映射关系，程序的指令和数据都还没被装入到内存。当 CPU 开始执行该程序时就会发生缺页异常，这时才会处理缺页。具体过程如下：</p>
<ol>
<li>根据上述建立的映射关系，计算出所缺页在可执行文件中的偏移。</li>
<li>在物理内存中分配一个物理页，并将所缺页从磁盘读入该物理页。</li>
<li>建立虚拟页与物理页的映射关系，然后重新执行导致缺页的指令。</li>
</ol>
<p>随着进程的执行，缺页会不断产生，操作系统也会不断地为其分配物理页来满足进程的需求，这样一个可执行文件就运行起来了。</p>
<h3 id="segment"><a class="markdownIt-Anchor" href="#segment"></a> Segment</h3>
<p>ELF 文件映射是以页为单位的，因此每个段都至少需要一个物理页，超出部分也将会单独占用一个页。一个 ELF 文件中有很多段，这必然会对内存空间造成很大的浪费。</p>
<p>那要怎样尽量减少这种浪费呢？</p>
<p>实际上操作系统并不关心 ELF 文件中各个段的具体内容，主要关心的是各个段所拥有的权限。这样一来，所有段基本上就被分成了三大类：</p>
<ul>
<li>以代码段为代表的 <strong>可读可执行</strong> 的段；</li>
<li>以数据段和 BSS 段为代表的 <strong>可读可写</strong> 的段；</li>
<li>以只读数据段为代表的 <strong>只读</strong> 段。</li>
</ul>
<p>因此可以把相同权限的段合并成一个段进行映射，从而减少页内碎片，达到节省内存空间的目的。</p>
<p>比如 <code>.text</code> 和 <code>.init</code> 分别是程序的可执行代码和初始化代码，它们具有相同的权限，那么装载时就可以将其作为一个 <strong>Segment</strong> 一起映射，即映射后虚拟内存空间中只有一个相应的 <strong>VMA</strong>（Virtual Memory Area）而不是两个。其中的 <code>.text</code> 和 <code>.init</code> 则称为 <strong>Section</strong>。</p>
<img src="https://img.gejiba.com/images/790b9378fe6204600abb5b28570b321e.webp" alt="1" style="zoom:50%;" />
<p>系统正是按 Segment 而不是 Section 来映射可执行文件的。正如描述 Section 属性的结构叫段表，描述 Segment 属性的结构叫 <strong>程序头</strong>（Program Header），它描述了 ELF 文件该如何被映射到进程的虚拟空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">    &gt; File Name: SectionMapping.c</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用静态链接的方式将其编译成可执行文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -static SectionMapping.c -o SectionMapping.elf -m32</span><br></pre></td></tr></table></figure>
<p>查看其程序头：</p>
<img src="https://img.gejiba.com/images/70d3f96c0712597db299adb2a7c57893.webp" alt="ph" style="zoom:55%;" />
<p>这里我们只关心 LOAD 类型，因为只有该类型的 Segment 是需要被映射的，其他类型只是用来辅助装载的。根据 Flg 类型，可执行文件会被映射到 4 个 VMA。</p>
<p>由于段地址以页为单位进行对齐，因此将 Section 合并成 Segment 进行装载时，虽然在一定程度上缓解了内存空间的浪费问题，但不得不承认，该问题仍然存在。例如：</p>
<img src="https://img.gejiba.com/images/6a495c4a3cb0908c6eed1c1f2e086df3.webp" alt="2" style="zoom:50%;" />
<p>因此有些 UNIX 系统采用了一个很取巧的办法——段合并。</p>
<h3 id="段合并"><a class="markdownIt-Anchor" href="#段合并"></a> 段合并</h3>
<p>所谓段合并，就是让那些各个段接壤部分共享一个物理页面，然后将该物理页面分别映射两次。如图：</p>
<img src="https://img.gejiba.com/images/42eb86f4e71e10dccbd55575f7345a6d.webp" alt="3" style="zoom:50%;" />
<p>可执行文件可以被加载到物理内存中的任意位置，因此页之间可以不连续。</p>
<p>段合并针对的是物理内存，虚拟空间中仍然按照 Segment 进行映射，即每个 Segment 都至少需要一个页，超出部分也将会单独占用一个页。</p>
<p>其实 UNIX 会将 ELF 文件头也看做一个段进行映射，因此从某种角度来看，段合并的过程为：</p>
<p>整个 ELF 文件从文件最开始到某个点结束（所有 LOAD 类型的段），逻辑上被分成以 4096 字节为单位的若干个块，每个块都会被装载到物理内存。对于那些包含两个段的块，将会被映射两次。</p>
<h3 id="堆和栈"><a class="markdownIt-Anchor" href="#堆和栈"></a> 堆和栈</h3>
<p>进程在执行时，还需要用到堆和栈，它们在进程的虚拟空间中也是以 VMA 的形式存在的。我们可以看一下 <code>SectionMapping.elf</code> 运行起来后的虚拟空间分布：</p>
<img src="https://img.gejiba.com/images/16084b25fb033a53a6aaf71ec88672b2.webp" alt="map" style="zoom:60%;" />
<p>其中，第一列是 VMA 的地址范围；第二列是 VMA 的权限，<code>p</code> 表示私有，<code>s</code> 表示共享；第三列表示 VMA 对应的 Segment 在映像文件中的偏移；第四列表示映像文件所在设备的主设备号和次设备号；第五列表示映像文件的节点号；最后一列是映像文件的路径。</p>
<p>可以看到，前五个 Segment 是映射到可执行文件的，而剩余几个段的主设备号、次设备号、文件节点号都是 0，表示它们没有映射到文件中，这种 VMA 叫做 <strong>匿名虚拟内存区域</strong>（Anonymous Virtual Memory Area）。这里堆和栈均只有读写权限，这与书中的描述有些出入，这应该是优化之后的结果。</p>
<h3 id="进程栈初始化"><a class="markdownIt-Anchor" href="#进程栈初始化"></a> 进程栈初始化</h3>
<p>进程刚开始启动时需要知道一些运行环境，最基本的就是系统环境变量和程序的运行参数，这些信息通常会被提前保存到 Stack VMA。</p>
<p>假设系统中有两个环境变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HOME=/home/user</span><br><span class="line">PATH=/usr/bin</span><br></pre></td></tr></table></figure>
<p>运行该程序的命令为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">prog 123</span><br></pre></td></tr></table></figure>
<p>进程初始化后的堆栈如图所示：</p>
<img src="https://img.gejiba.com/images/d212c3a8b5ae2016e6abf790e7057a3e.webp" alt="ProcessStack" style="zoom:55%;" />
<p>其中，esp 指向栈顶，前 4 个字节表示命令行参数的数量，这里是 <code>prog</code> 与 <code>123</code> 共 2 个参数，紧接着就是指向这两个字符串的指针。之后是一个 0，表示命令行读取结束。再后面是指向环境变量字符串的指针，最后还是以 0 表示结束。</p>
<p>进程启动后，初始化堆栈中的参数信息部分会被传递给 main 函数，即 <code>argc</code> 和 <code>argv</code> 两个参数。</p>
<h2 id="动态链接"><a class="markdownIt-Anchor" href="#动态链接"></a> 动态链接</h2>
<p>静态链接的缺陷：</p>
<ul>
<li>空间浪费。对于多个程序的公共部分，会在内存和磁盘空间中存在多个副本，造成严重的空间浪费。</li>
<li>更新困难。程序的更新、部署和发布不方便，每次都要以整个程序为单位。</li>
</ul>
<p>解决办法就是不对组成程序的目标文件进行链接，而是推迟到运行时才链接，这就是动态链接的基本思想。</p>
<p>动态链接时，多个程序的所有公共部分只会存在一份，以共享的方式存在。因此动态链接不仅节省了内存，还使程序的更新变得更加容易，只需覆盖某个旧的目标文件，在程序下次运行时自然会将新的目标文件链接进来，从而完成升级目标。</p>
<p>此外，动态链接还有其他一些优点，例如程序的 <strong>可扩展性</strong> 和 <strong>兼容性</strong>。</p>
<p>动态链接的程序在运行时可以动态选择加载各种程序模块，因此我们可以按照程序提供的接口编写符合要求的动态链接文件，即 <strong>插件</strong>（Plug-in），实现程序功能的扩展。</p>
<p>动态链接可以加强程序的兼容性是指，程序在不同平台运行时可以动态链接到操作系统提供的动态链接库，库函数的实现方式因平台而异，但只要提供的接口相同，便可在不同平台统一调用。</p>
<p>在 Linux 中，ELF 动态链接文件被称为 <strong>共享对象</strong>（Shared Object），一般以 <code>.so</code> 作为扩展名。</p>
<h3 id="简单的动态链接例子"><a class="markdownIt-Anchor" href="#简单的动态链接例子"></a> 简单的动态链接例子</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Program1.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    foobar(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Program2.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    foobar(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Lib.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foobar</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Printing from Lib.so %d\n&quot;</span>, i);</span><br><span class="line">    sleep(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Lib.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LIB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIB_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foobar</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>Program1.c 与 Program2.c 分别调用了 Lib.c 中的 foobar() 函数，该函数会将传入的参数打印出来。</p>
<p>首先将 Lib.c 编译成一个共享对象文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -fPIC -shared Lib.c -o Lib.so -m32</span><br></pre></td></tr></table></figure>
<p>其中 <code>-shared</code> 表示生成共享对象，<code>-fPIC</code> 表示生成位置无关代码。</p>
<p>得到 <a href="http://Lib.so">Lib.so</a> 共享对象文件后，再分别编译两个程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc Program1.c -o Program1 ./Lib.so -m32</span><br><span class="line">gcc Program2.c -o Program2 ./Lib.so -m32</span><br></pre></td></tr></table></figure>
<p>与静态链接不同，最终生成的可执行文件 Program1 中并没有将 Lib.o 链接进来，而是链接了 <a href="http://Lib.so">Lib.so</a>。该文件中保存了完整的符号信息，链接器在解析符号时就可以知道，foobar 是定义在 <a href="http://Lib.so">Lib.so</a> 中的动态符号。因此链接器在解析 Program1.o 遇到 foobar 时，就会将其标记为动态链接符号而不是进行地址重定位，这个过程会被留到装载时再进行。</p>
<p>根据 <a href="#%E5%A0%86%E5%92%8C%E6%A0%88">前面</a> 的介绍我们已经知道，当静态链接的可执行文件在执行时，整个进程中只有该文件本身会被映射到虚拟内存空间。那我们现在看一下，动态链接的可执行文件执行时的虚拟内存空间分布情况：</p>
<img src="https://img.gejiba.com/images/54401841ead2cef834c5d57b8006e788.webp" alt="ld-maps" style="zoom:55%;" />
<p>可以看到，除了可执行文件本身外，还有一些其他文件。其中，<a href="http://Lib.so">Lib.so</a> 与 Program1 一样都是被系统以同样的方法映射至进程的虚拟地址空间；另外，Program1 还用到了动态链接形式的 C 运行库 <a href="http://libc-2.31.so">libc-2.31.so</a>；而剩下的 <a href="http://ld-2.31.so">ld-2.31.so</a> 实际上是 Linux 的动态链接器。</p>
<p>动态链接器跟普通共享对象一样被映射到了进程的虚拟地址空间，在系统装载完可执行文件 Program1 之后，会先将控制权交给动态链接器，由它负责将可执行文件中外部符号的引用与相应的共享对象中的实际位置链接起来，然后再把控制权交给可执行文件 Program1 的入口地址，此时程序才会开始执行。</p>
<p>再来看一下 <a href="http://Lib.so">Lib.so</a> 的装载属性：</p>
<img src="https://img.gejiba.com/images/7badc295bef39dcf14d3bb2e01479f9f.webp" alt="Libso" style="zoom:55%;" />
<p>可以看到动态链接模块的装载地址是从 0x00000000 开始的，说明共享对象的装载地址在编译时是不确定的，而是在装载时由装载器根据当前地址空间的空闲情况，动态分配足够大小的虚拟地址空间给它。</p>
<h3 id="地址无关代码"><a class="markdownIt-Anchor" href="#地址无关代码"></a> 地址无关代码</h3>
<p>那么共享对象装载时，它在虚拟地址空间中的位置该如何确定呢？</p>
<p>如果使用固定地址来装载共享对象，对这些模块地址的管理将是一件无比繁琐的事，而且有很大的局限性。</p>
<p>如果使用静态链接的链接时重定位的方法，实现 <strong>装载时重定位</strong>，虽然可以将共享对象装载到任意位置，但该对象就不能被共享了。什么意思？</p>
<p>当共享对象被装载映射至虚拟空间后，其指令部分在多个进程之间是共享的。如果该模块中存在绝对地址引用，那么装载时重定位就会修改需要重定位的指令，而修改后的指令对每个进程来说都是不同的，所以没办法被多个进程共享。</p>
<p><strong>地址无关代码</strong>（PIC，Position-independent Code）是这么解决的：把指令中需要被修改的部分分离出来放到数据段（数据段权限为可读可写），这样指令部分就可以保持不变（代码段权限为可读可执行但不可修改），而数据部分则可以在每个进程中都拥有一个副本。</p>
<p>地址无关的意思是，共享对象在整个物理内存中只有一份，不同的进程引用时会映射到不同的虚拟地址，但最终映射到同一个物理位置。这里的重点是，共享对象内部符号的相对位置都是固定的，不论被加载到哪个虚拟地址，都不会影响最终计算出的真实的物理地址。</p>
<p>为了产生地址无关代码，我们先来分析一下共享对象模块中地址的引用方式：</p>
<ol>
<li>类型一：模块内部的函数调用、跳转等。</li>
<li>类型二：模块内部的数据访问，比如模块中定义的全局变量、静态变量。</li>
<li>类型三：模块外部的函数调用、跳转等。</li>
<li>类型四：模块外部的数据访问，比如其他模块中定义的全局变量。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> b;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">ext</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">    a = <span class="number">1</span>; <span class="comment">// Type 2: Inner-module data access</span></span><br><span class="line">    b = <span class="number">2</span>; <span class="comment">// Type 4: Inter-module data access</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    bar(); <span class="comment">// Type 1: Inner-module call</span></span><br><span class="line">    ext(); <span class="comment">// Type 3: Inter-module call</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于以上四种地址引用方式，地址无关代码的解决策略如下：</p>
<h4 id="1-模块内函数调用"><a class="markdownIt-Anchor" href="#1-模块内函数调用"></a> ① 模块内函数调用</h4>
<p>这种类型是最简单的。模块内部的函数调用或跳转都是相对地址调用，指令中的地址部分是相对于下一条指令的偏移量，二者相加之后才是所调用函数的地址，因此调用者和被调用者的相对位置是不变的，所以指令本身就是地址无关的，即不论该模块被装载到哪个位置，这条指令都是有效的。</p>
<p>不过这种情况有可能会出现 <strong>全局符号介入</strong> 的问题：程序所引用的某个函数在两个共享对象中都定义了，并且该程序又同时引用了这两个共享对象，那么一个共享对象里面的全局符号就会被另一个共享对象的同名全局符号覆盖，这种现象称为共享对象全局符号介入。</p>
<p>一般动态链接器都会按照装载顺序进行处理。当一个符号已经加载进全局符号表时，后面的相同符号将会被忽略。</p>
<h4 id="2-模块内数据访问"><a class="markdownIt-Anchor" href="#2-模块内数据访问"></a> ② 模块内数据访问</h4>
<p>对于模块内数据的访问，指令中不能直接包含数据的绝对地址，否则装载时需要重定位，而代码段是不允许修改的，因此唯一的办法就是相对寻址。</p>
<p>任何一条指令与模块内部的数据之间的相对位置是固定的，因此可以修改为当前指令的地址加上固定的偏移量来访问模块内数据。</p>
<h4 id="3-模块间数据访问"><a class="markdownIt-Anchor" href="#3-模块间数据访问"></a> ③ 模块间数据访问</h4>
<p>模块间数据访问的地址要等装载时才能确定，地址无关代码会将与地址相关的部分放到数据段里面，ELF 的做法是在数据段里面建立一个指向这些变量的指针数组，叫做 <strong>全局偏移表</strong>（GOT，Global Offset Table）。当代码需要引用另一个模块的全局变量时，根据 GOT 中变量所对应的的项可以找到变量的目标地址。</p>
<p>由于 GOT 放在数据段，所以在模块装载时可以被修改。并且每个进程都有一个独立的副本，互相之间不受影响，从而实现了地址无关。</p>
<h4 id="4-模块间函数调用"><a class="markdownIt-Anchor" href="#4-模块间函数调用"></a> ④ 模块间函数调用</h4>
<p>同类型三一样，可以通过 GOT 实现地址无关。</p>
<img src="https://img.gejiba.com/images/1c1c57d5de9d52b576496329b865ba1b.webp" alt="processVirtualSpace" style="zoom:50%;" />
<p>地址无关代码技术除了可以用于共享对象，还可以用于可执行文件，需要使用 <code>-fPIE</code> 编译，生成的文件叫做 <strong>地址无关可执行文件</strong>（PIE，Position Independent Executable）。</p>
<p>除了以上四种类型，其实还存在一些其他情况。比如共享模块内定义了可以被其他模块引用的全局变量，以及数据段中的绝对地址引用问题，这里就不展开了，感兴趣可以阅读原书。</p>
<h3 id="延迟绑定"><a class="markdownIt-Anchor" href="#延迟绑定"></a> 延迟绑定</h3>
<p>动态链接虽然有很多<a href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5">优势</a>，比静态链接要灵活很多，但它是以牺牲一部分性能为代价的。它比静态链接慢的主要原因有二：</p>
<ul>
<li>动态链接下对于全局和静态数据的访问以及模块间的调用，都要先定位 GOT，然后再间接寻址或跳转，如此一来程序的运行速度必然会减慢；</li>
<li>动态链接是在运行时完成的，即每次程序执行时都要进行一次链接工作。动态链接器会寻找并装载所需的共享对象并进行符号查找和地址重定位等工作，这些工作势必会减慢程序的启动速度。</li>
</ul>
<p>实际上，在程序执行过程中，很多函数可能自始至终都不会用到，比如一些错误处理函数或者用户很少会用到的功能模块等，如果一开始就把所有函数都链接好其实是一种浪费。</p>
<p>所以 ELF 采用了 <strong>延迟绑定</strong> 的做法，即当函数第一次被用到时才进行绑定，如果没用到则不进行绑定，这样可以大大加快程序的启动速度。</p>
<p>为了实现延迟绑定，ELF 使用了 <strong>PLT</strong>（Procedure Linkage Table）。同时 ELF 还将 GOT 拆分成了两个表 <code>.got</code> 和 <code>.got.plt</code>，前者用来保存全局变量引用的地址，后者保存函数引用的地址。PLT 在 ELF 中以独立的段存放，段名通常叫做 <code>.plt</code>。由于其本身是地址无关的代码，因此可以跟代码段一起合并成一个 Segment。</p>
<h3 id="动态链接相关结构"><a class="markdownIt-Anchor" href="#动态链接相关结构"></a> 动态链接相关结构</h3>
<h4 id="interp-段"><a class="markdownIt-Anchor" href="#interp-段"></a> .interp 段</h4>
<p>系统中动态链接器的位置是由 ELF 可执行文件决定的，其中 <code>.interp</code> 段（interpreter - 解释器）保存了可执行文件所需要的动态链接器的路径。</p>
<img src="https://img.gejiba.com/images/c8b384a90a8e841ef532505ce6f22426.webp" alt="interp" style="zoom:55%;" />
<p>该路径通常是一个 <strong>软链接</strong>，可以打印出来看一下：</p>
<img src="https://img.gejiba.com/images/ea31b8b17dfeb1fd636979654ec56dbe.webp" alt="ld-path" style="zoom:55%;" />
<p>可以看到，它最终指向的是 <code>/lib32/ld-2.31.so</code>，这个才是真正的动态链接器。</p>
<h4 id="dynamic-段"><a class="markdownIt-Anchor" href="#dynamic-段"></a> .dynamic 段</h4>
<p><code>.dynamic</code> 段保存了动态链接器所需要的基本信息，可以看做是动态链接下 ELF 的文件头。</p>
<img src="https://img.gejiba.com/images/455f5a1ebbe3f6d46c1cc2a73d307dfd.webp" alt="dynamic" style="zoom:55%;" />
<p>还可以通过如下命令查看一个模块或共享库依赖于哪些共享库：</p>
<img src="https://img.gejiba.com/images/2157b8fae17f194c158e93e8c04d606b.webp" alt="ldd" style="zoom:60%;" />
<h4 id="动态符号表"><a class="markdownIt-Anchor" href="#动态符号表"></a> 动态符号表</h4>
<p>对于 Program1 来说，它引用了 <a href="http://Lib.so">Lib.so</a> 里面的 foobar() 函数，我们就称 Program1 <strong>导入</strong>（Import）了 foobar() 函数，foobar() 也叫 Program1 的 <strong>导入函数</strong>。</p>
<p>对于 <a href="http://Lib.so">Lib.so</a> 来说，它定义了 foobar() 函数并提供给其他模块使用，我们称 <a href="http://Lib.so">Lib.so</a> <strong>导出</strong>（Export）了 foobar() 函数，foobar() 也叫 <a href="http://Lib.so">Lib.so</a> 的 <strong>导出函数</strong>。</p>
<p>为了表示动态链接这些模块间符号的导入导出关系，ELF 使用 <strong>动态符号表</strong>（Dynamic Symbol Table）来保存这些信息，段名叫 <code>.dynsym</code>。与静态链接的符号表 <code>.symtab</code> 不同的是，<code>.dynsym</code> 只保存了与动态链接相关的符号，而 <code>.symtab</code> 则保存了包括 <code>.dynsym</code> 中的符号在内的所有符号。</p>
<p>同时，与 <code>syntab</code> 类似，动态符号表也需要一些辅助表，比如保存符号名的字符串表。该表在静态链接中叫 <code>.strtab</code>，而在动态链接中叫 <code>.dynstr</code>。另外，由于动态链接需要在程序运行时查找符号，为了加快符号的查找过程，往往还有辅助的 <strong>符号哈希表</strong>（<code>.hash</code>）。</p>
<img src="https://img.gejiba.com/images/b3aeb8b51fc75184d4c9fc07b64e4d60.webp" alt="dynsym" style="zoom:55%;" />
<h4 id="动态链接重定位表"><a class="markdownIt-Anchor" href="#动态链接重定位表"></a> 动态链接重定位表</h4>
<p>动态链接中导入符号的地址在运行时才能确定，所以需要在运行时对其进行重定位。</p>
<p>虽然可执行文件和共享对象使用了 PIC（位置无关代码）技术，但这只能说明代码段不需要重定位，而数据段还包含了代码段中分离出来的 GOT，以及可能包含的其他绝对地址的引用，因此仍然需要重定位。</p>
<p>动态链接中的重定位表有 <code>.rel.dyn</code> 和 <code>.rel.plt</code>。前者是对数据引用的修正，它所修正的位置位于 <code>.got</code> 以及数据段；后者是对函数引用的修正，它所修正的位置位于 <code>.got.plt</code>。</p>
<img src="https://img.gejiba.com/images/93552e4866b5ecc52cedf57152b937d2.webp" alt="rel" style="zoom:55%;" />
<h3 id="动态链接的步骤和实现"><a class="markdownIt-Anchor" href="#动态链接的步骤和实现"></a> 动态链接的步骤和实现</h3>
<p>动态链接的步骤基本可以分为 3 步：</p>
<ul>
<li>启动动态链接器</li>
<li>装载所有需要的共享对象</li>
<li>重定位和初始化</li>
</ul>
<h4 id="动态链接器自举"><a class="markdownIt-Anchor" href="#动态链接器自举"></a> 动态链接器自举</h4>
<p>对于普通的共享对象来说，它可以依赖其他共享对象，由动态链接器负责链接和装载，以及重定位工作。</p>
<p>而动态链接器本身也是一个共享对象，因此它自然不能依赖其他共享对象，并且对于全局和静态变量的重定位工作也必须由它自身完成。</p>
<p>对于第一个条件，可以人为地在编写时进行控制；而对于第二个条件，动态链接器则必须在启动时有一段非常精巧的代码来实现，同时又不能用到全局和静态变量。这种具有一定限制条件的启动代码往往被称为 <strong>自举</strong>（bootstrap）。</p>
<h4 id="装载共享对象"><a class="markdownIt-Anchor" href="#装载共享对象"></a> 装载共享对象</h4>
<p>完成自举后，动态链接器就启动起来了。此时动态链接器会将可执行文件的符号表和链接器本身的符号表合并到一个 <strong>全局符号表</strong> 中，这是为之后的符号重定位工作做准备。</p>
<p>然后链接器寻找可执行文件中所依赖的共享对象，即 <code>.dynamic</code> 段中 NEEDED 类型的对象。这些共享对象的名字会被放到一个装载集合中。</p>
<p>链接器依次从集合中取出共享对象的名字，找到相应文件并读取相应的 ELF 文件头和 <code>.dynamic</code> 段，然后将其代码段和数据段映射到进程空间。如果该对象还依赖其他对象，那么还需将依赖对象的名字也放入集合中，如此循环直到把所有依赖的共享对象都装载进来为止。关于加载顺序是广度优先、深度优先还是其他顺序，取决于链接器，一般是广度优先的。</p>
<p>当一个共享对象被加载进来的时候，它的符号表也会被合并到全局符号表中。</p>
<h4 id="重定位和初始化"><a class="markdownIt-Anchor" href="#重定位和初始化"></a> 重定位和初始化</h4>
<p>共享对象装载完成后，动态链接器已经拥有了进程的全局符号表，包含了动态链接所需要的所有符号。此时链接器会重新遍历可执行文件和每个共享对象的重定位表进行重定位。</p>
<p>重定位完成后，如果某个共享对象有 <code>.init</code> 段，那么动态链接器会执行该段中的代码完成共享对象的初始化过程。相应地，共享对象还可能有 <code>.fini</code> 段，在进程退出时执行。</p>
<p>注意，动态链接执行的是共享对象中的 <code>.init</code> 段，而不是可执行文件中的。后者中的相应段由程序初始化部分代码来执行。</p>
<p>至此，所有的准备工作就完成了，动态链接器会将控制权移交给程序入口开始执行。</p>
]]></content>
      <categories>
        <category>读书笔记 - 程序员的自我修养</category>
      </categories>
      <tags>
        <tag>装载</tag>
        <tag>动态链接</tag>
        <tag>PIC</tag>
      </tags>
  </entry>
  <entry>
    <title>静态链接</title>
    <url>/posts/1093737480.html</url>
    <content><![CDATA[<p class='div-border yellow left right'><b><font color="green">粽</font> 有 千 古 ， 横 有 八 荒</b></br><b>前 途 似 海 ， 来 日 方 长</b></br>—— 今日端午，祝各位端午安康❤️</p>
<p>本文对应原书的第 2 部分，主要介绍了目标文件的格式和静态链接的详细过程。这里我以原书中的示例代码作为切入点进行介绍。</p>
<p>首先厘清几个概念，方便对文章的理解。</p>
<h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2>
<ol>
<li>
<p>编译生成的 <code>.o</code> 文件叫做可重定位目标文件，或者 <strong>目标文件</strong>，也叫 <strong>模块</strong>。</p>
</li>
<li>
<p><strong>链接器</strong> 所做的工作，无非就是把指令中对其他符号地址的引用加以修正。地址修正的过程就是 <strong>重定位</strong>，每个需要被修正的地方都是一个 <strong>重定位入口</strong>（Relocation Entry）。</p>
</li>
<li>
<p><strong>符号决议</strong>，其实就是地址绑定。只不过 <strong>决议</strong> 更倾向于静态链接，<strong>绑定</strong> 则倾向于动态链接。</p>
</li>
<li>
<p>目标文件（relocatable）就是按照可执行文件的格式存储的，只是因为还没有链接，可能有些符号或地址尚未被调整。Linux 的可执行文件格式是 <strong>ELF</strong>（Executable Linkable Format），ELF 的文件类型包括可重定位（relocatable）文件、可执行（executable）文件、共享目标（shared object）文件以及核心转储文件（core file），可通过 <code>file</code> 命令查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ file hello.o</span><br><span class="line">hello.o: hello.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped</span><br><span class="line"></span><br><span class="line">$ file hello</span><br><span class="line">hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=390f7f9d3ca8fb1e58ea8b44348b84c47e8ff45a, <span class="keyword">for</span> GNU/Linux 3.2.0, not stripped</span><br><span class="line"></span><br><span class="line">$ file /lib/libdmmp.so.0.2.0</span><br><span class="line">/lib/libdmmp.so.0.2.0: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=6f45d79f689c7bf1c7677423d33ad92a7b835fbc, stripped</span><br><span class="line"></span><br><span class="line">$ file coredump</span><br><span class="line">coredump: ELF 64-bit LSB core file, x86-64, version 1 (SYSV), SVR4-style, from <span class="string">&#x27;./hello.out&#x27;</span>, real uid: 0, effective uid: 0, real gid: 0, effective gid: 0, execfn: <span class="string">&#x27;./hello.out&#x27;</span>, platform: <span class="string">&#x27;x86_64&#x27;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>实际上，在新版本的 gcc 中，通过 <code>file</code> 查看到的可执行文件的格式是 <code>shared object</code>，这是因为编译器默认启用了 <code>-pie</code> 标志，因此只要在编译时添加编译选项 <code>-no-pie</code> 即可变成 <code>executable</code>，详情参见👉 <a href="https://blog.csdn.net/weixin_43833642/article/details/104557656">这篇博客</a>。其中 <code>-pie</code> 的作用我会在下一篇博客中介绍。</p>
</blockquote>
</li>
</ol>
<h2 id="目标文件里有什么"><a class="markdownIt-Anchor" href="#目标文件里有什么"></a> 目标文件里有什么</h2>
<p>目标文件中除了会包含编译后生成的代码和数据之外，还包括了链接时所需要的一些信息，如符号表、字符串表、调试信息等。这些信息按照不同的属性，以 <strong>段</strong>（Segment 或 <strong>Section</strong>） 的形式存储。下面以 <code>SimpleSection.o</code> 为例看一下其内部细节。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">    &gt; File Name: SimpleSection.c</span></span><br><span class="line"><span class="comment">    &gt; Author: Youngh</span></span><br><span class="line"><span class="comment">    &gt; Mail: younghblog@gmail.com</span></span><br><span class="line"><span class="comment">    &gt; Created Time: 2022-06-01 09:32:47</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_init_var = <span class="number">84</span>;</span><br><span class="line"><span class="type">int</span> g_uninit_var;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_static_init_var = <span class="number">83</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_static_uninit_var;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_init_var = <span class="number">85</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_uninit_var;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    func(static_init_var + static_uninit_var + a + b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们以 32 位模式进行编译（并未链接），以生成目标文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -c SimpleSection.c -m32</span><br></pre></td></tr></table></figure>
<p>通过 <code>objdump -h</code> 可以查看目标文件中关键段的基本信息：</p>
<img src="https://img.gejiba.com/images/ec9d561dc4b120e5145d865154af241e.webp" alt="关键段" style="zoom:60%;" />
<center>图2-1 关键段</center>
<p>打印出的信息共有 7 列，<code>Size</code> 表示段的长度；<code>VMA</code> 即 Virtual Memory Address，是段的虚拟地址，<code>LMA</code> 即 Load Memory Address，是段的装载地址，正常情况下两个值是一样的，但在某些嵌入式系统，特别是将程序放在 ROM 中的系统中值会不同；<code>File off</code> 是段所在的位置。</p>
<p>在段名一列，可以看到除了我们熟悉的 <code>.text</code>、<code>.data</code>、<code>.bss</code> 和 <code>.rodata</code> 之外，还有一些其他段。其中 <code>.comment</code> 存放的是编译器的版本信息，<code>.note.GNU-stack</code> 是堆栈提示段，剩余段暂不细究。</p>
<p>每个段的第 2 行表示段的各种属性。<code>CONTENTS</code> 表示该段在文件中存在，可以看到 <code>.bss</code> 段实际上在 ELF 文件中并不存在内容；<code>.note.GNU-stack</code> 段虽然有 <code>CONTENTS</code>，但其长度为 0，我们暂且也认为它在 ELF 文件中不存在。</p>
<p>根据上述打印出的信息，我们可以画出该目标文件的结构图：</p>
<img src="https://img.gejiba.com/images/3d04b951138994a76311dc3a02f49608.webp" alt="SSo" style="zoom:45%;" />
<center>图2-2 SimpleSection.o结构</center>
<p>接下来分别看一下各个段里的内容。</p>
<h3 id="代码段"><a class="markdownIt-Anchor" href="#代码段"></a> 代码段</h3>
<p>通过 <code>objdump -s</code> 可以查看目标文件中所有段的内容，并以十六进制的形式展示；而 <code>-d</code> 可以将所有包含指令的段反汇编。因此，执行 <code>objdump -s -d SimpleSection.o</code> 则可以同时打印这些内容。</p>
<p>由于内容过多，我将只截取与当前主题相关的信息：</p>
<img src="https://img.gejiba.com/images/31f2ef1fcf46e594e60400dc0b75ad9f.webp" alt="text" style="zoom:65%;" />
<center>图2-3 .text段</center>
<p>其中最左边一列是 <code>.text</code> 中的内容在该段中的偏移量，中间 4 列是十六进制内容，最右边一列是 <code>.text</code> 段的 ASCII 码形式。对照下面的反汇编结果，可以发现二者完全一致，因此 <code>.text</code> 段包含了 <code>func()</code> 与 <code>main()</code> 两个函数的所有指令。</p>
<h3 id="数据段和只读数据段"><a class="markdownIt-Anchor" href="#数据段和只读数据段"></a> 数据段和只读数据段</h3>
<img src="https://img.gejiba.com/images/07704393c9c5253e1e0eccfad5073f82.webp" alt="data&rodata" style="zoom:60%;" />
<center>图2-4 .data&.rodata段</center>
<p><code>.data</code> 段保存的是已初始化且值不为 0 的全局变量和静态变量，在 <code>SimpleSection.c</code> 中对应 <code>g_init_var</code>、<code>g_static_init_var</code> 与 <code>static_init_var</code> 三个变量。从上图可以看到，该段保存的内容有三个值（小端法），分别是 <code>0x00000054</code>、<code>0x00000053</code> 与 <code>0x00000055</code>，分别对应十进制的 84、83 和 85，正好对应上述三个变量。</p>
<p>在 <code>SimpleSection.c</code> 中调用 <code>printf()</code> 时用到了一个字符串常量 <code>%d\n</code>，它是只读的，因此放在 <code>.rodata</code> 段。从上图可以看到，该段保存的内容为 <code>25 64 01 00</code>，分别对应 ASCII 值 <code>% d \n \0</code>，其中 <code>\0</code> 是结束标志。</p>
<h3 id="bss-段"><a class="markdownIt-Anchor" href="#bss-段"></a> BSS 段</h3>
<p><code>.bss</code> 段存放的是未初始化和初始化为 0 的全局变量和静态变量，在 <code>SimpleSection.c</code> 中对应 <code>g_uninit_var</code>、<code>g_static_uninit_var</code> 与 <code>static_uninit_var</code> 三个 int 型变量，因此该段的大小应该为 12 个字节，但图 2-1 却显示该段大小只有 8 个字节。</p>
<p>我们可以查看一下目标文件的符号信息：</p>
<img src="https://img.gejiba.com/images/22aab797f0251672803f931d2e3fbfc6.webp" alt="symboltable" style="zoom:60%;" />
<center>图2-5 符号表内容</center>
<p>可以看到 <code>.bss</code> 段只会存放未初始化的静态变量，而未初始化的全局变量 <code>g_uninit_var</code> 则没有存放在任何段，只是一个未定义的 <code>COMMON</code> 符号。</p>
<p><code>.bss</code> 段其实并没有实际存放数据，即它并不会占用磁盘空间，只是通过记录这些未初始化静态变量的大小，达到为其预留空间的目的。更具体地讲，该段只是节省了最终存储在磁盘中的文件所占用的空间，而一旦该文件被装载到内存，就需要为其分配相应大小的内存空间，这样才能保证程序正确运行。</p>
<p><strong><span class="p red">那为什么未初始化的全局变量没有放在 <code>.bss</code> 段呢？</span></strong></p>
<p>这主要是因为未初始化的全局变量是 <strong>弱符号</strong>，在链接时该符号有可能在其他模块中所占的空间更大，那编译器就应该为该符号分配更大的空间。也就是说，在编译阶段并不能确定该符号的大小，所以 <code>.bss</code> 段并不知道应该为其分配多大的空间。当链接完成之后，任何一个弱符号的大小就确定下来了，因此会在最终的可执行文件中的 <code>.bss</code> 段为其分配空间。</p>
<p>由此可知，在最终生成的可执行文件中，未初始化或初始化为 0 的全局变量和静态变量都是存放在 <code>.bss</code> 段的，只是在链接之前，<code>.bss</code> 段只存放了未初始化或初始化为 0 的静态变量。</p>
<p>关于弱符号，我后面会做详细介绍，这里只需有个印象即可。</p>
<h2 id="elf-文件结构描述"><a class="markdownIt-Anchor" href="#elf-文件结构描述"></a> ELF 文件结构描述</h2>
<p>通过以上介绍，我们已经可以大致勾勒出 ELF 文件的轮廓，接下来我们进一步看一下该目标文件的详细内容。</p>
<p>ELF 目标文件以 <strong>ELF 文件头</strong>（ELF Header）开始，该结构描述了整个文件的基本属性。</p>
<p>紧接着就是 ELF 文件的各个段，每个段的基本信息是保存在 <strong>段表</strong>（Section Header Table）中的，段表也在该目标文件中。</p>
<p>另外还会有一些其他辅助结构，比如符号表、字符串表以及重定位表等。</p>
<h3 id="文件头"><a class="markdownIt-Anchor" href="#文件头"></a> 文件头</h3>
<p>查看 ELF 文件头：</p>
<img src="https://img.gejiba.com/images/7821e360ff1a2f910949afd1ed24053c.webp" alt="ELFHeader" style="zoom:60%;" />
<center>图3-1 ELF文件头</center>
<ul>
<li>
<p><strong>ELF 魔数</strong>。描述了 ELF 文件的平台属性。前 4 个字节是所有 ELF 文件都必须相同的标识码，其中第一个字节对应 ASCII 字符里的 DEL 控制符，后面三个字节分别对应 ELF 三个字母。其余每个字节的含义都已在图中标出。需要说明的是，ELF 文件的主版本号一般是 1，因为 ELF 自 1.2 以后就再没更新了。</p>
<img src="https://img.gejiba.com/images/31aa7c216dc6e241ae8fe37267672daf.webp" alt="Magic" style="zoom:55%;" />
<center>图3-2 魔数</center>
</li>
<li>
<p>数据存储方式：用补码（2’s complement）表示有符号数，用小端法存储。</p>
</li>
<li>
<p>Type：表示 ELF 文件类型。系统正是据此来判断 ELF 文件类型的，而不是通过文件扩展名。</p>
</li>
<li>
<p>ELF 文件头大小为 52 个字节，对应十六进制 0x34，因此其结束地址即为 0x34。</p>
</li>
<li>
<p>段表的位置在 1212 处，对应十六进制的 0x4bc。段表中有 16 个元素，每个元素的大小为 40 个字节，因此段表的大小为 16 * 40 = 640 = 0x280，于是段表的结束地址为 0x4bc + 0x280 = 0x73c。</p>
<p>我们再来查看一下目标文件的大小：</p>
<img src="https://img.gejiba.com/images/662d52cb1f04c6822004f4c9316d3414.webp" alt="ObjectSize" style="zoom:60%;" />
<center>图3-3 目标文件大小</center>
<p>目标文件的大小是 1852 个字节，对应十六进制为 0x73c，因此其虚拟地址范围为 0x000 ~ 0x73c，由此可知段表就在该目标文件的末尾。</p>
</li>
</ul>
<h3 id="段表"><a class="markdownIt-Anchor" href="#段表"></a> 段表</h3>
<p><strong>段表</strong>（Section Header Table）保存了段的基本属性，比如每个段的名字、长度、偏移、读写权限等等。换言之，<strong>ELF 文件的段结构是由段表决定的</strong>，编译器、链接器和装载器也都是依靠段表来定位和访问各个段的属性的。</p>
<p>前面我们通过 <code>objdump -h</code> 只是打印出了 ELF 文件中的关键段，下面我们通过打印段表来查看一下 ELF 文件的完整的段：</p>
<img src="https://img.gejiba.com/images/e4dd2cb1f932587d4d2c6ae7d4a67a93.webp" alt="SectionHeader" style="zoom:55%;" />
<center>图3-4 段表信息</center>
<ul>
<li>
<p>Nr：段的索引。通过其他命令查询到的段的索引与这里相对应。</p>
</li>
<li>
<p>Type：段的类型，共有如下几种类型：</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">值</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NULL</td>
<td style="text-align:center">0</td>
<td style="text-align:center">无效段</td>
</tr>
<tr>
<td style="text-align:center">PROGBITS</td>
<td style="text-align:center">1</td>
<td style="text-align:center">程序段，包括代码段和数据段</td>
</tr>
<tr>
<td style="text-align:center">SYMTAB</td>
<td style="text-align:center">2</td>
<td style="text-align:center">符号表</td>
</tr>
<tr>
<td style="text-align:center">STRTAB</td>
<td style="text-align:center">3</td>
<td style="text-align:center">字符串表</td>
</tr>
<tr>
<td style="text-align:center">RELA</td>
<td style="text-align:center">4</td>
<td style="text-align:center">重定位表</td>
</tr>
<tr>
<td style="text-align:center">HASH</td>
<td style="text-align:center">5</td>
<td style="text-align:center">符号表的哈希表</td>
</tr>
<tr>
<td style="text-align:center">DYNAMIC</td>
<td style="text-align:center">6</td>
<td style="text-align:center">动态链接信息</td>
</tr>
<tr>
<td style="text-align:center">NOTE</td>
<td style="text-align:center">7</td>
<td style="text-align:center">提示性信息</td>
</tr>
<tr>
<td style="text-align:center">NOBITS</td>
<td style="text-align:center">8</td>
<td style="text-align:center">在文件中没有内容</td>
</tr>
<tr>
<td style="text-align:center">REL</td>
<td style="text-align:center">9</td>
<td style="text-align:center">包含重定位信息</td>
</tr>
<tr>
<td style="text-align:center">SHLIB</td>
<td style="text-align:center">10</td>
<td style="text-align:center">保留</td>
</tr>
<tr>
<td style="text-align:center">DNYSYM</td>
<td style="text-align:center">11</td>
<td style="text-align:center">动态链接的符号表</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Addr：段的虚拟地址。如果该段可以被加载，则为加载后在进程虚拟地址空间中的地址，否则为 0。</p>
</li>
<li>
<p>Off：该段在文件中的偏移量。</p>
</li>
<li>
<p>ES：即 Entry Size。若该段包含了一些大小固定的项，则此值表示每个项的大小，否则为 0。</p>
</li>
<li>
<p>Flg：段的标志位。其中 A（Alloc）表示该段在进程空间中需要分配空间。</p>
</li>
<li>
<p>Al：即 Address Alignment，段地址对齐。0 和 1 表示没有对齐要求。</p>
</li>
</ul>
<h3 id="重定位表"><a class="markdownIt-Anchor" href="#重定位表"></a> 重定位表</h3>
<p>在链接时需要知道哪些指令需要被调整，指令的哪些部分需要被调整，以及怎么调整，而 <strong>重定位表</strong> 就是用来记录重定位相关信息的。</p>
<p>严格来说，重定位表实际上应该叫重定位段，因为每个要被重定位的 ELF 段都有一个对应的重定位表，比如 <code>.rel.text</code>、<code>.rel.data</code> 等，可以通过以下命令来查看目标文件中的重定位表：</p>
<img src="https://img.gejiba.com/images/5316a41dae31cc6739591afb4bc8cbea.webp" alt="rel" style="zoom:60%;" />
<center>图3-5 重定位表</center>
<p>其中 <code>OFFSET</code> 对应指令中需要调整的地址，可以结合反汇编代码进行查看：</p>
<img src="https://img.gejiba.com/images/1131223a0715763943fec8ec777b31a6.webp" alt="objdump" style="zoom:60%;" />
<center>图3-6 反汇编代码</center>
<p>以需要重定位的 <code>printf</code> 为例，其地址为 0x25，对应到反汇编代码中正好是 call 指令所调用的 printf 的地址。<code>TYPE</code> 表示重定位符号的调整方式，函数和变量的调整方式是不一样的。</p>
<h3 id="字符串表"><a class="markdownIt-Anchor" href="#字符串表"></a> 字符串表</h3>
<p>引用字符串表中的字符串只需给出一个下标，然后一直往后读，直到遇到 <code>\0</code>（0x00）停止。</p>
<p>在图 3-4 中，有两个字符串表，分别是 <code>.strtab</code> 与 <code>.shstrtab</code>，它们的索引分别是 14 和 15。其中：</p>
<ul>
<li>
<p><code>.strtab</code> 是 <strong>字符串表</strong>，用来保存普通的字符串，比如符号名：</p>
<img src="https://img.gejiba.com/images/cce93cd82ced57b9fbc97ef9c5231f2d.webp" alt="strtab" style="zoom:60%;" />
<center>图3-7 .strtab内容</center>
<p>第一列即表示字符串在该表中的下标，下同。</p>
</li>
<li>
<p><code>.shstrtab</code> 是 <strong>段表字符串表</strong>，用来保存段表中的字符串，通常是段名：</p>
<img src="https://img.gejiba.com/images/f5d75fab13c920843e0fa3df2b0c448b.webp" alt="shstrtab" style="zoom:60%;" />
<center>图3-8 .shstrtab内容</center>
</li>
</ul>
<h3 id="符号表"><a class="markdownIt-Anchor" href="#符号表"></a> 符号表</h3>
<p><strong>符号表</strong>（<code>.symtab</code>）记录了目标文件中所用到的所有符号，我们可以打印出来看一下：</p>
<img src="https://img.gejiba.com/images/efd17aa4a2c29631be034a30e124a57b.webp" alt="symtab" style="zoom:55%;" />
<center>图3-9 符号表内容</center>
<p>符号表的第一个元素，即下标为 0 的元素总是一个无效的未定义符号。接下来我们从最右边一列开始看起：</p>
<ul>
<li>Name：可以看到有些符号的名字并没有显示，这些符号都是段名，根据 Ndx 可以在图 3-4 中找到相应的段名。</li>
<li>Ndx：符号所在段，可以结合图 3-4 查看。另外 <code>UND</code> 是未定义（如 printf），表示该符号在本文件中被引用，但却在其他文件中定义；<code>ABS</code> 表示该符号包含一个绝对的值；<code>COM</code> 表示该符号是一个 COMMON 类型的符号，如未初始化的全局变量 <code>g_uninit_var</code>。</li>
<li>Vis：在 C/C++ 中未使用，我们暂时忽略它。</li>
<li>Bind：符号绑定信息。<code>LOCAL</code> 表示局部符号，仅本目标文件可见；<code>GLOBAL</code> 表示全局符号，外部可见；<code>WEAK</code> 表示弱引用。</li>
<li>Type：符号类型。<code>NOTYPE</code> 表示未知类型的符号；<code>FILE</code> 表示该符号是文件名；<code>SECTION</code> 表示该符号是一个段；<code>OBJECT</code> 表示该符号是个数据对象，例如变量、数组等；<code>FUNC</code> 表示该符号是个函数或其他可执行代码。</li>
<li>Size：符号大小。对于包含数据的符号，该值是数据类型的大小。0 表示该符号大小为 0 或未知。</li>
</ul>
<h3 id="重绘目标文件结构"><a class="markdownIt-Anchor" href="#重绘目标文件结构"></a> 重绘目标文件结构</h3>
<p>基于以上信息，我们在之前的基础上对 <code>SimpleSection.o</code> 的结构做了进一步完善（灰色段表示在本文中没有细究）：</p>
<img src="https://img.gejiba.com/images/cb5b8a4a7dc373f2c7465b5c7fb13fbf.webp" alt="SimpleSection" style="zoom:70%;" />
<center>图3-10 SimpleSection.o结构</center>
<p>可以看到在段表字符串表（.shstrtab）与段表（Section Header Table）之间存在 3 个字节的间隙，这是对齐所造成的。</p>
<h2 id="符号和引用"><a class="markdownIt-Anchor" href="#符号和引用"></a> 符号和引用</h2>
<p>我们从图 3-9 可以看到变量 <code>static_init_var</code> 与 <code>static_uninit_var</code> 变成了 <code>static_init_var.1513</code> 与 <code>static_uninit_var.1514</code>，这是 <strong>符号修饰</strong> 的结果，主要是为了防止符号冲突。</p>
<p>不同编译器采用了不同的符号修饰方法，因此不同编译器编译生成的目标文件之间无法正常链接。C++ 为了能够与 C 兼容引入了 <code>extern &quot;C&quot;</code>，从而保证该部分代码能够被当做 C 语言处理，C++ 的符号修饰机制将不会对该部分代码起作用，这样就保证了 C 库函数能够正常使用。</p>
<p>尽管有符号修饰，当多个目标文件中含有相同名字的全局符号定义时，链接过程中仍然会出现 <strong>符号重定义</strong> 的错误，这就涉及到了强弱符号的概念。</p>
<p>对于 C/C++，编译器会默认 <span class="p red">函数</span> 和 <span class="p red">初始化的全局变量</span> 为 <strong>强符号</strong>，而 <span class="p red">未初始化的全局变量</span> 为 <strong>弱符号</strong>，也可已通过 GCC 的 <code>__attribute__((weak))</code> 来定义任何一个强符号为弱符号。</p>
<p>根据强弱符号的概念，链接器的处理规则如下：</p>
<ol>
<li>规则 1：不允许强符号被多次定义，否则会报重复定义的错误；</li>
<li>规则 2：如果一个符号在某个目标文件中是强符号，在其他目标文件中是弱符号，那么会选择强符号；</li>
<li>规则 3：如果一个符号在所有目标文件中都是弱符号，那么选择其中占空间最大的那个。</li>
</ol>
<p>当一个目标文件中存在对外部目标文件中符号的引用时，链接过程中如果找不到该符号的定义，链接器就会报符号未定义错误，这种引用称为 <strong>强引用</strong>。</p>
<p>与之相对的还有 <strong>弱引用</strong>，处理弱引用时，如果该符号有定义则正常链接，如果没有也不会报错。对于未定义的弱引用，链接器会默认其为 0 或是一个特殊值，以便程序代码能够识别。</p>
<p>弱符号和弱引用对于库来说十分有用。比如库中定义的弱符号可以被用户定义的强符号覆盖，从而使用自定义版本的库函数；或者可以将某些扩展功能模块的引用定义为弱引用，这样当扩展模块与程序链接在一起时扩展功能可以正常使用，即使去掉了某些功能模块程序也可以正常链接，只是缺少了相应功能。</p>
<h2 id="静态链接"><a class="markdownIt-Anchor" href="#静态链接"></a> 静态链接</h2>
<p>静态链接采用 <strong>相似段合并</strong> 的方式，将多个目标文件中的代码段、数据段等分别进行合并，生成最终的可执行目标文件。整个链接过程分两步：</p>
<ul>
<li>第一步：空间与地址分配。扫描所有的输入目标文件，获取各个段的长度、属性和位置，并将符号表中所有的符号定义和符号引用统一放到全局的符号表中。链接器会将所有相同段合并，计算出各个段合并后的长度和位置，并与输入的目标文件建立映射关系。</li>
<li>第二部：符号解析与重定位。读取重定位信息，进行符号解析与重定位。</li>
</ul>
<p>这里以一个例子来介绍静态链接过程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">    &gt; File Name: a.c</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> shared;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *, <span class="type">int</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    swap(&amp;a, &amp;shared);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">    &gt; File Name: b.c</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> shared = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> &#123;</span><br><span class="line">    *a ^= *b ^= *a ^= *b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以 32 位模式将其编译成目标文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -c a.c b.c -m32 -fno-stack-protector</span><br></pre></td></tr></table></figure>
<p>这里之所以要去掉栈保护，是因为链接时会报 __stack_chk_fail_local 未定义错误。</p>
<p>使用 ld 链接器将二者链接起来，并且为了避免引入多余文件，将 main 指定为程序入口（默认为 _start）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ld -m elf_i386 a.o b.o -e main -o ab</span><br></pre></td></tr></table></figure>
<p>这里要加 <code>-m elf_i386</code> 是因为目标文件是 i386 架构，是 32 位的，而我机器上的 ld 默认是 i386:x86-64，是 64 位的，二者不兼容，因此需要指定链接器生成 32 位的可执行文件。</p>
<p>打印出链接前后各个段的属性（这里对输出做了简化）：</p>
<img src="https://img.gejiba.com/images/a1d1f4f2ae87701ac800fe9e6bdef6f7.webp" alt="a" style="zoom:60%;" />
<img src="https://img.gejiba.com/images/cc99cf40690aab83f2c000217aa26c6c.webp" alt="b" style="zoom:60%;" />
<img src="https://img.gejiba.com/images/f55c7828276c81f3bbfbde9d4c40041f.webp" alt="ab" style="zoom:60%;" />
<center>图4-1 链接前后</center>
<p>链接前，目标文件中所有段的虚拟地址都是 0，这是因为虚拟空间还没有分配；</p>
<p>链接后，可执行文件中的各个段都被分配到相应的虚拟地址。链接过程如下图：</p>
<img src="https://img.gejiba.com/images/dc9af7ad765e3fad30359317eee70a50.webp" alt="ld" style="zoom:60%;" />
<center>图4-2 链接过程</center>
<p>关于符号解析与重定位在上文的 <a href="#%E7%AC%A6%E5%8F%B7%E8%A1%A8">符号表</a> 与 <a href="#%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8">重定位表</a> 中有相关介绍，这里就不再赘述了。</p>
]]></content>
      <categories>
        <category>读书笔记 - 程序员的自我修养</category>
      </categories>
      <tags>
        <tag>静态链接</tag>
        <tag>ELF</tag>
      </tags>
  </entry>
  <entry>
    <title>温故而知新</title>
    <url>/posts/2281565213.html</url>
    <content><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>在整理 <a href="https://younghblog.gitee.io/categories/读书笔记-CSAPP/" target="_blank">CSAPP</a> 的这段时间，我阅读了《程序员的自我修养—链接、装载与库》这本经典书籍。书中基于 Linux 和 Windows 两大平台，介绍了系统软件的运行机制和原理，对链接、装载和库进行了深入浅出的剖析，强烈推荐❤️对系统底层感兴趣的各位小伙伴去阅读原书！</p>
<p>初次阅读，有点磕磕绊绊，所以趁现在有时间打算重新看一遍，顺便整理下笔记📝一方面加深理解，一方面便于查阅。这里我只会整理 Linux 平台下的相关笔记，Windows 暂时不打算看。</p>
<h2 id="思维导图"><a class="markdownIt-Anchor" href="#思维导图"></a> 思维导图</h2>
<p>由于线程相关概念与本书关系不大，后续内容也并没有对其做过多介绍，因此我在思维导图中对线程部分的描述会相对详细一些。</p>
<p><img src="https://img.gejiba.com/images/6f68bfa4ba88cb89dc5c0c7987bf064b.webp" alt="第一章思维导图" /></p>
]]></content>
      <categories>
        <category>读书笔记 - 程序员的自我修养</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟内存知多少</title>
    <url>/posts/1869698891.html</url>
    <content><![CDATA[<h2 id="认识虚拟内存"><a class="markdownIt-Anchor" href="#认识虚拟内存"></a> 认识虚拟内存</h2>
<p>虚拟内存是对主存和磁盘 I/O 设备的抽象，是 CPU 与物理内存之间的一个中间层。</p>
<p class='div-border white left right' style="border:1px solid #03a9f4; border-left-style: solid;border-left-width: 5px;border-right-style: solid; border-right-width: 5px;">计算机系统提供了不同层次的抽象表示，以隐藏实际实现的复杂性：</br></br><img src="https://img.gejiba.com/images/a8a67beaae798f3f562ff3c5e9048046.webp" alt="abstract" style="zoom:35%;" /></br>其中，操作系统是对硬件资源的抽象。</p>
<p>虚拟内存主要用来解决应用程序对内存需求日益增长的问题：现代物理内存的容量增长已经非常快了，但还是跟不上应用程序对主存需求的增长速度，即对于应用程序来说内存可能还是不够用，这就是虚拟内存出现的原因。</p>
<p>虚拟内存为每个进程提供了一个大的、一致的且私有的地址空间，同时提供了三个非常重要的能力：</p>
<ol>
<li>缓存机制。将主存看做磁盘的缓存，主存中只保留活动区域，并根据需要在主存和磁盘之间来回传送数据，从而使主存得到了高效的利用。</li>
<li>内存管理。为每个进程提供了一致的地址空间，从而简化了内存管理。</li>
<li>进程保护。每个进程的地址空间都是私有的，不会被其他进程破坏。</li>
</ol>
<h2 id="虚拟页"><a class="markdownIt-Anchor" href="#虚拟页"></a> 虚拟页</h2>
<p><span class="p red"><b>从概念上来说，虚拟内存是存放在磁盘上的一个地址连续的数组。</b></span>数组索引是虚拟地址，数组中的内容被缓存在主存中。</p>
<p>虚拟内存与物理内存之间以页为单位传送数据。虚拟内存中的页称为 <strong>虚拟页</strong>，物理内存中的页称为 <strong>物理页</strong>，物理页也叫 <strong>页帧</strong> 或 <strong>页框</strong>（page frame）。</p>
<p>虚拟页一共有三种状态：</p>
<ol>
<li><strong>未分配</strong>：磁盘中还没有任何数据与之相关联。</li>
<li><strong>已缓存</strong>：已分配，并且已经缓存在了物理内存中。</li>
<li><strong>未缓存</strong>：已分配，但尚未缓存在物理内存中。</li>
</ol>
<p><span class="p red"><b>从实现上来说，虚拟内存只是存放在内存中的一个数据结构。</b></span></p>
<p>进程执行前需要先装载，由于装载时已经建立了虚拟空间与可执行文件的映射关系，所以对于可执行文件中的任意虚拟页的访问，只会有缓存和未缓存两种状态。</p>
<p>未分配状态指的是磁盘中的空闲内存，可以通过内存分配函数（如 malloc）进行申请。</p>
<p>虚拟页往往很大，通常是 4KB ~ 2MB，这主要是因为主存的不命中处罚很大（主存不命中时访问磁盘的时间较长），为了补偿这些较长的访问时间，倾向于使用较大的数据块。并且由于大的不命中处罚，DRAM 缓存是全相联的，即任何虚拟页都可以放置在任何物理页中。</p>
<h2 id="页表"><a class="markdownIt-Anchor" href="#页表"></a> 页表</h2>
<p>如何判断一个虚拟页是否缓存到了 DRAM 中，以及缓存到了 DRAM 中的哪个物理页呢？除了需要依靠操作系统和 MMU 的支持外，还有一个非常重要的数据结构就是 <strong>页表</strong>。</p>
<p>每个进程都有自己的页表，页表保存在物理内存中，负责将虚拟页映射到物理页。每次 MMU 要将一个虚拟地址转换为物理地址时，都会读取页表。页表中的内容是由操作系统维护的。</p>
<p>页表中的每一项都是一个页表条目（Page Table Entry，PTE），每个虚拟页都会对应一个 PTE。这里先假设每个 PTE 只由 1 个有效位和 1 个 n 位地址字段组成。</p>
<p>有效位为 1 表示相应虚拟页被缓存到了物理内存中，而后面的地址字段就是相应物理页的地址。</p>
<p>如果有效位为 0，则表示相应虚拟页尚未缓存（地址字段指向该虚拟页在磁盘上的地址）或尚未分配（地址字段为空）。</p>
<img src="https://img.gejiba.com/images/1f533acea037920622ed8aae9cf30c54.webp" alt="页表" style="zoom:35%;" />
<p>上图展示了 8 个虚拟页和 4 个物理页所对应的页表。有 4 个虚拟页被缓存在了物理内存中，因此页表中对应项的有效位为 1，并且地址指向物理页；VP0 和 VP5 尚未分配，因此页表中对应项的有效位为 0，地址为空；VP3 和 VP6 已分配但尚未缓存，因此页表中对应项的有效位为 0，地址指向磁盘中的虚拟页。</p>
<h2 id="缺页"><a class="markdownIt-Anchor" href="#缺页"></a> 缺页</h2>
<p>对于已缓存的虚拟页可以直接命中，这种情况比较简单，这里重点看一下对于未缓存的虚拟页所导致的页不命中的情况，即缺页。</p>
<p>如图，CPU 要访问 VP3，但其并未缓存在 DRAM 中。此时 MMU 从页表中读取 PTE3，从有效位推断出 VP3 未被缓存，于是便触发了缺页异常。</p>
<img src="https://img.gejiba.com/images/5f5f928b95feb1ea1eb5aa38a898238e.webp" alt="BeforePageFault" style="zoom:35%;" />
<p>缺页异常会调用内核中相应的处理程序，从物理页中选择一个牺牲页（比如 VP4），用来存放 VP3。如果 VP4 已被修改，那么内核会将其写回磁盘。</p>
<p>接下来异常处理程序会根据 PTE 中的地址字段从磁盘中找到 VP3，将其复制到内存中的 PP3 位置，然后建立起虚拟页与物理页的映射关系并返回。此时 CPU 会重新执行导致缺页的那条指令，将虚拟地址重新发送到 MMU，此时就能够正常命中了，如图：</p>
<img src="https://img.gejiba.com/images/f4197667bc9721f172fe9fa89508984a.webp" alt="AfterPageFault" style="zoom:35%;" />
<h2 id="分配页面"><a class="markdownIt-Anchor" href="#分配页面"></a> 分配页面</h2>
<p>对于未分配的虚拟页，看一下其分配过程。</p>
<p>例如 VP5 尚未分配，当调用诸如 malloc 之类的分配函数时，会先在磁盘上分配空间，然后更新页表项 PTE5，使其指向磁盘中新创建的页，这时该虚拟页就从未分配变成了未缓存状态：</p>
<img src="https://img.gejiba.com/images/22b521b7beef951628c4e3dea87d7ce5.webp" alt="allocate" style="zoom:35%;" />
<h2 id="内存保护"><a class="markdownIt-Anchor" href="#内存保护"></a> 内存保护</h2>
<p>我们前面提到了页表中每个 PTE 由 1 个有效位和 1 个 n 位地址字段组成，事实上远不止这些。为了控制对内存系统的访问，这里再介绍 3 个额外的许可位：</p>
<ul>
<li><code>SUP</code>：表示内核（超级用户）模式。运行在内核模式的进程可以访问任何页面，而运行在用户模式的进程只能访问 <code>SUP</code> 为 0 的页面。</li>
<li><code>READ</code>：控制对页面的读访问权限。</li>
<li><code>WRITE</code>：控制对页面的写访问权限。</li>
</ul>
<p>通过这些许可位就可以控制一个用户进程不能修改其只读代码段，不能读写内核中的代码和数据段，不能读写其他进程的私有内存，不能修改与其他进程共享的虚拟页面（除非其他共享者都显式地允许它这么做），从而起到了 <strong>内存保护</strong> 的作用。</p>
<p>如果指令违反了这些许可条件，例如修改一个只读代码段，CPU 就会触发保护机制，在 Linux 中会报段错误（segmentation fault）。</p>
<h2 id="地址翻译"><a class="markdownIt-Anchor" href="#地址翻译"></a> 地址翻译</h2>
<p>了解了虚拟页、物理页和页表之后，再来看一下 <strong>地址翻译</strong>，即 MMU 是如何通过页表将虚拟地址映射到物理地址的：</p>
<img src="https://img.gejiba.com/images/7c8774365c01d601e434fe57a33bc6a6.webp" alt="地址翻译" style="zoom:30%;" />
<p>其中 <strong>页表基址寄存器</strong> 指向当前页表。MMU 根据虚拟页号找到相应的 PTE，再根据物理页号与虚拟地址中的偏移量就可以得到相应的物理地址。</p>
<p>MMU 根据虚拟页号查找 PTE 时，有页命中和页不命中两种情况。当该 PTE 的有效位为 1 时页命中，为 0 时页不命中。</p>
<p>当页命中时：</p>
<img src="https://img.gejiba.com/images/f1b0706b7c81b38995c443f6ba08c05d.webp" alt="PTHit" style="zoom:25%;" />
<p>当页不命中时：</p>
<img src="https://img.gejiba.com/images/d44d25a093d0442c932ab25deea267aa.webp" alt="PTMiss" style="zoom:25%;" />
<p>为了方便理解，上图将高速缓存和内存放到一起进行表示，二者之间的实际交互关系如下：</p>
<img src="https://img.gejiba.com/images/073cdfdb3c2973603fd4546938322501.webp" alt="cache&dram" style="zoom:30%;" />
<p>可以发现，CPU 每产生一个虚拟地址，MMU 就必须进行一次访存操作，即查阅 PTE 将虚拟地址转换为物理地址。在最坏情况下，内存中也没有该页表项，这时就需要从磁盘换入该 PTE，然后 MMU 再额外进行一次访存操作。而在最好情况下，该 PTE 恰好缓存在 L1 Cache，那么访存开销就只有 1~2 个周期，而即便是这样的开销，很多系统也仍会试图消除它，具体做法就是在 MMU 中增加一个 PTE 的缓存，即 TLB。</p>
<h2 id="tlb"><a class="markdownIt-Anchor" href="#tlb"></a> TLB</h2>
<p>TLB（Translation Lookaside Buffer），俗称快表，是一个小的、虚拟寻址的缓存。为了通过虚拟地址寻找 TLB 中的项（TLB 是组相联或全相联的），将虚拟地址的虚拟页号（VPN）进一步划分为 TLB 的标记位（TLBT）和组索引位（TLBI），如图所示：</p>
<img src="https://img.gejiba.com/images/b7c9f89274715cefa3afc2b1ea971fe9.webp" alt="VA" style="zoom:30%;" />
<p>TLB 通常有高度的相联度，每一行都缓存了 PTE 的内容。并且由于是在 MMU 中，因此地址翻译非常快。</p>
<p>当 TLB 命中时：</p>
<img src="https://img.gejiba.com/images/4bf7ca2feda8831061d108d2cc7855db.webp" alt="TLBHit" style="zoom:30%;" />
<p>当 TLB 不命中时：</p>
<img src="https://img.gejiba.com/images/93e15328ed4c3497365420ceed176acd.webp" alt="TLBMiss" style="zoom:30%;" />
<h2 id="多级页表"><a class="markdownIt-Anchor" href="#多级页表"></a> 多级页表</h2>
<p>到现在为止，我们一直假设系统只用一个单独的页表来进行地址翻译，但这显然是不现实的。我们可以计算一下：对于一个 32 位地址空间的系统，页大小为 4KB，一个页表项是 4 个字节，那么这个页表有多大？</p>
<blockquote>
<ul>
<li>
<p>32 位地址空间 <span class="p red"><b>→</b></span> 地址总数是2<sup>32</sup> ，而每个地址对应的内存空间为 1 B，所以最大内存空间为 2<sup>32</sup> B</p>
</li>
<li>
<p>4 KB 的页 <span class="p red"><b>→</b></span> 即页大小为 2<sup>12</sup> B <span class="p red"><b>→</b></span> 总页数为 2<sup>32</sup> B / 2<sup>12</sup> B = 2<sup>20</sup></p>
</li>
<li>
<p>4 B 的页表项 <span class="p red"><b>→</b></span> 即页表项大小为 2<sup>2</sup> B，而一个页表项对应一个页，所以有 2<sup>20</sup> 个页就需要有相同数量的页表项 <span class="p red"><b>→</b></span> 页表大小 = 页表项数 x 页表项大小 = 2<sup>20</sup> x 2<sup>2</sup> B = 4 x 2<sup>20</sup> B = 4 MB</p>
</li>
</ul>
<p class='div-border blue left right'> 2<sup>30</sup> B	=	1 GB</br>2<sup>20</sup> B	=	1 MB</br>2<sup>10</sup> B	=	1 KB</p>
</blockquote>
<p>由此可知，在内存中必须驻留一个 4MB 大小的页表，即使该程序只用到了虚拟地址空间中很小的一部分。对于 64 位的系统来说，页表会更大。</p>
<p>为了压缩页表，常用的方法就是使用 <strong>多级页表</strong>。还是上面的例子，一个 4MB 的页表映射了 4GB 的空间，如果我们使用两级页表，那么效果会是什么样呢？</p>
<p>将这个独立的页表拆分成 1024 个等大小的页表，那么每个页表的大小为 4MB / 1024 = 4 KB，每个 4KB 的页表能够映射 4KB / 4B * 4KB = 4MB 的虚拟地址空间，这段空间我们称其为 <strong>片</strong>（chunk）。</p>
<p>为了管理这 1024 个页表，还需要一个页表，这里将其称为 <strong><span class="p red">一级页表（也叫页目录）</span></strong>，相应地这 1024 个页表就叫二级页表。一级页表中一个页表项对应一个二级页表，因此一级页表就有 1024 个页表项，于是一级页表的大小为 1024 * 4B = 4KB。</p>
<p>可以发现，一级页表和每个二级页表大小都是 4KB，刚好是一个页的大小。</p>
<img src="https://img.gejiba.com/images/aa4db5f33751e65016341f82cc31be0a.webp" alt="2levelPT" style="zoom:40%;" />
<p>如果某个片中每个虚拟页均未分配，那么相应的一级页表项就为空（片2~7），自然也不需要二级页表了。多级页表从两个方面缓解了对内存的需求：</p>
<ul>
<li>如果一级页表为空，那么相应的二级页表根本就不会存在。这代表着一种巨大的潜在节约，因为对于一个典型的程序来说，4GB 的虚拟地址空间中大部分虚拟页都是未分配的。</li>
<li>只有一级页表和经常使用的二级页表才需要缓存在主存中，其他二级页表只在必要时换入换出，这就大大减少了主存的压力。</li>
</ul>
<p>当使用了 k 级页表之后，进行地址翻译时虚拟地址中的虚拟页号会被划分成 k 个：</p>
<img src="https://img.gejiba.com/images/a2b7aa48456b24f6f8be5fd722fbfc07.webp" alt="klevelPT" style="zoom:28%;" />
<p>在前 k - 1 级页表中，每个 PTE 都指向下一级页表的基地址，第 k 级页表中的 PTE 则包含了某个物理页的页号，或者某个磁盘块的地址。为了构造出物理地址，MMU 必须访问 k 个页表。</p>
<div class="note quote flat"><p>事实上，多级页表的地址翻译并不会比单页表慢很多。</p>
</div>
<p>以 Core i7 为例，看一下完整的地址翻译过程。</p>
<p>Core i7 采用四级页表的层次结构，CR3 寄存器保存了一级页表的基地址。CR3 的值是每个进程上下文的一部分，每次进程上下文切换时，CR3 的值都会被保存和恢复。</p>
<p>Core i7 的内存系统如下：</p>
<img src="https://img.gejiba.com/images/b7450e2a058a179082ebcac570771477.webp" alt="corei7mem" style="zoom:40%;" />
<p>地址翻译过程如下：</p>
<img src="https://img.gejiba.com/images/1be6c26ad41cec6488e280cbddcc30d3.webp" alt="corei7addtranslation" style="zoom:40%;" />
<h2 id="linux-虚拟内存系统"><a class="markdownIt-Anchor" href="#linux-虚拟内存系统"></a> Linux 虚拟内存系统</h2>
<p>Linux 进程的虚拟内存空间如下图，我们已经很熟悉了。</p>
<img src="https://img.gejiba.com/images/b3d458042407463af9d69dfab0d3a6d1.webp" alt="Linux进程的虚拟内存空间" style="zoom:60%;" />
<p>Linux 将虚拟内存组织为区域（area，也叫段）的集合，每个区域实际上都是一个数据结构。内核为系统中的每个进程都维护了一个任务结构 <code>task_struct</code>，其中包含了运行该进程所需的所有信息，例如 PID、PC、栈指针、可执行文件的名字等等。</p>
<p><img src="https://img.gejiba.com/images/0c09cdfb806b3ec4eec728948ddeeee9.webp" alt="vmas" /></p>
<p><code>task_struct</code> 的其中一个成员 <code>mm</code> 指向 <code>mm_struct</code>，它描述了虚拟内存的当前状态。其中 <code>pgd</code>（page global directory，页目录）指向页目录的基地址，当内核运行该进程时会将其存放在 CR3 控制寄存器中；<code>mmap</code> 则指向 <code>vm_area_struct</code> 链表。</p>
<p>每个 <code>vm_area_struct</code> 都描述了当前虚拟地址空间的一个区域，其中各字段的含义已在图中标出。</p>
<p>当 MMU 翻译某个虚拟地址时发生了缺页，缺页处理程序将会执行以下步骤：</p>
<ol>
<li>判断该虚拟地址是否合法，即是否在某个区域的地址范围内。此时需要比较该虚拟地址与每个区域结构的 <code>vm_start</code> 和 <code>vm_end</code>，如果不合法，则会触发 <strong>段错误</strong>，如图中 ① 所示，从而终止进程。</li>
<li>判断该内存访问是否合法，即进程是否有读、写或执行该区域的权限。如果不合法，比如要对只读代码段进行写操作，则会触发 <strong>保护异常</strong>，如图中 ② 所示，从而终止进程。</li>
<li>此时便可以确定该缺页是由于合法的虚拟地址进行合法的内存访问所造成的。处理缺页的过程为：选择一个牺牲页（如果没有空白页的话），如果被修改过则需要写回磁盘，然后换入新的物理页并更新页表。当缺页处理程序返回时，CPU 重新执行引起缺页的指令，此时就可以正常翻译了。</li>
</ol>
<h2 id="内存映射"><a class="markdownIt-Anchor" href="#内存映射"></a> 内存映射</h2>
<p>前面在介绍 <a href="#%E8%99%9A%E6%8B%9F%E9%A1%B5">虚拟页</a> 的时候，我们提到了当可执行文件被装载时，会建立虚拟地址空间与可执行文件的映射关系，这实际上就是内存映射。</p>
<p>Linux 通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化该虚拟内存区域中的内容，这个过程称为 <strong>内存映射</strong>。可以映射的磁盘文件有两种类型：</p>
<ol>
<li>普通文件。文件中保存了初始化的内容，例如可执行目标文件。页面按需调度，直到发生缺页时才会换入物理内存。如果换入之后没有填满该区域，则用零来填充剩余部分。</li>
<li><strong>匿名文件</strong>。文件中保存的都是二进制零，由内核创建。当虚拟内存空间映射到该区域时，并不需要在磁盘和内存之间进行数据传送，只需用零覆盖即可。因此，映射到匿名文件的页有时也叫 <strong>请求二进制零的页</strong>。</li>
</ol>
<p>无论哪种情况，一旦一个虚拟页与磁盘中的文件完成了内存映射，它就会在由内核维护的交换空间与物理内存之间换入换出。</p>
<p class='div-border blue left'><b>交换空间</b> 是磁盘上的一块区域，当物理内存吃紧时，会将内存中不常访问的数据换出到该区域，这样系统就有了更多的物理内存为各进程服务。当需要访问交换空间中存储的内容时，再将其换入到物理内存中。因此，<span class="p red"><b>交换空间限制了当前进程所能分配的虚拟页的总数。</b></span></p>]]></content>
      <categories>
        <category>读书笔记 - CSAPP</category>
      </categories>
      <tags>
        <tag>虚拟内存</tag>
        <tag>地址翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>高速缓存是如何查找数据的</title>
    <url>/posts/2065420180.html</url>
    <content><![CDATA[<h2 id="cache-的组织结构"><a class="markdownIt-Anchor" href="#cache-的组织结构"></a> Cache 的组织结构</h2>
<p>高速缓存可以看成由缓存行（cache line）组成的数组，每个缓存行分为三个部分，其中：</p>
<ul>
<li>
<p><strong>有效位</strong> 指明了当前行所存储的数据是否有效，大小为 1 个 bit；</p>
</li>
<li>
<p><strong>标记位</strong> 唯一地标识了存储在缓存行中的信息；</p>
</li>
<li>
<p><strong>数据块</strong>（Block） 则是部分内存数据的副本。</p>
</li>
</ul>
<p>高速缓存的组织结构可以用元组 <code>(S, E, B, m)</code> 表示，<code>m</code> 是主存物理地址的位数。</p>
<img src="https://img.gejiba.com/images/86f467a47a83e338e941edf133d73fc5.webp" alt="cachestruct" style="zoom:45%;" />
<p>高速缓存的大小（Capacity）指的是所有数据块的大小之和，并不包含有效位和标记位，因此可以通过 <code>C = B x E x S</code> 计算得到。</p>
<p>相应地，对高速缓存访问的 <code>m</code> 位的地址被划分成了如下结构：</p>
<img src="https://img.gejiba.com/images/85db219b099cce3ea5c5a13f86de723f.webp" alt="cacheaddr" style="zoom:70%;" />
<p>当某个地址向高速缓存发出访问后，首先根据组索引位 <code>s</code> 确定索要访问的数据在哪个组，然后根据标记位 <code>t</code> 确定组中的哪一行与之匹配，当且仅当有效位为 1 并且标记位也匹配时才算访存命中。此时，根据块偏移位 <code>b</code> 就可以从 B 个字节的数据块中抽取出所访问的数据。</p>
<h2 id="cache-的地址映射方式"><a class="markdownIt-Anchor" href="#cache-的地址映射方式"></a> Cache 的地址映射方式</h2>
<p>根据每个组高速缓存行的行数 <code>E</code>，高速缓存可以分为三种类型：</p>
<h3 id="直接映射高速缓存"><a class="markdownIt-Anchor" href="#直接映射高速缓存"></a> 直接映射高速缓存</h3>
<p><code>E == 1</code>：</p>
<img src="https://img.gejiba.com/images/9828e5344d0fdc7b3d6b1754c5bfac0f.webp" alt="directmap" style="zoom:30%;" />
<p>由于每个组只有 1 个缓存行，因此访存时确定了所属组之后就只需访问一行，通过比较标记位和判断有效位来确定是否命中。若不命中，则从内存中取出相应数据直接替换掉当前行。</p>
<h3 id="组相联高速缓存"><a class="markdownIt-Anchor" href="#组相联高速缓存"></a> 组相联高速缓存</h3>
<p><code>1 &lt; E &lt; C/B</code>：</p>
<img src="https://img.gejiba.com/images/8ac0edf84c919e9c95998d17fe2aab75.webp" alt="二路组相联cache" style="zoom:43%;" />
<p>每个组包含不止一个缓存行，通常也叫 <strong>E路组相联</strong> 高速缓存。</p>
<p>访存时确定了所属组之后，必须检查多个缓存行的标记位和有效位，因为组中的每一行都可以包含任何映射到这个组中的内存块，就相当于将所有哈希值相同的数据都放在同一个组中。</p>
<p>当访存不命中时，需要从内存中取出包含这个数据的块。此时，若该组中有空行，自然将取回的数据放入空行；如果没有，则需要选择其中一行进行替换。常见的缓存替换策略有 LFU（Least Frequently Used，最不经常使用）、LRU（Least Recently Used，最近最少使用）、随机替换等等。</p>
<h3 id="全相联高速缓存"><a class="markdownIt-Anchor" href="#全相联高速缓存"></a> 全相联高速缓存</h3>
<p><code>E == C/B</code>：</p>
<img src="https://img.gejiba.com/images/945c8168db1fd891a288777fd799a8b2.webp" alt="fullyassociativecache" style="zoom:45%;" />
<p>高速缓存只有一个组，包含了所有行。因此地址中不再需要组索引位，只包含标记位和块偏移。</p>
<p>此时的访存操作必须并行地比对很多标记位，构造一个又大又快的全相联高速缓存困难且昂贵，因此这种方式只适合做小的高速缓存，例如 TLB。</p>
]]></content>
      <categories>
        <category>读书笔记 - CSAPP</category>
      </categories>
      <tags>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title>多核CPU如何保证缓存一致性</title>
    <url>/posts/921523538.html</url>
    <content><![CDATA[<p>当 CPU 中的某个核要对内存中的数据进行修改时，会先将其缓存到 cache 中，然后再去修改。此时由于修改后的数据尚未写回到内存，如果其他核要去访问这个数据，就会读到修改之前的数据，这就是 <strong>缓存一致性问题</strong>。对此有两种解决方式：</p>
<h2 id="对总线加锁"><a class="markdownIt-Anchor" href="#对总线加锁"></a> 对总线加锁</h2>
<p>CPU 和其他组件都是通过 <strong>总线</strong>（数据总线、控制总线、地址总线）进行通信的，因此通过对总线加锁就可以保证只有一个核获取到锁，而其他核都处于阻塞状态。这样虽然保证了数据的一致性，但也严重影响了 CPU 的执行效率。</p>
<h2 id="使用缓存一致性协议-mesi"><a class="markdownIt-Anchor" href="#使用缓存一致性协议-mesi"></a> 使用缓存一致性协议 MESI</h2>
<p>该协议只对单个缓存行加锁，因此不会影响到内存中其他数据的读写，这样就可以保证执行效率。</p>
<p><strong>MESI</strong> 每个字母对应一种状态：</p>
<table>
<thead>
<tr>
<th style="text-align:center">状态</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">M（Modified）</td>
<td style="text-align:center">修改</td>
<td style="text-align:center">缓存行中的数据已被修改，与内存中的数据不一致，并且该数据只存在于本地 cache 中（即只存在于当前核的 cache 中）</td>
</tr>
<tr>
<td style="text-align:center">E（Exclusive）</td>
<td style="text-align:center">独享、互斥</td>
<td style="text-align:center">缓存行中的数据与内存中的数据一致，并且该数据只存在于本地 cache 中</td>
</tr>
<tr>
<td style="text-align:center">S（Shared）</td>
<td style="text-align:center">共享</td>
<td style="text-align:center">缓存行中的数据与内存中的数据一致，并且该数据存在于多个 cache 中（即存在于多个核的 cache 中）</td>
</tr>
<tr>
<td style="text-align:center">I（Invalid）</td>
<td style="text-align:center">无效</td>
<td style="text-align:center">当前缓存行无效</td>
</tr>
</tbody>
</table>
<p>MESI 的状态转移过程：</p>
<p class='div-border blue left'>local read/write：当前核读写本地 cache 中的缓存行数据。</br>remote read/write：其它核读写内存中的数据，该数据已被缓存到某个核的 cache 中。</p>
<table style="width:100%">
    <tr>
        <th align="center" bgcolor="#f5f6f8">当前<br/>状态</th> 
        <th align="center" bgcolor="#f5f6f8">事件</th> 
        <th align="center" bgcolor="#f5f6f8">行为</th> 
        <th align="center" width="8%" bgcolor="#f5f6f8">下个<br/>状态</th> 
   </tr>
    <tr>
        <td rowspan="5" align="center" style="font-size:50px; font-weight:bold">M</td>
    </tr>
    <tr>
        <td align="center">local read</td>
        <td align="left">从 cache 中读，状态不变</td>
        <td align="center">M</td>
    </tr>
    <tr>
        <td align="center">local write</td>
        <td align="left">修改 cache 数据，状态不变</td>
        <td align="center">M</td>
    </tr>
    <tr>
        <td align="center">remote read</td>
        <td align="left">将数据写回内存，使其它核能够获取到最新数据，状态变为 S</td>
        <td align="center">S</td>    
    </tr>
    <tr>
        <td align="center">remote write</td>
        <td align="left">将数据写回内存，使其它核能够获取到最新数据，状态变为 I</td>
        <td align="center">I</td>    
    </tr>
    <tr>
        <td rowspan="5" align="center" style="font-size:50px; font-weight:bold">E</td>    
    </tr>
    <tr>
        <td align="center">local read</td>
        <td align="left">从 cache 中读，状态不变</td>
        <td align="center">E</td>
    </tr>
    <tr>
        <td align="center">local write</td>
        <td align="left">修改 cache 数据，状态变为 M</td>
        <td align="center">M</td>
    </tr>
    <tr>
        <td align="center">remote read</td>
        <td align="left">数据与其它核共享，状态变为 S</td>
        <td align="center">S</td>    
    </tr>
    <tr>
        <td align="center">remote write</td>
        <td align="left">数据被修改，状态变为 I</td>
        <td align="center">I</td>    
    </tr>
    <tr>
        <td rowspan="5" align="center" style="font-size:50px; font-weight:bold">S</td>    
    </tr>
    <tr>
        <td align="center">local read</td>
        <td align="left">从 cache 中读，状态不变</td>
        <td align="center">S</td>
    </tr>
    <tr>
        <td align="center">local write</td>
        <td align="left">先将其它核的状态变为 I，再将本地状态变为 M</td>
        <td align="center">M</td>
    </tr>
    <tr>
        <td align="center">remote read</td>
        <td align="left">数据与其它核共享，状态不变</td>
        <td align="center">S</td>    
    </tr>
    <tr>
        <td align="center">remote write</td>
        <td align="left">数据被修改，状态变为 I</td>
        <td align="center">I</td>    
    </tr>
    <tr>
        <td rowspan="9" align="center" style="font-size:50px; font-weight:bold">I</td>    
    </tr>
    <tr>
        <td rowspan="3" align="center">local read</td>
        <td align="left">若其它核中没数据，则将内存中的数据缓存到本地 cache，状态变为 E</td>
        <td rowspan="3" align="center">E/S</td>
    </tr>
    <tr>
        <td align="left">若其它核中有数据，且状态为 M，则先将数据写回内存，然后将内存中的数据缓存到本地 cache，二者状态均变为 S</td>
    </tr>
    <tr>
        <td align="left">若其它核中有数据，且状态为 E 或 S，则将内存中的数据缓存到本地 cache，并将它们的状态均变为 S</td>
    </tr>
    <tr>
        <td rowspan="3" align="center">local write</td>
        <td align="left">若其它核中没数据，则将内存中的数据缓存到本地 cache，状态变为 M</td>
        <td rowspan="3" align="center">M</td>
    </tr>
    <tr>
        <td align="left">若其它核中有数据，且状态为 M，则先将数据写回内存，状态变为 I，然后将内存中的数据缓存到本地 cache，状态变为 M</td>
    </tr>
    <tr>
        <td align="left">若其它核中有数据，且状态为 E 或 S，则将它们的状态变为 I，然后将内存中的数据缓存到本地 cache，状态变为 M</td>
    </tr>
    <tr>
        <td align="center">remote read</td>
        <td align="left">本地数据已失效，不受其它核操作的影响</td>
        <td align="center">I</td>    
    </tr>
    <tr>
        <td align="center">remote write</td>
        <td align="left">本地数据已失效，不受其它核操作的影响</td>
        <td align="center">I</td>    
    </tr>
</table>]]></content>
      <categories>
        <category>读书笔记 - CSAPP</category>
      </categories>
      <tags>
        <tag>MESI</tag>
      </tags>
  </entry>
  <entry>
    <title>如何摆脱CPU分支预测错误</title>
    <url>/posts/2875321003.html</url>
    <content><![CDATA[<p>现在我们已经知道，CPU 引入流水线的目的就是为了保证每个时钟周期都能发射一条新的指令，从而提升其性能。要做到这一点，就必须在取出当前指令后立马确定下一条指令的位置。</p>
<p>根据 <a href="https://younghblog.gitee.io/posts/3931262747.html" target="_blank">上一篇</a> 博文可知，大多数指令都可以在取指阶段确定下一条指令的地址，比如对于 call 和 jmp（无条件跳转）指令来说，下一条指令的地址就是指令中的常数字 <code>valC</code>，而对于其他指令来说则是 <code>valP</code>。</p>
<p>但不幸的是，如果取出的指令是条件转移指令 cmovXX，则必须等到执行阶段完成才能确定下一条指令的地址。类似地，如果取出的指令是返回指令 ret，则要等到访存结束后才能确定下一条指令的地址。</p>
<p>CPU 对于 ret 的处理比较简单，即 <span class="p red">流水线必须暂停直到 ret 指令访存结束。</span>而对于 cmovXX，则会进行分支预测以提高 CPU 的执行效率。</p>
<h2 id="cpu-分支预测"><a class="markdownIt-Anchor" href="#cpu-分支预测"></a> CPU 分支预测</h2>
<p>具体来说，CPU 既可以预测选择了分支，也可以预测没有选择分支，然后按照所预测的方向继续往下执行。当然，预测终归只是预测，必然会有错误的情况发生。如果错误的分支预测经常发生，那么性能损失就会显著增加。因为当这样的事件发生时，CPU 已经取出并执行了部分错误的指令，因此需要清除掉所有这些错误的指令，同时还需要用来自正确分支的指令填充流水线。 <span class="p red">通常，现代 CPU 会因分支预测错误而遭受 10-20 个周期的惩罚。</span></p>
<p>如今，处理器非常擅长预测分支结果，不仅可以遵循静态预测规则，还可以检测动态模式。通常，分支预测器会采用后者。</p>
<p class='div-border blue left'> <b>静态分支预测</b>：由编译器来决定哪个分支可能被 CPU 命中。一般会选择第一个分支，即 if 后面的逻辑，而不是 else 后面的逻辑。</br><b>动态分支预测</b>：在运行期间决定预测结果。它会在 CPU 硬件中开辟一块缓存，专门记录每个分支最近几次的命中情况，然后做出预测。</p>
<p>通用来说，应用程序的错误预测率在 5%-10% 的范围是正常的，如果该指标高于 10% 就要引起注意了。</p>
<h2 id="摆脱分支预测错误的方式"><a class="markdownIt-Anchor" href="#摆脱分支预测错误的方式"></a> 摆脱分支预测错误的方式</h2>
<p><span class="p red">为了摆脱分支预测错误，最直接的方法就是摆脱分支本身。</span>接下来就介绍两种摆脱分支的方式。</p>
<h3 id="1-用查找表替换分支"><a class="markdownIt-Anchor" href="#1-用查找表替换分支"></a> 1. 用查找表替换分支</h3>
<p>通过查找表可以避免频繁的分支。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mapToBucket</span><span class="params">(<span class="type">unsigned</span> v)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; <span class="number">10</span>)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(v &gt;= <span class="number">10</span> &amp;&amp; v &lt; <span class="number">20</span>)  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v &gt;= <span class="number">20</span> &amp;&amp; v &lt; <span class="number">30</span>)  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(v &gt;= <span class="number">30</span> &amp;&amp; v &lt; <span class="number">40</span>)  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(v &gt;= <span class="number">40</span> &amp;&amp; v &lt; <span class="number">50</span>)  <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中存在许多分支，这些分支可能具有很高的错误预测率。</p>
<p>我们可以使用数组查找来重写该函数，这样函数的汇编代码应该只有一个分支而不是多个分支。此外，buckets 数组相对较小，因此我们可以期望它驻留在 CPU 缓存中，从而能够对其进行快速访问：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找表版本</span></span><br><span class="line"><span class="type">int</span> buckets[<span class="number">256</span>] = &#123;</span><br><span class="line">     <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,</span><br><span class="line">     <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>,</span><br><span class="line">     <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>,</span><br><span class="line">     <span class="number">3</span>,  <span class="number">3</span>,  <span class="number">3</span>,  <span class="number">3</span>,  <span class="number">3</span>,  <span class="number">3</span>,  <span class="number">3</span>,  <span class="number">3</span>,  <span class="number">3</span>,  <span class="number">3</span>,</span><br><span class="line">     <span class="number">4</span>,  <span class="number">4</span>,  <span class="number">4</span>,  <span class="number">4</span>,  <span class="number">4</span>,  <span class="number">4</span>,  <span class="number">4</span>,  <span class="number">4</span>,  <span class="number">4</span>,  <span class="number">4</span>,</span><br><span class="line">    <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>,</span><br><span class="line">    <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>,</span><br><span class="line">    ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mapToBucket</span><span class="params">(<span class="type">unsigned</span> v)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(v &lt; (<span class="keyword">sizeof</span>(buckets) / <span class="keyword">sizeof</span>(<span class="type">int</span>)))</span><br><span class="line">    	<span class="keyword">return</span> buckets[v];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们需要映射更大范围的值，分配一个非常大的数组是不切实际的。在这种情况下，可以使用 interval map 数据结构，以使用更少的内存和对数级的查找复杂度来实现该目标。</p>
<h3 id="2-用谓词替换分支"><a class="markdownIt-Anchor" href="#2-用谓词替换分支"></a> 2. 用谓词替换分支</h3>
<p>通过执行分支的两个部分，然后选择正确的结果，可以有效地消除一些分支。 如果 if 分支有非常多的错误预测，可以尝试通过这种方式来消除分支。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原始版本</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">if</span>(cond) &#123; <span class="comment">// 假设分支有较高的错误预测率</span></span><br><span class="line">    a = computeX();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    a = computeY();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 原始汇编版本</span></span><br><span class="line"><span class="attr">400504:</span> 	<span class="string">test</span>	<span class="string">%edi,</span> <span class="string">%edi</span>	<span class="comment"># 要在执行阶段完成后才能知道结果</span></span><br><span class="line"><span class="attr">400506:</span> 	<span class="string">je</span>	<span class="string">$400514</span></span><br><span class="line"><span class="attr">400508:</span> 	<span class="string">mov</span>	<span class="string">$0,</span> <span class="string">%eax</span></span><br><span class="line"><span class="attr">40050d:</span> 	<span class="string">call</span>	<span class="string">&lt;computeX&gt;</span></span><br><span class="line"><span class="attr">400512:</span> 	<span class="string">jmp</span>	<span class="string">$40051e</span></span><br><span class="line"><span class="attr">400514:</span> 	<span class="string">mov</span> 	<span class="string">$0,</span> <span class="string">%eax</span></span><br><span class="line"><span class="attr">400519:</span> 	<span class="string">call</span> 	<span class="string">&lt;computeY&gt;</span></span><br><span class="line"><span class="attr">40051e:</span> 	<span class="string">mov</span> 	<span class="string">%eax,</span> <span class="string">%edi</span></span><br></pre></td></tr></table></figure>
<p>用谓词替换分支后：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无分支版本</span></span><br><span class="line"><span class="type">int</span> x = computeX();</span><br><span class="line"><span class="type">int</span> y = computeY();</span><br><span class="line"><span class="type">int</span> a = cond ? x : y;</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 无分支汇编版本</span></span><br><span class="line"><span class="attr">400537:</span> 	<span class="string">mov</span> 	<span class="string">$0,</span> <span class="string">%eax</span></span><br><span class="line"><span class="attr">40053c:</span> 	<span class="string">call</span> 	<span class="string">&lt;computeX&gt;</span></span><br><span class="line"><span class="attr">400541:</span> 	<span class="string">mov</span> 	<span class="string">%eax,</span> <span class="string">%ebp</span></span><br><span class="line"><span class="attr">400543:</span> 	<span class="string">mov</span> 	<span class="string">$0,</span> <span class="string">%eax</span></span><br><span class="line"><span class="attr">400548:</span> 	<span class="string">call</span> 	<span class="string">&lt;computeY&gt;</span></span><br><span class="line"><span class="attr">40054d:</span> 	<span class="string">test</span> 	<span class="string">%ebx,</span> <span class="string">%ebx</span></span><br><span class="line"><span class="attr">40054f:</span> 	<span class="string">cmovne</span>	<span class="string">%ebp,</span> <span class="string">%eax</span>	<span class="comment"># 要在执行阶段完成后才能知道结果</span></span><br></pre></td></tr></table></figure>
<p>在无分支版本中，编译器能够去除分支并生成 cmovne 指令来替代。</p>
<blockquote>
<p>这里大家可能会有疑问：无分支汇编版本中的 <code>cmovne</code>（第 8 行）跟原始汇编版本中的 <code>test</code>（第 2 行）一样，都是要等到执行阶段完成后才能确定下一条指令的地址，那为什么无分支版本的效率会更高呢？</p>
<p>在当前示例中，<code>test</code> 后面还有很多依赖其结果的指令，它们都会阻塞起来等待其执行完成；而 <code>cmovne</code> 并没有阻塞后续指令，因此它的执行效率会更高。</p>
</blockquote>
<h2 id="消除分支的负面影响"><a class="markdownIt-Anchor" href="#消除分支的负面影响"></a> 消除分支的负面影响</h2>
<p>在上述无分支版本的示例中，x 和 y 都是独立计算的，然后只选择其中一个值。<span class="p red">虽然这种转换消除了分支错误预测的惩罚，但它会比原始代码做更多的工作。</span></p>
<p>在这种情况下，性能改进在很大程度上取决于 computeX() 和 computeY() 函数的特性。如果函数很小并且编译器能够内联它们，它可能会带来显著的性能优势；但 <span class="p red">如果函数很大，两个函数都去执行的开销就会比分支预测错误的开销更大。</span></p>
<p>此外，<span class="p red">消除分支还会限制 CPU 的并行执行能力。</span></p>
<p>对于原始版本中的代码片段，CPU 可以根据分支预测器选择 if 分支，并使用 <code>a = computeX()</code> 来推测执行。如果后续有指令要用 <code>a</code> 来索引数组元素，那么在知道 if 分支的真实结果之前就可以发出此加载（即直接使用分支预测所计算出的 <code>a</code> 的值。因为分支预测只需选择一个分支然后向下执行即可，而不需要计算出所有情况）。</p>
<p>而对于无分支版本中的代码，这种推测是不可能的，因为 CPU 无法在 <code>cmovne</code> 指令完成之前发出使用 <code>a</code> 的加载（无分支版本需要计算出所有情况，并且在最终执行完 <code>cmovne</code> 指令后才能确定 <code>a</code> 的值到底属于哪种情况）。</p>
<h2 id="何时选择无分支版本"><a class="markdownIt-Anchor" href="#何时选择无分支版本"></a> 何时选择无分支版本</h2>
<p>在代码的原始版本和无分支版本之间进行权衡的典型例子是 <strong>二分查找</strong>。</p>
<ul>
<li>
<p><span class="p red">对于不适合 CPU 缓存的大型数组的查找，基于分支的二分查找版本的性能更好。</span>因为与内存访问的延迟（cache 未命中会导致较高的延迟，无分支版本可能会有更多的 cache 不命中）相比，分支预测错误的代价较低。由于存在分支，CPU 可以推测它们的结果，从而同时加载当前迭代和下一次迭代中的数组元素。</p>
</li>
<li>
<p><span class="p red">对于适合 CPU 缓存的小型数组的查找，情况则正好相反。</span>由于数组适合 CPU 缓存，因此加载延迟很小（只有几个周期）。而基于分支的二分查找可能会遭受持续的错误预测（对于二分查找一旦预测错误，后续所有的预测一定都是错的），惩罚约为 20 个周期。在这种情况下，错误预测的代价远远大于内存访问的代价，从而大大削弱了推测执行的优势。在这种情况下，无分支版本通常会更快。</p>
</li>
</ul>
<p>二分查找是一个很好的例子，说明了如何在基础版本和无分支版本之间进行选择。但现实情况可能很难分析，因此，需要通过测试来确定在特定场景中替换分支是否有益。</p>
<h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2>
<ul>
<li>现代处理器非常擅长预测分支结果，因此 <strong>建议仅在错误预测率较高时再去修复分支错误预测的工作</strong>。</li>
<li>当 CPU 分支预测错误率较高时，应用程序的性能可能会受到影响。在这种情况下，算法的无分支版本可能会更好，因此可以考虑通过 <strong>查找表</strong> 和 <strong>谓词</strong> 来替换分支。</li>
<li><strong>无分支算法并非总是有益的</strong>，要通过测试来确定是否适合特定场景。</li>
</ul>
</br>
<div class="note info flat"><p><span class="p blue">以上内容主要参考自『Performance Analysis and Tuning on Modern CPUs』</span></p>
</div>]]></content>
      <categories>
        <category>读书笔记 - CSAPP</category>
      </categories>
      <tags>
        <tag>分支消除</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU流水线的各个阶段到底做了什么</title>
    <url>/posts/3931262747.html</url>
    <content><![CDATA[<p>我们在学习 CPU 处理机制的时候，为了便于理解，都会从 <strong>顺序执行</strong>（Sequential）的处理器开始介绍。对于顺序执行的 CPU，每个时钟周期都要处理一条完整的指令，这是一个漫长的过程，因此时钟频率会低到让人难以接受。为了提升 CPU 的性能，便引入了流水线技术。</p>
<p class='div-border blue left'>可即便使用了流水线，顺序执行的 CPU 的处理效率仍然无法满足我们的现实需要，因此现代处理器都是 <b>乱序执行</b>（Out-of-Order）的。</br>乱序执行即指令的执行并非按照程序中指令的原始顺序，而是后面的指令有可能会先于前面的指令执行。当然，为了保证程序的正确性，乱序执行必须保证与顺序执行相同的执行结果。</p>
<p>通常来说，处理一条指令包括很多操作，将它们组织成一个特殊的序列，就能设计出一个充分利用每个硬件的处理器。CPU 流水线最经典的划分方式包括：取指、译码、执行、访存、写回、更新 PC 寄存器。这些阶段的划分已是老生常谈，但每个阶段具体都做了什么，却跟我之前的理解有着严重的偏差。比如：</p>
<ul>
<li><span class="p red">取指阶段就只是单纯地从 PC 寄存器取出指令吗？</span></li>
<li><span class="p red">译码阶段是要对取出的机器指令进行翻译吗？</span></li>
<li><span class="p red">执行阶段好像是最简单的，就是执行程序逻辑中的主体运算，但真的就只有这一种情况吗？</span></li>
<li><span class="p red">访存就是访问 DRAM 内存吗？</span></li>
<li><span class="p red">写回是将修改后的值重新写回到内存吗？</span></li>
</ul>
<p>当然这些答案都是否定的，接下来我将通过各种类型的指令来详细介绍 CPU 流水线的各个阶段。</p>
<p>为了彻底搞清楚 CPU 对这些指令的处理过程，首先需要了解这些 <code>Y86-64</code> 指令的编码格式：</p>
<p><img src="https://img.gejiba.com/images/9cfcac8bb960fb57bda358842cf65826.webp" alt="Y86-64" /></p>
<p>可以看到指令编码长度从 1 字节到 10 字节不等。其中：</p>
<p>第 1 个字节表示操作码（icode : ifun），根据第 1 个字节就能知道指令的类型，进而知道有没有操作数，以及有几个操作数。图中 <code>fn</code> 用来表示该条指令是整数操作（OPq）、数据传送条件（cmovXX）或是分支条件（jXX）。</p>
<p>第 2 个字节表示操作数（rA : rB），对于那些只需要一个寄存器操作数的指令（irmovq、pushq 和 popq），将另一个寄存器指示符设置为十六进制数 <code>F</code>。</p>
<p>剩余 8 个字节表示立即数（irmovq 中的 <code>V</code>）、地址偏移量（rmmovq 与 mrmovq 中的 <code>D</code>）或是目标地址（jXX 与 call 中的 <code>Dest</code>）。</p>
<p>背景知识介绍差不多了，接下来我们就进入正题！</p>
<h2 id="opq-rrmovq-与-irmovq"><a class="markdownIt-Anchor" href="#opq-rrmovq-与-irmovq"></a> OPq、rrmovq 与 irmovq</h2>
<p><img src="https://img.gejiba.com/images/8f1a06dd51324402e831fdfa77d93088.webp" alt="OPq&amp;rrmovq&amp;irmovq" /></p>
<p>图中 <span class="p red">M<sub>n</sub>[X]</span> 表示访问内存位置 <code>X</code> 处的 <code>n</code> 个字节，下同。</p>
<p>可以看到，<strong>取指阶段</strong> 根据 PC 寄存器中所保存的地址从内存中取出指令，同时还解析出了指令的操作码和操作数，以及当前指令的长度，并且根据该长度计算出了下一条指令的地址 <code>valP</code>。</p>
<p><strong>译码阶段</strong> 从寄存器文件中读取最多两个操作数。而 irmovq 指令是将立即数读入到寄存器，不涉及对寄存器的读取，因此该指令在译码阶段不执行任何操作。</p>
<p><strong>执行阶段</strong> 由 ALU 执行指令指明的操作，当只有一个操作数时，将第二个操作数设为 0。这个过程可能需要设置条件码（<code>set CC</code>）。</p>
<p>由于这三类指令均未涉及到内存操作，因此在 <strong>访存阶段</strong> 不执行任何操作。</p>
<p><strong>写回阶段</strong> 将执行阶段得到的结果写回到目的寄存器，最后 <strong>更新 PC 寄存器</strong>。</p>
<h2 id="rmmovq-与-mrmovq"><a class="markdownIt-Anchor" href="#rmmovq-与-mrmovq"></a> rmmovq 与 mrmovq</h2>
<p><img src="https://img.gejiba.com/images/186a2f5d3d11a529447ab9046504c0dc.webp" alt="rmmovq&amp;mrmovq" /></p>
<p>这里的 <code>D</code> 表示地址偏移量，例如 <code>rmmovq %rsp,100(%rbx)</code>，表示将 %rsp 寄存器中的值放到内存中，内存地址是 %rbx 寄存器中的值加上 100。</p>
<p>这里的 <strong>执行阶段</strong> 计算的是内存地址。</p>
<p><strong>访存阶段</strong> 将值写入内存或者从内存中读出某个值。</p>
<p>由于 rmmovq 的不涉及到对目的寄存器的写，因此在 <strong>写回阶段</strong> 该指令不执行任何操作。</p>
<p>其余阶段中相同的操作这里不再赘述，下同。</p>
<h2 id="pushq-与-popq"><a class="markdownIt-Anchor" href="#pushq-与-popq"></a> pushq 与 popq</h2>
<p><img src="https://img.gejiba.com/images/0ed95a00e91e504ff8ee2a6b780504eb.webp" alt="pushq&amp;popq" /></p>
<p><strong>译码阶段</strong> 除了要读取指定寄存器中的操作数，还要读取栈顶指针的值。</p>
<p><strong>执行阶段</strong> 计算栈顶指针移动后的地址，该地址就是将要访问的内存地址。</p>
<p><strong>写回阶段</strong> 除了将结果写回目的寄存器外，还要更新栈顶指针的位置。</p>
<h2 id="jxx-call-与-ret"><a class="markdownIt-Anchor" href="#jxx-call-与-ret"></a> jXX、call 与 ret</h2>
<p><img src="https://img.gejiba.com/images/6f15acef0a82abde1779d52ca2104e86.webp" alt="jXX&amp;call&amp;ret" /></p>
<p>call 和 ret 指令类似于 pushq 和 popq。call 指令会将下一条指令的地址压入栈中（<strong>访存</strong>），然后将调用的目的地址 <code>valC</code> 作为下一条执行指令的地址（<strong>更新 PC</strong>）。ret 指令将从栈顶弹出的地址 <code>valM</code> 作为下一条执行指令的地址（<strong>更新 PC</strong>），并且由 call 可知，这条指令其实就是 call 指令后面紧跟的那条指令，表示在函数调用返回后继续往下执行。</p>
<p>jXX 指令在 <strong>执行阶段</strong> 会计算是否满足跳转条件。</p>
<p><strong>更新 PC 阶段</strong> 将根据分支条件设置下一条指令的地址。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>处理一条指令可以划分成以下几个阶段，这些阶段不一定都会执行，与具体的指令类型有关。</p>
<ul>
<li><strong>取指</strong>（Fetch）：从内存中读取指令，地址为 PC 寄存器的值。同时还会解析指令的操作码（指令类型）和操作数（寄存器指示符 rA/rB，可能还有常数），并计算出顺序执行时下一条指令的地址，该地址等于 PC 的值加上当前指令的长度。</li>
<li><strong>译码</strong>（Decode）：根据寄存器指示符从相应的寄存器文件中读入最多两个操作数，有时候需要读取 %rsp 寄存器所保存的地址。</li>
<li><strong>执行</strong>（Execute）：根据操作码类型，这个阶段可能执行的操作包括：执行指令指明的操作（可能还会设置条件码）；计算内存引用的有效地址；增加或减少栈指针；检验条件码和传送条件是否成立（条件传送指令 cmovXX）；决定是否选择分支（跳转指令）。</li>
<li><strong>访存</strong>（Memory）：从内存读取数据，或者将数据写入内存。</li>
<li><strong>写回</strong>（Write back）：最多可以将两个结果写到寄存器文件，包括写回指令中指定的目的寄存器，以及 %rsp 寄存器（更新栈顶指针的位置）。</li>
<li><strong>更新 PC</strong>（PC update）：将 PC 寄存器设置成下一条指令的地址。</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记 - CSAPP</category>
      </categories>
      <tags>
        <tag>CPU流水线</tag>
      </tags>
  </entry>
  <entry>
    <title>看懂简单的汇编代码</title>
    <url>/posts/3467593604.html</url>
    <content><![CDATA[<p>本文介绍的是 AT&amp;T 格式的汇编代码。先上表格：</p>
<img src="https://img.gejiba.com/images/2ec02466ed8dac1bfe60bab88be7fa76.webp" alt="整数寄存器" style="zoom:80%;" />
<p>表格记录了不同寄存器的功能。汇编指令通常都有一个或多个操作数，有的指令没有操作数，这些操作数有三种类型：立即数 <span class="p red">$<em>Imm</em></span>、寄存器 <span class="p red"><em>r<sub>a</sub></em></span> 和内存引用 <span class="p red">(<em>r<sub>a</sub></em>)</span>。</p>
<p>常见的操作指令有：</p>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">mov    S, D</td>
<td style="text-align:center">把数据从S传送到D</td>
</tr>
<tr>
<td style="text-align:center">push    S</td>
<td style="text-align:center">栈顶指针下移，S入栈</td>
</tr>
<tr>
<td style="text-align:center">pop    D</td>
<td style="text-align:center">栈顶内容赋值给D，栈顶指针上移</td>
</tr>
<tr>
<td style="text-align:center">lea    S, D</td>
<td style="text-align:center">将S的地址（&amp;S）赋值给D</td>
</tr>
<tr>
<td style="text-align:center">inc/dec/neg/not    D</td>
<td style="text-align:center">将D<code>加1/减1/取负/取反</code>后赋值给D</td>
</tr>
<tr>
<td style="text-align:center">add/sub/imul/xor/or/and    S, D</td>
<td style="text-align:center">将D<code>加/减/乘/异或/或/与</code>S后赋值给D</td>
</tr>
<tr>
<td style="text-align:center">sal/shl/sar/shr    k, D</td>
<td style="text-align:center">将D<code>算术/逻辑左移</code>/<code>算术/逻辑右移</code>k位后赋值给D</td>
</tr>
<tr>
<td style="text-align:center">leaq    S, D</td>
<td style="text-align:center">将S的地址赋值给D或者对S算术运算后赋值给D</td>
</tr>
<tr>
<td style="text-align:center">cmp/test    S1, S2</td>
<td style="text-align:center">根据<code>S2-S1或S2&amp;S1</code>的结果设置条件码</td>
</tr>
<tr>
<td style="text-align:center">cltq</td>
<td style="text-align:center">将 %eax 符号扩展到 %rax</td>
</tr>
<tr>
<td style="text-align:center">call/ret</td>
<td style="text-align:center">函数调用/函数返回</td>
</tr>
<tr>
<td style="text-align:center">enter/leave</td>
<td style="text-align:center">堆积/撤销一个栈</td>
</tr>
</tbody>
</table>
<p>接下来通过几个示例来进一步理解。</p>
<h2 id="mov-指令"><a class="markdownIt-Anchor" href="#mov-指令"></a> mov 指令</h2>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">exchange</span><span class="params">(<span class="type">long</span> *xp, <span class="type">long</span> y)</span> &#123;</span><br><span class="line">    <span class="type">long</span> x = *xp;</span><br><span class="line">    *xp = y;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一个参数 xp 保存在 %rdi 中，第二个参数 y 保存在 %rsi 中，返回值保存在 %rax 中</span></span><br><span class="line"><span class="comment"># *xp 是对 xp 的解引用，即读取内存中地址 xp 处所存放的值，因此表示为 (%rdi)</span></span><br><span class="line"><span class="attr">exchange:</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">(%rdi),</span> <span class="string">%rax</span>	<span class="comment"># 将 *xp 作为返回值</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">%rsi,</span> <span class="string">(%rdi)</span>	<span class="comment"># 将 y 赋值给 *xp</span></span><br><span class="line">	<span class="string">ret</span>			<span class="comment"># return</span></span><br></pre></td></tr></table></figure>
<h2 id="lea-指令"><a class="markdownIt-Anchor" href="#lea-指令"></a> lea 指令</h2>
<p>lea（load effective address）表示加载有效地址，虽然形式上是内存引用，但实际上并没有引用内存，而是将一个内存地址直接赋值给目的操作数；mov 则是将地址处的数据赋值给目的操作数。例如：</p>
<p><code>leaq 8(%rbx), %rax</code>  表示将 <code>%rbx+8</code> 这个地址直接赋值给 <code>%rax</code>，而不是把该地址处所对应的数据赋值给 <code>%rax</code>。mov 指令则恰恰相反：</p>
<p><code>movq 8(%rbx), %rax</code> 表示将 <code>%rbx+8</code> 这个地址处所对应的数据赋值给 <code>%rax</code>。</p>
<p>lea 的用法比较灵活，除了加载有效地址，还可以进行算术运算。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">scale</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span> &#123;</span><br><span class="line">    <span class="type">long</span> t = x + <span class="number">4</span> * y + <span class="number">12</span> * z;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># x in %rdi, y in %rsi, z in %rdx</span></span><br><span class="line"><span class="attr">scale:</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="string">(%rdi,</span> <span class="string">%rsi,</span> <span class="number">4</span><span class="string">),</span> <span class="string">%rax</span>	<span class="comment"># 将 x + 4y 放入 %rax</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="string">(%rdx,</span> <span class="string">%rdx,</span> <span class="number">2</span><span class="string">),</span> <span class="string">%rdx</span>	<span class="comment"># z = z + 2z = 3z</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="string">(%rax,</span> <span class="string">%rdx,</span> <span class="number">4</span><span class="string">),</span> <span class="string">%rax</span>	<span class="comment"># 将 (x + 4y) + 3z * 4 作为返回值</span></span><br><span class="line">	<span class="string">ret</span></span><br></pre></td></tr></table></figure>
<p>对于后两条 <code>leaq</code> 指令，之所以没有直接合并成 <code>leaq (%rax, %rdx, 12), %rax</code>，是因为对于变址寻址中的比例因子只能取 1、2、4、8，因此需要对 12 分解。</p>
<p>比例因子的取值与源代码中定义的数组类型相关，编译器会据此来确定比例因子的数值。比如对于 char 类型的数组，其比例因子是 1；short 类型的比例因子是 2；int 类型是 4；double 类型是 8 等等。</p>
<blockquote>
<p>判断 lea 是加载地址还是算术运算，可以根据所操作的寄存器的功能。如果是保存参数的普通寄存器一般表示算术运算，而其他特殊的寄存器则表示加载有效地址（个人观察，有待查证）。</p>
</blockquote>
<h2 id="算术指令"><a class="markdownIt-Anchor" href="#算术指令"></a> 算术指令</h2>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">arith</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span> &#123;</span><br><span class="line">    <span class="type">long</span> t1 = x ^ y;</span><br><span class="line">    <span class="type">long</span> t2 = z * <span class="number">48</span>;</span><br><span class="line">    <span class="type">long</span> t3 = t1 &amp; <span class="number">0x0F0F0F0F</span>;</span><br><span class="line">    <span class="type">long</span> t4 = t2 - t3;</span><br><span class="line">    <span class="keyword">return</span> t4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># x in %rdi, y in %rsi, z in %rdx</span></span><br><span class="line"><span class="attr">arith:</span></span><br><span class="line">	<span class="string">xorq</span>	<span class="string">%rsi,</span> <span class="string">%rdi</span>		<span class="comment"># x = x ^ y</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="string">(%rdx,</span> <span class="string">%rdx,</span> <span class="number">2</span><span class="string">),</span> <span class="string">%rax</span>	<span class="comment"># 将 z + 2z = 3z 放入 %rax</span></span><br><span class="line">	<span class="string">salq</span>	<span class="string">$4,</span> <span class="string">%rax</span>		<span class="comment"># 将 3z 左移 4 位，即 3z * 16 = 48z 作为返回值</span></span><br><span class="line">	<span class="string">andl</span>	<span class="string">$252645135,</span> <span class="string">%edi</span>	<span class="comment"># 该立即数有 8 * 4 = 32 位，因此只取前 32 位进行与运算</span></span><br><span class="line">	<span class="string">subq</span>	<span class="string">%rdi,</span> <span class="string">%rax</span>		<span class="comment"># 将 48z - t3 的值作为返回值</span></span><br><span class="line">	<span class="string">ret</span></span><br></pre></td></tr></table></figure>
<p>对于源程序第 3 行代码中的乘法操作，被编译成了 leaq 和左移两条指令。编译器之所以没有直接使用乘法指令来实现，是因为乘法指令的执行时间更长，因此编译器会优先选择更高效的方式。</p>
<h2 id="控制指令"><a class="markdownIt-Anchor" href="#控制指令"></a> 控制指令</h2>
<h3 id="条件码"><a class="markdownIt-Anchor" href="#条件码"></a> 条件码</h3>
<p>除了整数寄存器，CPU 还维护着一组单个比特位的条件码寄存器，可以通过检测这些寄存器来执行条件分支指令。常用的条件码：</p>
<table>
<thead>
<tr>
<th style="text-align:center">条件码</th>
<th style="text-align:center">全称</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CF</td>
<td style="text-align:center">Carry  Flag</td>
<td style="text-align:center">进位标志</td>
<td style="text-align:center">最高位产生了进位</td>
</tr>
<tr>
<td style="text-align:center">ZF</td>
<td style="text-align:center">Zero  Flag</td>
<td style="text-align:center">零标志位</td>
<td style="text-align:center">操作结果为零</td>
</tr>
<tr>
<td style="text-align:center">SF</td>
<td style="text-align:center">Sign  Flag</td>
<td style="text-align:center">符号标志</td>
<td style="text-align:center">操作结果为负</td>
</tr>
<tr>
<td style="text-align:center">OF</td>
<td style="text-align:center">Overflow  Flag</td>
<td style="text-align:center">溢出标志</td>
<td style="text-align:center">操作结果溢出</td>
</tr>
</tbody>
</table>
<p>算术和逻辑运算指令会改变条件码寄存器的内容（<code>leaq</code> 不会），还有两类指令专门用来设置条件码而不改变其它任何寄存器：<code>cmp</code> 和 <code>test</code>。</p>
<p><code>cmp S1, S2</code> 会根据 <code>S2 - S1</code> 的结果来设置条件码；</p>
<p><code>test S1, S2</code> 会根据 <code>S2 &amp; S1</code> 的结果来设置条件码。</p>
<p><code>test</code> 指令的典型用法是两个操作数相同，用来判断该操作数是正数，零，还是负数。对于这样的指令，如 <code>testq %rax,%rax</code>，它与 <code>cmpq $0, %rax</code> 是等价的。</p>
<p>接下来通过示例看一下对条件码的访问。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">comp</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a in %rdi, b in %rsi</span></span><br><span class="line"><span class="attr">comp:</span></span><br><span class="line">	<span class="string">cmpq</span>	<span class="string">%rsi,</span> <span class="string">%rdi</span>	<span class="comment"># 根据 a - b 的结果设置条件码寄存器</span></span><br><span class="line">	<span class="string">setl</span>	<span class="string">%al</span>		<span class="comment"># 如果 a &lt; b，将 al 寄存器设置为 1；否则设置为 0</span></span><br><span class="line">	<span class="string">movzbl</span>	<span class="string">%al,</span> <span class="string">%eax</span>	<span class="comment"># movz 表示零扩展，将 al 寄存器从 byte 扩展到 long word</span></span><br><span class="line">	<span class="string">ret</span></span><br></pre></td></tr></table></figure>
<h3 id="循环"><a class="markdownIt-Anchor" href="#循环"></a> 循环</h3>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fact_do</span><span class="params">(<span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        result *= n;</span><br><span class="line">        n = n - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span>(n &gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># n in %rdi</span></span><br><span class="line"><span class="attr">fact_do:</span></span><br><span class="line">	<span class="string">movl</span>	<span class="string">$1,</span> <span class="string">%eax</span>	<span class="comment"># 将 1 放入 %eax</span></span><br><span class="line"><span class="string">.L2:</span></span><br><span class="line">	<span class="string">imulq</span>	<span class="string">%rdi,</span> <span class="string">%rax</span>	<span class="comment"># 将 %rax 中的值更新为自身乘以 n</span></span><br><span class="line">	<span class="string">subq</span>	<span class="string">$1,</span> <span class="string">%rdi</span>	<span class="comment"># n = n - 1</span></span><br><span class="line">	<span class="string">cmpq</span>	<span class="string">$1,</span> <span class="string">%rdi</span>	<span class="comment"># 根据 n - 1 的结果设置条件码寄存器</span></span><br><span class="line">	<span class="string">jg</span>		<span class="string">.L2</span>	<span class="comment"># 如果 n &gt; 1 则跳转到 .L2 处执行</span></span><br><span class="line">	<span class="string">rep;</span> <span class="string">ret</span>		<span class="comment"># rep 是空操作，可以直接无视它</span></span><br></pre></td></tr></table></figure>
<p><code>imul</code> 表示有符号整数乘法，<code>mul</code> 则表示无符号整数乘法。</p>
<h2 id="push-与-pop-指令"><a class="markdownIt-Anchor" href="#push-与-pop-指令"></a> push 与 pop 指令</h2>
<p><code>pushq S</code>，等价于以下两条操作指令：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">subq</span>	<span class="string">$8,</span> <span class="string">%rsp</span></span><br><span class="line"><span class="string">movq</span>	<span class="string">S,</span> <span class="string">(%rsp)</span></span><br></pre></td></tr></table></figure>
<p>因此两次 push 之后 %rsp 依然指向栈顶。</p>
<p>相应地，<code>popq D</code> 也等价于两条指令：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">movq</span>	<span class="string">(%rsp),</span> <span class="string">D</span></span><br><span class="line"><span class="string">addq</span>	<span class="string">$8,</span> <span class="string">%rsp</span></span><br></pre></td></tr></table></figure>
<p>如图所示：</p>
<img src="https://img.gejiba.com/images/944e92c68fc061803e0017ae75b7e13e.webp" alt="pushpop" style="zoom:80%;" />
<h2 id="call-与-ret-指令"><a class="markdownIt-Anchor" href="#call-与-ret-指令"></a> call 与 ret 指令</h2>
<p><code>call</code> 和 <code>ret</code> 指令类似于 <code>pushq</code> 和 <code>popq</code>。</p>
<p><code>call</code> 指令会将下一条指令的地址压入栈中，然后将调用的目的地址 <code>D</code> 作为下一条执行指令的地址。</p>
<p><code>ret</code> 指令将从栈顶弹出的地址作为下一条执行的指令的地址。由 <code>call</code> 可知，这条指令其实就是 <code>call</code> 指令后面紧跟的那条指令，表示在函数调用返回后继续往下执行。</p>
<p>如图所示：</p>
<p><img src="https://img.gejiba.com/images/e3492a3a945ffa8638842c82d99b6f9e.webp" alt="callret" /></p>
<h2 id="enter-与-leave-指令"><a class="markdownIt-Anchor" href="#enter-与-leave-指令"></a> enter 与 leave 指令</h2>
<p><code>enter</code> 指令在原有的栈上堆积了一个栈，等价于以下两条操作指令：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">pushq</span>	<span class="string">%rbp</span></span><br><span class="line"><span class="string">movq</span>	<span class="string">%rsp,</span> <span class="string">%rbp</span></span><br></pre></td></tr></table></figure>
<p><code>leave</code> 指令则是撤销这个新堆积的栈，等价于以下两条指令：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">movq</span>	<span class="string">%rbp,</span> <span class="string">%rsp</span></span><br><span class="line"><span class="string">popq</span>	<span class="string">%rbp</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img.gejiba.com/images/1a55414f1ab12c87dd1345e47778e8e3.webp" alt="enter&amp;leave" /></p>
<h2 id="函数调用"><a class="markdownIt-Anchor" href="#函数调用"></a> 函数调用</h2>
<h3 id="函数栈帧"><a class="markdownIt-Anchor" href="#函数栈帧"></a> 函数栈帧</h3>
<p>当函数需要的存储空间超出寄存器所能存放的大小时，就会在栈上分配空间，这块存储空间称为该函数的 <strong>栈帧</strong>。例如，在本文最开始给出的表格中可以发现，对于前 6 个参数，每一个都有相对应的寄存器进行保存，而从第 7 个参数开始，则被保存到了栈里面。另外，还有两种常见的情况需要为函数分配栈帧，一种是对一个局部变量使用取地址符，因此必须能为它产生一个地址；另一种是当局部变量是数组或结构体。</p>
<p>当函数 P 调用函数 Q 时，其栈帧结构如下：</p>
<img src="https://img.gejiba.com/images/e89ffa3aefa3462d8eb41ee9777ead4c.webp" alt="P调用Q的栈帧结构" style="zoom:16%;" />
<p>当前正在执行的函数的栈帧总是保存在栈顶，当 P 调用 Q 时，call 指令会把返回地址压入栈中，该地址指明了当 Q 返回时，要从 P 的哪个位置继续执行。下面看一个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">proc</span><span class="params">(<span class="type">long</span>  a1, <span class="type">long</span>  *a1p,</span></span><br><span class="line"><span class="params">          <span class="type">int</span>   a2, <span class="type">int</span>   *a2p,</span></span><br><span class="line"><span class="params">          <span class="type">short</span> a3, <span class="type">short</span> *a3p,</span></span><br><span class="line"><span class="params">          <span class="type">char</span>  a4, <span class="type">char</span>  *a4p)</span> &#123;</span><br><span class="line">    *a1p += a1;</span><br><span class="line">    *a2p += a2;</span><br><span class="line">    *a3p += a3;</span><br><span class="line">    *a4p += a4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">call_proc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span>  x1 = <span class="number">1</span>; <span class="type">int</span>  x2 = <span class="number">2</span>;</span><br><span class="line">    <span class="type">short</span> x3 = <span class="number">3</span>; <span class="type">char</span> x4 = <span class="number">4</span>;</span><br><span class="line">    proc(x1, &amp;x1, x2, &amp;x2, x3, &amp;x3, x4, &amp;x4);</span><br><span class="line">    <span class="keyword">return</span> (x1 + x2) * (x3 - x4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>proc 的汇编代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a1 in %rdi, a1p in %rsi</span></span><br><span class="line"><span class="comment"># a2 in %edx, a2p in %rcx</span></span><br><span class="line"><span class="comment"># a3 in %r8w, a3p in %r9</span></span><br><span class="line"><span class="comment"># %rsp 指向栈顶</span></span><br><span class="line"><span class="comment"># a4 in %rsp+8, a4p in %rsp+16</span></span><br><span class="line"><span class="attr">proc:</span></span><br><span class="line">	<span class="string">movq</span>	<span class="number">16</span><span class="string">(%rsp),</span> <span class="string">%rax</span>	<span class="comment"># 将 a4p 放入 %rax</span></span><br><span class="line">	<span class="string">addq</span>	<span class="string">%rdi,</span> <span class="string">(%rsi)</span>	<span class="comment"># *a1p += a1</span></span><br><span class="line">	<span class="string">addl</span>	<span class="string">%edx,</span> <span class="string">(%rcx)</span>	<span class="comment"># *a2p += a2</span></span><br><span class="line">	<span class="string">addw</span>	<span class="string">%r8w,</span> <span class="string">(%r9)</span>	<span class="comment"># *a3p += a3</span></span><br><span class="line">	<span class="string">movl</span>	<span class="number">8</span><span class="string">(%rsp),</span> <span class="string">%edx</span>	<span class="comment"># 将 a4 放入 %edx</span></span><br><span class="line">	<span class="string">addb</span>	<span class="string">%dl,</span> <span class="string">(%rax)</span>	<span class="comment"># *a4p += a4</span></span><br><span class="line">	<span class="string">ret</span></span><br></pre></td></tr></table></figure>
<p>有几点需要注意：</p>
<ul>
<li>虽然从第 7 个参数开始都被保存到了栈中，但是当指令需要对这些参数操作时，仍然需要先从栈读入到寄存器中。</li>
<li>通过栈传递参数时，所有数据都需要 8 字节对齐，所以 a4 即便只有 1 个字节，仍然为其分配了 8 个字节的存储空间。<span class="p red">注意：只有借助栈传递参数时才需要 8 字节对齐，如果只是在栈中存放局部变量，比如使用了取地址运算符的局部变量（必须存放在栈中），它们是不需要对齐的。</span></li>
<li>a4 是从 %rsp+8 的位置开始存放的，而不是 %rsp 指向的位置，说明返回地址占据了栈顶位置。函数 proc 的栈帧如图所示：</li>
</ul>
<img src="https://img.gejiba.com/images/3dc0f287b4a191a0053e3de978a4726a.webp" alt="proc 的栈帧" style="zoom:45%;" />
<p>call_proc 的汇编代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">call_proc:</span></span><br><span class="line">	<span class="string">subq</span>	<span class="string">$32,</span> <span class="string">%rsp</span>	<span class="comment"># %rsp - 32，分配 32 字节大小的栈帧</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">$1,</span> <span class="number">24</span><span class="string">(%rsp)</span>	<span class="comment"># 将立即数 1 放到栈帧 %rsp + 24 处</span></span><br><span class="line">	<span class="string">movl</span>	<span class="string">$2,</span> <span class="number">20</span><span class="string">(%rsp)</span>	<span class="comment"># 将立即数 2 放到栈帧 %rsp + 20 处</span></span><br><span class="line">	<span class="string">movw</span>	<span class="string">$3,</span> <span class="number">18</span><span class="string">(%rsp)</span>	<span class="comment"># 将立即数 3 放到栈帧 %rsp + 18 处</span></span><br><span class="line">	<span class="string">movb</span>	<span class="string">$4,</span> <span class="number">17</span><span class="string">(%rsp)</span>	<span class="comment"># 将立即数 4 放到栈帧 %rsp + 17 处</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="number">17</span><span class="string">(%rsp),</span> <span class="string">%rax</span>	<span class="comment"># 将 &amp;x4 放入 %rax</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">%rax,</span> <span class="number">8</span><span class="string">(%rsp)</span>	<span class="comment"># 将 &amp;x4 放到栈帧 %rsp + 8 处作为第 8 个参数</span></span><br><span class="line">	<span class="string">movl</span>	<span class="string">$4,</span> <span class="string">(%rsp)</span>	<span class="comment"># 将立即数 4 放到栈帧 %rsp 处作为第 7 个参数</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="number">18</span><span class="string">(%rsp),</span> <span class="string">%r9</span>	<span class="comment"># 将 &amp;x3 作为第 6 个参数</span></span><br><span class="line">	<span class="string">movl</span>	<span class="string">$3,</span> <span class="string">%r8d</span>	<span class="comment"># 将立即数 3 作为第 5 个参数</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="number">20</span><span class="string">(%rsp),</span> <span class="string">%rcx</span>	<span class="comment"># 将 &amp;x2 作为第 4 个参数</span></span><br><span class="line">	<span class="string">movl</span>	<span class="string">$2,</span> <span class="string">%edx</span>	<span class="comment"># 将立即数 2 作为第 3 个参数</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="number">24</span><span class="string">(%rsp),</span> <span class="string">%rsi</span>	<span class="comment"># 将 &amp;x1 作为第 2 个参数</span></span><br><span class="line">	<span class="string">movl</span>	<span class="string">$1,</span> <span class="string">%edi</span>	<span class="comment"># 将立即数 1 作为第 1 个参数</span></span><br><span class="line">	<span class="comment"># 调用函数 proc</span></span><br><span class="line">	<span class="string">call</span>	<span class="string">proc</span></span><br><span class="line">	<span class="string">movslq</span>	<span class="number">20</span><span class="string">(%rsp),</span> <span class="string">%rdx</span>	<span class="comment"># 将 x2 符号扩展为四字放入 %rdx</span></span><br><span class="line">	<span class="string">addq</span>	<span class="number">24</span><span class="string">(%rsp),</span> <span class="string">%rdx</span>	<span class="comment"># 将 x2 + x1 放入 %rdx</span></span><br><span class="line">	<span class="string">movswl</span>	<span class="number">18</span><span class="string">(%rsp),</span> <span class="string">%eax</span>	<span class="comment"># 将 x3 符号扩展为双字放入 %eax</span></span><br><span class="line">	<span class="string">movsbl</span>	<span class="number">17</span><span class="string">(%rsp),</span> <span class="string">%ecx</span>	<span class="comment"># 将 x4 符号扩展为双字放入 %ecx</span></span><br><span class="line">	<span class="string">subl</span>	<span class="string">%ecx,</span> <span class="string">%eax</span>	<span class="comment"># 将 x3 - x4 放入 %eax</span></span><br><span class="line">	<span class="string">cltq</span>			<span class="comment"># 将 %eax 符号扩展到 %rax</span></span><br><span class="line">	<span class="string">imulq</span>	<span class="string">%rdx,</span> <span class="string">%rax</span>	<span class="comment"># 将 (x3 - x4) * (x2 + x1) 作为返回值</span></span><br><span class="line">	<span class="string">addq</span>	<span class="string">$32,</span> <span class="string">%rsp</span>	<span class="comment"># %rsp + 32，释放 32 字节大小的栈帧</span></span><br><span class="line">	<span class="string">ret</span></span><br></pre></td></tr></table></figure>
<p>函数 call_proc 的栈帧如图所示：</p>
<img src="https://img.gejiba.com/images/64c8434dd3f2a16518fbd172400264e8.webp" alt="call_proc 的栈帧" style="zoom:45%;" />
<h3 id="被调用者保存寄存器"><a class="markdownIt-Anchor" href="#被调用者保存寄存器"></a> [被]调用者保存寄存器</h3>
<p>在程序执行的过程中，寄存器是被所有函数共享的，因此为了确保在使用过程中寄存器内的数据不被覆盖，处理器采用了一组统一的寄存器使用惯例，所有函数都必须遵守。</p>
<p>根据惯例，对于 16 个通用寄存器，除了 %rsp 之外，其余 15 个寄存器被划分为调用者保存和被调用者保存。其中，%rbx、%rbp、%r12~%r15 被划分为 <strong>被调用者保存寄存器</strong>，剩余的被划分为 <strong>调用者保存寄存器</strong>。下面以一个例子说明其使用方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">P</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span> &#123;</span><br><span class="line">    <span class="type">long</span> u = Q(y);</span><br><span class="line">    <span class="type">long</span> v = Q(x);</span><br><span class="line">    <span class="keyword">return</span> u + v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># x in %rdi, y in %rsi</span></span><br><span class="line"><span class="attr">P:</span></span><br><span class="line">	<span class="string">pushq</span>	<span class="string">%rbp</span>		<span class="comment"># 保存 %rbp 中的值</span></span><br><span class="line">	<span class="string">pushq</span>	<span class="string">%rbx</span>		<span class="comment"># 保存 %rbx 中的值</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">%rdi,</span> <span class="string">%rbp</span>	<span class="comment"># 将 %rdi 中的值 x 保存到 %rbp 中</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">%rsi,</span> <span class="string">%rdi</span>	<span class="comment"># 将 y 放入 %rdi 作为第一个参数</span></span><br><span class="line">	<span class="string">call</span>	<span class="string">Q</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">%rax,</span> <span class="string">%rbx</span>	<span class="comment"># 将 Q 的返回结果 u 保存到 %rbx 中</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">%rbp,</span> <span class="string">%rdi</span>	<span class="comment"># 将 x 放入 %rdi 作为第一个参数</span></span><br><span class="line">	<span class="string">call</span>	<span class="string">Q</span></span><br><span class="line">	<span class="string">addq</span>	<span class="string">%rbx,</span> <span class="string">%rax</span>	<span class="comment"># 将 v + u 作为返回值</span></span><br><span class="line">	<span class="string">addq</span>	<span class="string">$8,</span> <span class="string">%rsp</span>	<span class="comment"># 释放 8 个字节的栈帧</span></span><br><span class="line">	<span class="string">popq</span>	<span class="string">%rbx</span>		<span class="comment"># 恢复 %rbx 中的值</span></span><br><span class="line">	<span class="string">popq</span>	<span class="string">%rbp</span>		<span class="comment"># 恢复 %rbp 中的值</span></span><br><span class="line">	<span class="string">ret</span></span><br></pre></td></tr></table></figure>
<p>在函数 P 中，x 保存在 %rdi 中，当在第 7 行调用函数 Q 时，由于 Q 有一个参数，因此也会使用 %rdi。为了防止 P 中的 %rdi 值被覆盖，需要先将其保存到一个其他无关的寄存器 %rbp 中（第 6 行），而为了防止原本 %rbp 中的内容被覆盖，在此之前还需将其中的内容压入栈中保存起来（第 3 行）。</p>
<p>同样的道理，当第一次调用 Q 结束时，结果会被保存在 %rax 中返回；而当第二次调用函数 Q 时，其返回结果仍然会保存在 %rax 中。为了防止第一次返回的结果被覆盖，需要先将其保存到一个其他无关的寄存器 %rbx 中（第 8 行），而为了防止原本 %rbx 中的内容被覆盖，在此之前还需将其中的内容压入栈中保存起来（第 4 行）。</p>
<p>在函数 P 结束之前，按照栈后进先出的顺序出栈，依次恢复 %rbx 和 %rbp 中的内容。</p>
<h3 id="函数递归调用"><a class="markdownIt-Anchor" href="#函数递归调用"></a> 函数递归调用</h3>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">rfact</span><span class="params">(<span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)</span><br><span class="line">        result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        result = n * rfact(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># n in %rdi</span></span><br><span class="line"><span class="attr">rfact:</span></span><br><span class="line">	<span class="string">pushq</span>	<span class="string">%rbx</span>			<span class="comment"># 保存 %rbx 中的值</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">%rdi,</span> <span class="string">%rbx</span>		<span class="comment"># 将 n 放入 %rbx</span></span><br><span class="line">	<span class="string">movl</span>	<span class="string">$1,</span> <span class="string">%eax</span>		<span class="comment"># 将 1 放入 %rax</span></span><br><span class="line">	<span class="string">cmpq</span>	<span class="string">$1,</span> <span class="string">%rdi</span>		<span class="comment"># 根据 n - 1 的值设置条件码寄存器</span></span><br><span class="line">	<span class="string">jle</span>	<span class="string">.L35</span>			<span class="comment"># 如果 n &lt;= 1，跳转到 .L35</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="number">-1</span><span class="string">(%rdi),</span> <span class="string">%rdi</span>		<span class="comment"># 将 n = n - 1 作为第一个参数</span></span><br><span class="line">	<span class="string">call</span>	<span class="string">rfact</span>			<span class="comment"># 调用函数 rfact</span></span><br><span class="line">	<span class="string">imulq</span>	<span class="string">%rbx,</span> <span class="string">%rax</span>		<span class="comment"># 将 rfact(n - 1) * n 的值放入 %rax</span></span><br><span class="line"><span class="string">.L35:</span></span><br><span class="line">	<span class="string">popq</span>	<span class="string">%rbx</span>			<span class="comment"># 恢复 %rbx 中的值</span></span><br><span class="line">	<span class="string">ret</span></span><br></pre></td></tr></table></figure>
<h2 id="数组和指针"><a class="markdownIt-Anchor" href="#数组和指针"></a> 数组和指针</h2>
<p>数组在内存中是连续存放的，每个元素所占内存的大小由数组类型决定，如图所示：</p>
<img src="https://img.gejiba.com/images/e3d43bd460b0c20d24ce0fd3018b4f7b.webp" alt="array" style="zoom:62%;" />
<p>对指针进行运算时，计算结果会根据指针类型进行相应的伸缩。为方便理解，将内存抽象成一个很大的数组，假设初始时指针 p 和 q 都指向 0x100 处，现分别对两个指针进行加 1 操作，由于指针类型不同，指针 p + 1 会前进 1 个字节，而指针 q + 1 会前进 4 个字节，如图所示：</p>
<img src="https://img.gejiba.com/images/fb5a7e558f74a7c9c29816a82405f68a.webp" alt="padd" style="zoom:70%;" />
<p>而数组名正是指向该数组首元素的指针，因此对于数组 <code>int arr[5]</code> 中的每一个元素，均有两种表示方式，如图所示：</p>
<img src="https://img.gejiba.com/images/38e1cc7b41ea67d443c837bebf6bbe95.webp" alt="parr" style="zoom:75%;" />
<p>对于二维数组，在内存中是按照行优先的顺序存储的：</p>
<img src="https://img.gejiba.com/images/af9f4f55dd7d45b4c94e582e69595f8c.webp" alt="2D-array" style="zoom:70%;" />
<h2 id="结构体和联合体"><a class="markdownIt-Anchor" href="#结构体和联合体"></a> 结构体和联合体</h2>
<p>CPU 是按 32/64 位的大小进行存取的，为了提高 CPU 的执行效率，计算机系统对基本数据类型的合法地址做了一些限制，要求某种类型的地址必须是某个值（2 / 4 / 8）的倍数，这就是 <strong>数据对齐</strong>。数据对齐会由编译器自动实现，但了解其实现方法还是很有必要的，可以优化代码结构，达到节省空间和提高效率（减少访存次数）的目的。</p>
<p>数据对齐的基本原则是：<span class="p red">任何 K 字节的基本对象的地址必须是 K 的倍数</span>。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>  i;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span>  j;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果不进行数据对齐（以 64 位机器为例），结构体 S1 在内存中的分布如图 (a) 所示。</p>
<p>虽然整体只占了 9 个字节，但要访问成员 j，需要访问两次内存才行，这样效率并不高。而如果进行了数据对齐，则访问所有成员都只需访问一次内存即可，如图 (b)。其中在 c 后面插入 3 个字节，是因为 j 占 4 个字节，所以它的起始地址必须是 4 的倍数。</p>
<p>另外，在结构体的末尾，可能也需要一些填充。比如假设结构体 S1 中没有成员 j，那所有元素都是满足对齐要求的，但是当该结构体声明为数组时（比如 <code>struct S1 arr[2]</code>），对齐原则就无法保证了，因此需要在末尾进行填充以满足结构体数组的对齐原则，如图 (c)。</p>
<img src="https://img.gejiba.com/images/56afaf0f2107e96c0d3562725c18e2be.webp" alt="align" style="zoom:50%;" />
<p>与结构体不同，联合体中的所有字段共享同一存储区域，因此联合体的大小取决于其最大字段的大小。如果我们事先知道两个不同字段的使用是互斥的，那么就可以将这两个字段声明为一个联合体，从而达到节省内存空间的目的。</p>
<p>此外，联合体还可以用来访问不同数据类型的位模式，比如判断机器的大小端：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">    &#125; temp;</span><br><span class="line">    temp.i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(temp.c == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Little Endian\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Big Endian\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 i 占 4 个字节，c 占 1 个字节，二者共享同一段内存，因此只需为 temp 分配 4 字节的空间。当为联合体中的 i 赋值后（第 6 行），为 temp 分配的四个字节都填满了，此时访问其中的 c 成员，其实就是访问这段内存的第 1 个字节，即低地址处的第 1 个字节。</p>
<p>对于 4 字节的整型 1，其十六进制表示为 <code>0x0000 0001</code>。若机器是小端，则低位放低地址处，高位放高地址处，地址从低到高依次为 <code>0x01 0x00 0x00 0x00</code>；若机器是大端，则低位放高地址处，高位放低地址处，地址从低到高依次为 <code>0x00 0x00 0x00 0x01</code>。</p>
<p>此时只需判断 c 的值是 <code>0x01</code> 还是 <code>0x00</code>，即可判断机器是小端还是大端。</p>
<p>再比如，可以用如下方法来获取 double 类型的二进制位表示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">double2bits</span><span class="params">(<span class="type">double</span> d)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> u;</span><br><span class="line">    &#125; temp; <span class="comment">// 以一种类型存储，以另一种类型访问</span></span><br><span class="line">    temp.d = d;</span><br><span class="line">    <span class="keyword">return</span> temp.u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>double</code> 与 <code>unsigned long</code> 所占的字节相同，因此当为 d 赋值后，d 和 u 就共同拥有了相同大小的内存空间，此时对 u 的访问即是 d 的二进制位的十进制表示。</p>
]]></content>
      <categories>
        <category>读书笔记 - CSAPP</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>栈帧</tag>
        <tag>数据对齐</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机系统漫游</title>
    <url>/posts/4223884717.html</url>
    <content><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>《深入理解计算机系统-CSAPP》是计算机领域的圣经✨之前翻看过两三次，不过由于平时在实验室一直都有各种事情牵扯时间跟精力，每次阅读都近乎走马观花。</p>
<p>最近论文送审之后终于有了充足的时间，于是便静下心来重新读了一遍。对于其中一些晦涩难懂且意义不大（个人愚见）的知识点（如浮点数的表示和运算、存储器山等等）本人并未细究，这里仅对自己之前没有完全掌握，或者易忘易混淆的知识点做个记录📝方便日后查阅。</p>
<p>在整理了部分内容之后我发现整体架构看起来依然有些零散，没有逻辑主线💥事实上我也确实是从 <code>hello.c</code> 程序编译的各个过程中发散出来的小的知识点。</p>
<p>为了使介绍能够更加聚焦，后续内容我决定采用问答的形式，然后从回答中抽取关键字来“浅挖”其原理和细节。能力一般，水平有限，所有内容仅仅是个人的一些粗浅的理解，之后我会尽量多读相关书籍来修正和完善这些内容🚩</p>
<p>『计算机系统漫游』部分主要是对全书中我比较感兴趣的部分做一个粗略的介绍，其中每个 <span class="inline-tag blue">蓝色小标签</span> 中的内容（包括但不限于此）都将是后续博客中进一步展开介绍的对象~~</p>
<h2 id="从hello-world开始"><a class="markdownIt-Anchor" href="#从hello-world开始"></a> 从Hello World开始</h2>
<p><img src="https://img.gejiba.com/images/2df68f1e0cc0ea3c4bd7722f0b09e509.webp" alt="Hello World编译过程" /></p>
<h2 id="文本文件与二进制文件"><a class="markdownIt-Anchor" href="#文本文件与二进制文件"></a> 文本文件与二进制文件</h2>
<p>我们所编写的 <code>hello.c</code> 程序属于文本文件，经过编译后生成的可执行文件是二进制文件。它们最终在物理内存上都是以二进制形式保存的，因此二者的主要区别是逻辑上的而不是物理上的：</p>
<ul>
<li>
<p>文本文件：基于字符编码，如ASCII、Unicode等，每个值都有固定的Size。</p>
</li>
<li>
<p>二进制文件：基于值编码，没有固定的Size，实际上就是把值在物理内存上的原始二进制形式。</p>
</li>
</ul>
<p>比如 <code>\n</code> 在文本文件中是换行符，而在二进制文件中会被认为是 <code>\</code> 和 <code>n</code> 两个字符。</p>
<h2 id="原码-反码和补码"><a class="markdownIt-Anchor" href="#原码-反码和补码"></a> 原码、反码和补码</h2>
<p>有符号数的表示方法有三种，分别是原码、反码和补码，它们都是用最高位的 <code>0</code> 和 <code>1</code> 来区分正负。对于正数，三者的表示都是一致的，即该数的二进制表示，主要区别是在负数上。例如 <code>15</code> 的二进制表示为 <code>0000 1111</code>，而对于 <code>-15</code>：</p>
<ul>
<li>原码：<code>1000 1111</code> 符号位 + 二进制表示</li>
<li>反码：<code>1111 0000</code> 在原码基础上，除符号位外全部取反</li>
<li>补码：<code>1111 0001</code> 反码 + 1</li>
</ul>
<p>在计算机中，有符号数是用补码来表示的。之所以不用另外两种编码方式，是因为对于数字 <code>0</code>，二者都有两种不同的编码方式，分别是 <code>+0</code> 和 <code>-0</code>，而补码则不存在这种问题。</p>
<h2 id="汇编程序与机器指令"><a class="markdownIt-Anchor" href="#汇编程序与机器指令"></a> 汇编程序与机器指令</h2>
<p>高级语言编写的程序可以在很多不同的机器上编译运行，生成该机器所支持的 <span class="inline-tag blue">机器指令</span>。 <span class="inline-tag blue">汇编程序</span> 是机器指令的文本表示，在不同指令级架构的机器上有不同的表现形式，这也就解释了为什么最终生成的可执行目标文件一般都不能跨平台执行。</p>
<p>Java之所以能够跨平台（一次编译多次运行），是因为它并不是直接运行在CPU上的，而是生成字节码（.class）文件后由 JVM 统一执行。此时JVM有两种选择：一种是使用 Java 解释器解释执行，另一种是使用 JIT 编译器将字节码转化为本地机器指令。</p>
<p>二者的区别在于，前者启动速度快但运行速度慢，后者启动速度慢但运行速度快。这是因为解释器不需要像 JIT 编译器一样，将所有字节码都转化为机器指令，自然就省去了优化的时间。而当 JIT 编译器完成第一次编译后会将字节码对应的机器指令保存下来，下次可以直接使用。由于机器指令的执行效率要高于 Java 解释器，所以在实际情况中，为了速度和效率，通常采用两者相结合的方式。</p>
<h2 id="可重定位文件与可执行文件"><a class="markdownIt-Anchor" href="#可重定位文件与可执行文件"></a> 可重定位文件与可执行文件</h2>
<p>如果想让代码运行，那么生成的目标代码中的每个符号（函数或变量）的地址都应该是确定的。事实上，在汇编阶段，只有跟源代码在同一个模块中的符号地址能确定下来，而定义在其他模块中的全局变量和函数的地址要在链接的时候才能确定。编译器在没法确定地址的情况下，会先将其置为 0，等到链接的时候再去修正它们，这个过程就是<span class="inline-tag blue">重定位</span>。因此很自然地，在链接之前（汇编阶段）生成的目标文件叫做可重定位目标文件，在链接之后生成的目标文件叫做 <span class="inline-tag blue">可执行目标文件</span>。</p>
<h2 id="静态链接与动态链接"><a class="markdownIt-Anchor" href="#静态链接与动态链接"></a> 静态链接与动态链接</h2>
<p>链接分为 <span class="inline-tag blue">静态链接</span> 和 <span class="inline-tag blue">动态链接</span>，二者的区别在于：静态链接会把引用到的所有目标文件全部嵌入到可执行文件中，因此生成的是完全可执行的目标文件；动态链接只会链接所引用文件的重定位和符号表信息，因此生成的是部分链接的可执行目标文件，直到运行或加载的时候，才会由动态链接器将物理内存中的共享库的地址与其链接起来。</p>
<h2 id="cpu流水线划分"><a class="markdownIt-Anchor" href="#cpu流水线划分"></a> CPU流水线划分</h2>
<p>CPU流水线最经典的划分方式包括：取指、译码、执行、访存、写回、更新PC寄存器。这些阶段看似简单，但有很多细节与我之前的理解存在严重偏差。比如取指阶段就只是单纯地从PC寄存器取出指令吗？译码阶段是要对取出的机器指令进行翻译吗？执行阶段好像是最简单的，就是执行我们程序逻辑中的主体运算，但就只有这一种情况吗？访存就是访问DRAM内存吗？写回是将修改后的值重新写回到内存吗？当然这些答案都是否定的，后续我会详细介绍 <span class="inline-tag blue">CPU流水线</span> 的这几个阶段。</p>
<h2 id="高速缓存存储器"><a class="markdownIt-Anchor" href="#高速缓存存储器"></a> 高速缓存存储器</h2>
<p><span class="inline-tag blue">高速缓存</span> 的结构可以用<code>(S, E, B, m)</code>来表示，每个缓存行中还保存了有效位和标记位，方便快速定位目标数据，那具体工作过程是怎样的呢？另外根据<code>E</code>的不同，可以分为直接映射、组相连和全相连的高速缓存，这样划分的目的是什么？各有都有哪些优缺点？每种方式都有自己的应用场景吗？</p>
<h2 id="物理内存和虚拟内存"><a class="markdownIt-Anchor" href="#物理内存和虚拟内存"></a> 物理内存和虚拟内存</h2>
<p><span class="inline-tag blue">虚拟内存</span> 并不是虚拟的、非真实存在的内存，而是对磁盘的虚拟化，将内存视为磁盘的高速缓存，在内存空间不足时将磁盘的一块区域划分成虚拟内存，通过与物理内存的换入换出来满足程序运行的需求。有虚拟内存自然就有 <span class="inline-tag blue">虚拟地址</span>，相应地也会有物理地址，它们之间是如何完成映射的？进程的虚拟地址空间是真实存在的吗？是保存在物理内存中的吗？程序请求分配到的内存是物理内存吗？<span class="inline-tag blue">内存分配</span> 后忘记释放内存会怎么样？Java不需要手动释放内存，那它的 <span class="inline-tag blue">垃圾回收</span> 机制是怎么实现的？这些问题我都会在后续博客中一一解答。</p>
]]></content>
      <categories>
        <category>读书笔记 - CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>This is a test blog</title>
    <url>/posts/1243066710.html</url>
    <content><![CDATA[<h1 id="一级标题"><a class="markdownIt-Anchor" href="#一级标题"></a> 一级标题</h1>
<p>Welcome to <a href="https://hexo.io/">Hexo</a>!</p>
<h2 id="二级标题"><a class="markdownIt-Anchor" href="#二级标题"></a> 二级标题</h2>
<h3 id="三级标题"><a class="markdownIt-Anchor" href="#三级标题"></a> 三级标题</h3>
<h1 id="基础语法"><a class="markdownIt-Anchor" href="#基础语法"></a> 基础语法</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mapToBucket</span><span class="params">(<span class="type">unsigned</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v &gt;= <span class="number">0</span> &amp;&amp; v &lt; <span class="number">10</span>)  <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">if</span> (v &gt;= <span class="number">10</span> &amp;&amp; v &lt; <span class="number">20</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">if</span> (v &gt;= <span class="number">20</span> &amp;&amp; v &lt; <span class="number">30</span>) <span class="keyword">return</span> <span class="number">2</span>; <span class="keyword">if</span> (v &gt;= <span class="number">30</span> &amp;&amp; v &lt; <span class="number">40</span>) <span class="keyword">return</span> <span class="number">3</span>; <span class="keyword">if</span> (v &gt;= <span class="number">40</span> &amp;&amp; v &lt; <span class="number">50</span>) <span class="keyword">return</span> <span class="number">4</span>; <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按住<kbd>Ctrl</kbd>键<code>跳转</code></p>
<blockquote>
<p>提示块标签</p>
</blockquote>
<ul>
<li>
<p>无序列表1</p>
</li>
<li>
<p>无序列表2</p>
</li>
</ul>
<ol>
<li>有序列表1</li>
<li>有序列表2</li>
</ol>
<p><mark>文本高亮</mark>，<strong>加粗</strong>，<em>斜体</em>，<mark><em><strong>斜体高亮加粗</strong></em></mark>，<s>删除线</s>，<u>下划线</u>。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">+ 新增行</span></span><br><span class="line"><span class="deletion">- 删除行</span></span><br><span class="line">其他行</span><br></pre></td></tr></table></figure>
<h1 id="分隔线"><a class="markdownIt-Anchor" href="#分隔线"></a> 分隔线</h1>
<hr />
<h1 id="标签外挂"><a class="markdownIt-Anchor" href="#标签外挂"></a> 标签外挂</h1>
<div class="note default flat"><p>default 标签外挂</p>
</div>
<div class="note primary flat"><p>primary 标签外挂</p>
</div>
<div class="note success flat"><p>success 标签外挂</p>
</div>
<div class="note danger flat"><p>danger 标签外挂</p>
</div>
<div class="note info flat"><p>info 标签外挂</p>
</div>
<div class="note warning flat"><p>warning 标签外挂</p>
</div>
<div class="note red flat"><p>red  标签外挂</p>
</div>
<div class="note quote flat"><p>quote  标签外挂</p>
</div>
<div class="tip">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<div class="tip success">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<div class="tip error">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<div class="tip warning">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<div class="tip wtgo">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<div class="tip ban">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<div class="tip home">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<div class="tip important">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<div class="tip ref">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<div class="tip ffa">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<div class="tip key">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<div class="tip socd">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<h1 id="容器"><a class="markdownIt-Anchor" href="#容器"></a> 容器</h1>
<div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test2-1">test2 1</button></li><li class="tab"><button type="button" data-href="#test2-2">test2 2</button></li><li class="tab active"><button type="button" data-href="#test2-3">test2 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test2-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="test2-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<div class="tabs" id="test3"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test3-1">test3 1</button></li><li class="tab"><button type="button" data-href="#test3-2">test3 2</button></li><li class="tab"><button type="button" data-href="#test3-3">test3 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test3-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">第一个Tab</button></li><li class="tab"><button type="button" data-href="#test4-2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#test4-3"><i class="fas fa-bomb"></i>炸弹</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab名字为第一个Tab</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><strong>只有图标 没有Tab名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p><strong>名字+icon</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h1 id="tag-hide"><a class="markdownIt-Anchor" href="#tag-hide"></a> tag hide</h1>
<p>哪个英文字母最酷？ <span class="hide-inline"><button type="button" class="hide-button" style="background-color: #FF7242;color: #fff">查看答案
  </button><span class="hide-content">因为西装裤(C装酷)</span></span></p>
<p>门里站着一个人? <span class="hide-inline"><button type="button" class="hide-button" style="">Click
  </button><span class="hide-content">闪</span></span></p>
<h1 id="block"><a class="markdownIt-Anchor" href="#block"></a> Block</h1>
<div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><div class="fj-gallery"><p><img src="https://cdn1.tianli0.top/gh/exploreMeta/cdn/img/banner/about.webp" alt="" /><br /><img src="https://cdn1.tianli0.top/gh/exploreMeta/cdn/img/banner/donate.webp" alt="" /></p>
          </div></div></div>
<h1 id="toggle"><a class="markdownIt-Anchor" href="#toggle"></a> Toggle</h1>
<details class="toggle" ><summary class="toggle-button" style="">查看代码</summary><div class="toggle-content"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure></div></details>
<h1 id="按键"><a class="markdownIt-Anchor" href="#按键"></a> 按键</h1>
<p><kbd>Ctrl </kbd>+<kbd>C </kbd> <kbd>Ctrl </kbd>+<kbd>V </kbd></p>
<h1 id="小标签"><a class="markdownIt-Anchor" href="#小标签"></a> 小标签</h1>
<!-- note语法示例 -->
<p class='div-border green left right'>加粗绿色</p>
<p class='div-border green'>绿色</p>
<p class='div-border red'>红色</p>
<p class='div-border yellow'>黄色</p>
<p class='div-border grey'>灰色</p>
<p class='div-border blue'>蓝色</p>
<!-- 小tag标签语法示例 -->
<span class="inline-tag red">红色小标签</span>
<span class="inline-tag green">绿色小标签</span>
<span class="inline-tag blue">蓝色小标签</span>
<span class="inline-tag yellow">黄色小标签</span>
<span class="inline-tag grey">灰色小标签</span>
<h1 id="彩色文字"><a class="markdownIt-Anchor" href="#彩色文字"></a> 彩色文字</h1>
<p>在一段话中方便插入各种颜色的标签，包括：<span class="p red">红色</span>、<span style="color:#ffbd2b">黄色</span>、<span class="p green">绿色</span>、<span class="p cyan">青色</span>、<span class="p blue">蓝色</span>。</p>
<h1 id="密码样式文本"><a class="markdownIt-Anchor" href="#密码样式文本"></a> 密码样式文本</h1>
<p><psw>你能看见我吗？</psw></p>
<h1 id="用markdown编写的表格样式"><a class="markdownIt-Anchor" href="#用markdown编写的表格样式"></a> 用markdown编写的表格样式</h1>
<table>
<thead>
<tr>
<th>写法</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>title</td>
<td>【必需】文章标题</td>
</tr>
<tr>
<td>date</td>
<td>【必需】文章创建日期</td>
</tr>
<tr>
<td>updated</td>
<td>【可选】文章更新日期</td>
</tr>
<tr>
<td>tags</td>
<td>【可选】文章标籤</td>
</tr>
<tr>
<td>categories</td>
<td>【可选】文章分类</td>
</tr>
<tr>
<td>keywords</td>
<td>【可选】文章关键字</td>
</tr>
<tr>
<td>description</td>
<td>【可选】文章描述</td>
</tr>
<tr>
<td>top_img</td>
<td>【可选】文章顶部图片</td>
</tr>
<tr>
<td>cover</td>
<td>【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false/图片地址/留空)</td>
</tr>
<tr>
<td>toc</td>
<td>【可选】显示文章TOC(默认为设置中toc的enable配置)</td>
</tr>
<tr>
<td>toc_number</td>
<td>【可选】显示toc_number(默认为设置中toc的number配置)</td>
</tr>
<tr>
<td>auto_open</td>
<td>【可选】是否自动打开TOC(默认为设置中toc的auto_open配置)</td>
</tr>
<tr>
<td>copyright</td>
<td>【可选】显示文章版权模块(默认为设置中post_copyright的enable配置)</td>
</tr>
<tr>
<td>mathjax</td>
<td>【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</td>
</tr>
<tr>
<td>katex</td>
<td>【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</td>
</tr>
<tr>
<td>aplayer</td>
<td>【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</td>
</tr>
<tr>
<td>highlight_shrink</td>
<td>【可选】配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置)</td>
</tr>
<tr>
<td>comments</td>
<td>【可选】显示文章评论模块(默认 true)</td>
</tr>
</tbody>
</table>
<p>另一种常见表格样式：</p>
<div alt="three-table"> <!--alt还可取值为"notitle-table"，一种无表头的小型表格-->
<table>
  <tr>
    <th alt="left">标题1</th>
    <th alt="center">标题2</th>
    <th alt="right">标题3</th>
  </tr>
  <tr>
    <td alt="left">居左：alt="left"</td>
    <td alt="center">居中：alt="center"</td>
    <td alt="right">居右：alt="right"</td>
  </tr>
  <tr>
    <td alt="left">x</td>
    <td alt="center">y</td>
    <td alt="right">z</td>
  </tr>
</table>
</div>
<p><a href="#%E4%BA%8C%E7%BA%A7%E6%A0%87%E9%A2%98">跳转</a>至二级标题（锚点）</p>
<h1 id="上下标"><a class="markdownIt-Anchor" href="#上下标"></a> 上下标</h1>
<p>X<sup>2</sup>, H<sub>2</sub>O，下标如果是多个单词或字符并以空格分隔，需要对空格进行转义，即在空格前面加<code>\</code>，（X<sub>下标1 下标2</sub>）。要显示*特殊字符等，也是通过反斜杠转义</p>
<h1 id="双语"><a class="markdownIt-Anchor" href="#双语"></a> 双语</h1>
<ul>
<li>
<p><ruby>Base<rp> (</rp><rt>top</rt><rp>)</p>
</li>
<li>
<p></rp></ruby>、<ruby>佐天泪子<rp> (</rp><rt>xiān qún kuáng mó</rt><rp>) </rp></ruby></p>
</li>
<li>
<p><ruby>超電磁砲<rp> (</rp><rt>レールガン</rt><rp>) </rp></ruby></p>
</li>
</ul>
<h1 id="图片"><a class="markdownIt-Anchor" href="#图片"></a> 图片</h1>
<img src="https://cdn1.tianli0.top/gh/exploreMeta/cdn/img/banner/client.jpg" style="zoom: 67%;"/>
<p>Gallery 相册</p>
<div class="fj-gallery"><p><img src="https://cdn1.tianli0.top/gh/exploreMeta/cdn/img/banner/about.webp" alt="" /><br /><img src="https://cdn1.tianli0.top/gh/exploreMeta/cdn/img/banner/donate.webp" alt="" /></p>
          </div>
<h1 id="音乐"><a class="markdownIt-Anchor" href="#音乐"></a> 音乐</h1>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" src="//music.163.com/outchain/player?type=2&id=1342183925&auto=0"></iframe>
<h1 id="emoji表情"><a class="markdownIt-Anchor" href="#emoji表情"></a> Emoji表情</h1>
<p><a href="https://hub.xn--p8jhe.tw/SmallOyster/emoji">查询链接</a></p>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
  </entry>
</search>
