<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>看懂简单的汇编代码</title>
    <url>/posts/3467593604.html</url>
    <content><![CDATA[<p>本文介绍的是 ATT 格式的汇编代码。先上表格：</p>
<img src="https://img.gejiba.com/images/2ec02466ed8dac1bfe60bab88be7fa76.webp" alt="整数寄存器" style="zoom:80%;" />
<p>表格记录了不同寄存器的功能。汇编指令通常都有一个或多个操作数，有的指令没有操作数，这些操作数有三种类型：立即数 <span class="p red">$<em>Imm</em></span>、寄存器 <span class="p red"><em>r<sub>a</sub></em></span> 和内存引用 <span class="p red">(<em>r<sub>a</sub></em>)</span>。</p>
<p>常见的操作指令有：</p>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">mov    S, D</td>
<td style="text-align:center">把数据从S传送到D</td>
</tr>
<tr>
<td style="text-align:center">push    S</td>
<td style="text-align:center">栈顶指针下移，S入栈</td>
</tr>
<tr>
<td style="text-align:center">pop    D</td>
<td style="text-align:center">栈顶内容赋值给D，栈顶指针上移</td>
</tr>
<tr>
<td style="text-align:center">lea    S, D</td>
<td style="text-align:center">将S的地址（&amp;S）赋值给D</td>
</tr>
<tr>
<td style="text-align:center">inc/dec/neg/not    D</td>
<td style="text-align:center">将D<code>加1/减1/取负/取反</code>后赋值给D</td>
</tr>
<tr>
<td style="text-align:center">add/sub/imul/xor/or/and    S, D</td>
<td style="text-align:center">将D<code>加/减/乘/异或/或/与</code>S后赋值给D</td>
</tr>
<tr>
<td style="text-align:center">sal/shl/sar/shr    k, D</td>
<td style="text-align:center">将D<code>算术/逻辑左移</code>/<code>算术/逻辑右移</code>k位后赋值给D</td>
</tr>
<tr>
<td style="text-align:center">leaq    S, D</td>
<td style="text-align:center">将S的地址赋值给D或者对S算术运算后赋值给D</td>
</tr>
<tr>
<td style="text-align:center">cmp/test    S1, S2</td>
<td style="text-align:center">根据<code>S2-S1或S2&amp;S1</code>的结果设置条件码</td>
</tr>
<tr>
<td style="text-align:center">cltq</td>
<td style="text-align:center">将 %eax 符号扩展到 %rax</td>
</tr>
</tbody>
</table>
<p>接下来通过几个示例来进一步理解。</p>
<h2 id="mov-指令"><a class="markdownIt-Anchor" href="#mov-指令"></a> mov 指令</h2>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">exchange</span><span class="params">(<span class="type">long</span> *xp, <span class="type">long</span> y)</span> &#123;</span><br><span class="line">    <span class="type">long</span> x = *xp;</span><br><span class="line">    *xp = y;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一个参数 xp 保存在 %rdi 中，第二个参数 y 保存在 %rsi 中，返回值保存在 %rax 中</span></span><br><span class="line"><span class="comment"># *xp 是对 xp 的解引用，即读取内存中地址 xp 处所存放的值，因此表示为 (%rdi)</span></span><br><span class="line"><span class="attr">exchange:</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">(%rdi),</span> <span class="string">%rax</span>	<span class="comment"># 将 *xp 作为返回值</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">%rsi,</span> <span class="string">(%rdi)</span>	<span class="comment"># 将 y 赋值给 *xp</span></span><br><span class="line">	<span class="string">ret</span>			<span class="comment"># return</span></span><br></pre></td></tr></table></figure>
<h2 id="lea-指令"><a class="markdownIt-Anchor" href="#lea-指令"></a> lea 指令</h2>
<p>lea（load effective address）表示加载有效地址，虽然形式上是内存引用，但实际上并没有引用内存，而是将一个内存地址直接赋值给目的操作数；mov 则是将地址处的数据赋值给目的操作数。例如：</p>
<p><code>leaq 8(%rbx), %rax</code>  表示将 <code>%rbx+8</code> 这个地址直接赋值给 <code>%rax</code>，而不是把该地址处所对应的数据赋值给 <code>%rax</code>。mov 指令则恰恰相反：</p>
<p><code>movq 8(%rbx), %rax</code> 表示将 <code>%rbx+8</code> 这个地址处所对应的数据赋值给 <code>%rax</code>。</p>
<p>lea 的用法比较灵活，除了加载有效地址，还可以进行算术运算。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">scale</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span> &#123;</span><br><span class="line">    <span class="type">long</span> t = x + <span class="number">4</span> * y + <span class="number">12</span> * z;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># x in %rdi, y in %rsi, z in %rdx</span></span><br><span class="line"><span class="attr">scale:</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="string">(%rdi,</span> <span class="string">%rsi,</span> <span class="number">4</span><span class="string">),</span> <span class="string">%rax</span>	<span class="comment"># 将 x + 4y 放入 %rax</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="string">(%rdx,</span> <span class="string">%rdx,</span> <span class="number">2</span><span class="string">),</span> <span class="string">%rdx</span>	<span class="comment"># z = z + 2z = 3z</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="string">(%rax,</span> <span class="string">%rdx,</span> <span class="number">4</span><span class="string">),</span> <span class="string">%rax</span>	<span class="comment"># 将 (x + 4y) + 3z * 4 作为返回值</span></span><br><span class="line">	<span class="string">ret</span></span><br></pre></td></tr></table></figure>
<p>对于后两条 <code>leaq</code> 指令，之所以没有直接合并成 <code>leaq (%rax, %rdx, 12), %rax</code>，是因为对于变址寻址中的比例因子只能取 1、2、4、8，因此需要对 12 分解。</p>
<p>比例因子的取值与源代码中定义的数组类型相关，编译器会据此来确定比例因子的数值。比如对于 char 类型的数组，其比例因子是 1；short 类型的比例因子是 2；int 类型是 4；double 类型是 8 等等。</p>
<blockquote>
<p>判断 lea 是加载地址还是算术运算，可以根据所操作的寄存器的功能。如果是保存参数的普通寄存器一般表示算术运算，而其他特殊的寄存器则表示加载有效地址（个人观察，有待查证）。</p>
</blockquote>
<h2 id="算术指令"><a class="markdownIt-Anchor" href="#算术指令"></a> 算术指令</h2>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">arith</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span> &#123;</span><br><span class="line">    <span class="type">long</span> t1 = x ^ y;</span><br><span class="line">    <span class="type">long</span> t2 = z * <span class="number">48</span>;</span><br><span class="line">    <span class="type">long</span> t3 = t1 &amp; <span class="number">0x0F0F0F0F</span>;</span><br><span class="line">    <span class="type">long</span> t4 = t2 - t3;</span><br><span class="line">    <span class="keyword">return</span> t4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># x in %rdi, y in %rsi, z in %rdx</span></span><br><span class="line"><span class="attr">arith:</span></span><br><span class="line">	<span class="string">xorq</span>	<span class="string">%rsi,</span> <span class="string">%rdi</span>		<span class="comment"># x = x ^ y</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="string">(%rdx,</span> <span class="string">%rdx,</span> <span class="number">2</span><span class="string">),</span> <span class="string">%rax</span>	<span class="comment"># 将 z + 2z = 3z 放入 %rax</span></span><br><span class="line">	<span class="string">salq</span>	<span class="string">$4,</span> <span class="string">%rax</span>		<span class="comment"># 将 3z 左移 4 位，即 3z * 16 = 48z 作为返回值</span></span><br><span class="line">	<span class="string">andl</span>	<span class="string">$252645135,</span> <span class="string">%edi</span>	<span class="comment"># 该立即数有 8 * 4 = 32 位，因此只取前 32 位进行与运算</span></span><br><span class="line">	<span class="string">subq</span>	<span class="string">%rdi,</span> <span class="string">%rax</span>		<span class="comment"># 将 48z - t3 的值作为返回值</span></span><br><span class="line">	<span class="string">ret</span></span><br></pre></td></tr></table></figure>
<p>对于源程序第 3 行代码中的乘法操作，被编译成了 leaq 和左移两条指令。编译器之所以没有直接使用乘法指令来实现，是因为乘法指令的执行时间更长，因此编译器会优先选择更高效的方式。</p>
<h2 id="控制指令"><a class="markdownIt-Anchor" href="#控制指令"></a> 控制指令</h2>
<h3 id="条件码"><a class="markdownIt-Anchor" href="#条件码"></a> 条件码</h3>
<p>除了整数寄存器，CPU 还维护着一组单个比特位的条件码寄存器，可以通过检测这些寄存器来执行条件分支指令。常用的条件码：</p>
<table>
<thead>
<tr>
<th style="text-align:center">条件码</th>
<th style="text-align:center">全称</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CF</td>
<td style="text-align:center">Carry  Flag</td>
<td style="text-align:center">进位标志</td>
<td style="text-align:center">最高位产生了进位</td>
</tr>
<tr>
<td style="text-align:center">ZF</td>
<td style="text-align:center">Zero  Flag</td>
<td style="text-align:center">零标志位</td>
<td style="text-align:center">操作结果为零</td>
</tr>
<tr>
<td style="text-align:center">SF</td>
<td style="text-align:center">Sign  Flag</td>
<td style="text-align:center">符号标志</td>
<td style="text-align:center">操作结果为负</td>
</tr>
<tr>
<td style="text-align:center">OF</td>
<td style="text-align:center">Overflow  Flag</td>
<td style="text-align:center">溢出标志</td>
<td style="text-align:center">操作结果溢出</td>
</tr>
</tbody>
</table>
<p>算术和逻辑运算指令会改变条件码寄存器的内容（<code>leaq</code> 不会），还有两类指令专门用来设置条件码而不改变其它任何寄存器：<code>cmp</code> 和 <code>test</code>。</p>
<p><code>cmp S1, S2</code> 会根据 <code>S2 - S1</code> 的结果来设置条件码；</p>
<p><code>test S1, S2</code> 会根据 <code>S2 &amp; S1</code> 的结果来设置条件码。</p>
<p><code>test</code> 指令的典型用法是两个操作数相同，用来判断该操作数是正数，零，还是负数。对于这样的指令，如 <code>testq %rax,%rax</code>，它与 <code>cmpq $0, %rax</code> 是等价的。</p>
<p>接下来通过示例看一下对条件码的访问。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">comp</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a in %rdi, b in %rsi</span></span><br><span class="line"><span class="attr">comp:</span></span><br><span class="line">	<span class="string">cmpq</span>	<span class="string">%rsi,</span> <span class="string">%rdi</span>	<span class="comment"># 根据 a - b 的结果设置条件码寄存器</span></span><br><span class="line">	<span class="string">setl</span>	<span class="string">%al</span>		<span class="comment"># 如果 a &lt; b，将 al 寄存器设置为 1；否则设置为 0</span></span><br><span class="line">	<span class="string">movzbl</span>	<span class="string">%al,</span> <span class="string">%eax</span>	<span class="comment"># movz 表示零扩展，将 al 寄存器从 byte 扩展到 long word</span></span><br><span class="line">	<span class="string">ret</span></span><br></pre></td></tr></table></figure>
<h3 id="循环"><a class="markdownIt-Anchor" href="#循环"></a> 循环</h3>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fact_do</span><span class="params">(<span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        result *= n;</span><br><span class="line">        n = n - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span>(n &gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># n in %rdi</span></span><br><span class="line"><span class="attr">fact_do:</span></span><br><span class="line">	<span class="string">movl</span>	<span class="string">$1,</span> <span class="string">%eax</span>	<span class="comment"># 将 1 放入 %eax</span></span><br><span class="line"><span class="string">.L2:</span></span><br><span class="line">	<span class="string">imulq</span>	<span class="string">%rdi,</span> <span class="string">%rax</span>	<span class="comment"># 将 %rax 中的值更新为自身乘以 n</span></span><br><span class="line">	<span class="string">subq</span>	<span class="string">$1,</span> <span class="string">%rdi</span>	<span class="comment"># n = n - 1</span></span><br><span class="line">	<span class="string">cmpq</span>	<span class="string">$1,</span> <span class="string">%rdi</span>	<span class="comment"># 根据 n - 1 的结果设置条件码寄存器</span></span><br><span class="line">	<span class="string">jg</span>		<span class="string">.L2</span>	<span class="comment"># 如果 n &gt; 1 则跳转到 .L2 处执行</span></span><br><span class="line">	<span class="string">rep;</span> <span class="string">ret</span>		<span class="comment"># rep 是空操作，可以直接无视它</span></span><br></pre></td></tr></table></figure>
<p><code>imul</code> 表示有符号整数乘法，<code>mul</code> 则表示无符号整数乘法。</p>
<h2 id="函数调用"><a class="markdownIt-Anchor" href="#函数调用"></a> 函数调用</h2>
<h3 id="函数栈帧"><a class="markdownIt-Anchor" href="#函数栈帧"></a> 函数栈帧</h3>
<p>当函数需要的存储空间超出寄存器所能存放的大小时，就会在栈上分配空间，这块存储空间称为该函数的 <strong>栈帧</strong>。例如，在本文最开始给出的表格中可以发现，对于前 6 个参数，每一个都有相对应的寄存器进行保存，而从第 7 个参数开始，则被保存到了栈里面。另外，还有两种常见的情况需要为函数分配栈帧，一种是对一个局部变量使用取地址符，因此必须能为它产生一个地址；另一种是当局部变量是数组或结构体。</p>
<p>当函数 P 调用函数 Q 时，其栈帧结构如下：</p>
<img src="https://img.gejiba.com/images/e89ffa3aefa3462d8eb41ee9777ead4c.webp" alt="P调用Q的栈帧结构" style="zoom:16%;" />
<p>当前正在执行的函数的栈帧总是保存在栈顶，当 P 调用 Q 时，call 指令会把返回地址压入栈中，该地址指明了当 Q 返回时，要从 P 的哪个位置继续执行。下面看一个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">proc</span><span class="params">(<span class="type">long</span>  a1, <span class="type">long</span>  *a1p,</span></span><br><span class="line"><span class="params">          <span class="type">int</span>   a2, <span class="type">int</span>   *a2p,</span></span><br><span class="line"><span class="params">          <span class="type">short</span> a3, <span class="type">short</span> *a3p,</span></span><br><span class="line"><span class="params">          <span class="type">char</span>  a4, <span class="type">char</span>  *a4p)</span> &#123;</span><br><span class="line">    *a1p += a1;</span><br><span class="line">    *a2p += a2;</span><br><span class="line">    *a3p += a3;</span><br><span class="line">    *a4p += a4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">call_proc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span>  x1 = <span class="number">1</span>; <span class="type">int</span>  x2 = <span class="number">2</span>;</span><br><span class="line">    <span class="type">short</span> x3 = <span class="number">3</span>; <span class="type">char</span> x4 = <span class="number">4</span>;</span><br><span class="line">    proc(x1, &amp;x1, x2, &amp;x2, x3, &amp;x3, x4, &amp;x4);</span><br><span class="line">    <span class="keyword">return</span> (x1 + x2) * (x3 - x4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>proc 的汇编代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a1 in %rdi, a1p in %rsi</span></span><br><span class="line"><span class="comment"># a2 in %edx, a2p in %rcx</span></span><br><span class="line"><span class="comment"># a3 in %r8w, a3p in %r9</span></span><br><span class="line"><span class="comment"># %rsp 指向栈顶</span></span><br><span class="line"><span class="comment"># a4 in %rsp+8, a4p in %rsp+16</span></span><br><span class="line"><span class="attr">proc:</span></span><br><span class="line">	<span class="string">movq</span>	<span class="number">16</span><span class="string">(%rsp),</span> <span class="string">%rax</span>	<span class="comment"># 将 a4p 放入 %rax</span></span><br><span class="line">	<span class="string">addq</span>	<span class="string">%rdi,</span> <span class="string">(%rsi)</span>	<span class="comment"># *a1p += a1</span></span><br><span class="line">	<span class="string">addl</span>	<span class="string">%edx,</span> <span class="string">(%rcx)</span>	<span class="comment"># *a2p += a2</span></span><br><span class="line">	<span class="string">addw</span>	<span class="string">%r8w,</span> <span class="string">(%r9)</span>	<span class="comment"># *a3p += a3</span></span><br><span class="line">	<span class="string">movl</span>	<span class="number">8</span><span class="string">(%rsp),</span> <span class="string">%edx</span>	<span class="comment"># 将 a4 放入 %edx</span></span><br><span class="line">	<span class="string">addb</span>	<span class="string">%dl,</span> <span class="string">(%rax)</span>	<span class="comment"># *a4p += a4</span></span><br><span class="line">	<span class="string">ret</span></span><br></pre></td></tr></table></figure>
<p>有几点需要注意：</p>
<ul>
<li>虽然从第 7 个参数开始都被保存到了栈中，但是当指令需要对这些参数操作时，仍然需要先从栈读入到寄存器中。</li>
<li>通过栈传递参数时，所有数据都需要 8 字节对齐，所以 a4 即便只有 1 个字节，仍然为其分配了 8 个字节的存储空间。<span class="p red">注意：只有借助栈传递参数时才需要 8 字节对齐，如果只是在栈中存放局部变量，比如使用了取地址运算符的局部变量（必须存放在栈中），它们是不需要对齐的。</span></li>
<li>a4 是从 %rsp+8 的位置开始存放的，而不是 %rsp 指向的位置，说明返回地址占据了栈顶位置。函数 proc 的栈帧如图所示：</li>
</ul>
<img src="https://img.gejiba.com/images/3dc0f287b4a191a0053e3de978a4726a.webp" alt="proc 的栈帧" style="zoom:45%;" />
<p>call_proc 的汇编代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">call_proc:</span></span><br><span class="line">	<span class="string">subq</span>	<span class="string">$32,</span> <span class="string">%rsp</span>	<span class="comment"># %rsp - 32，分配 32 字节大小的栈帧</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">$1,</span> <span class="number">24</span><span class="string">(%rsp)</span>	<span class="comment"># 将立即数 1 放到栈帧 %rsp + 24 处</span></span><br><span class="line">	<span class="string">movl</span>	<span class="string">$2,</span> <span class="number">20</span><span class="string">(%rsp)</span>	<span class="comment"># 将立即数 2 放到栈帧 %rsp + 20 处</span></span><br><span class="line">	<span class="string">movw</span>	<span class="string">$3,</span> <span class="number">18</span><span class="string">(%rsp)</span>	<span class="comment"># 将立即数 3 放到栈帧 %rsp + 18 处</span></span><br><span class="line">	<span class="string">movb</span>	<span class="string">$4,</span> <span class="number">17</span><span class="string">(%rsp)</span>	<span class="comment"># 将立即数 4 放到栈帧 %rsp + 17 处</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="number">17</span><span class="string">(%rsp),</span> <span class="string">%rax</span>	<span class="comment"># 将 &amp;x4 放入 %rax</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">%rax,</span> <span class="number">8</span><span class="string">(%rsp)</span>	<span class="comment"># 将 &amp;x4 放到栈帧 %rsp + 8 处作为第 8 个参数</span></span><br><span class="line">	<span class="string">movl</span>	<span class="string">$4,</span> <span class="string">(%rsp)</span>	<span class="comment"># 将立即数 4 放到栈帧 %rsp 处作为第 7 个参数</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="number">18</span><span class="string">(%rsp),</span> <span class="string">%r9</span>	<span class="comment"># 将 &amp;x3 作为第 6 个参数</span></span><br><span class="line">	<span class="string">movl</span>	<span class="string">$3,</span> <span class="string">%r8d</span>	<span class="comment"># 将立即数 3 作为第 5 个参数</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="number">20</span><span class="string">(%rsp),</span> <span class="string">%rcx</span>	<span class="comment"># 将 &amp;x2 作为第 4 个参数</span></span><br><span class="line">	<span class="string">movl</span>	<span class="string">$2,</span> <span class="string">%edx</span>	<span class="comment"># 将立即数 2 作为第 3 个参数</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="number">24</span><span class="string">(%rsp),</span> <span class="string">%rsi</span>	<span class="comment"># 将 &amp;x1 作为第 2 个参数</span></span><br><span class="line">	<span class="string">movl</span>	<span class="string">$1,</span> <span class="string">%edi</span>	<span class="comment"># 将立即数 1 作为第 1 个参数</span></span><br><span class="line">	<span class="comment"># 调用函数 proc</span></span><br><span class="line">	<span class="string">call</span>	<span class="string">proc</span></span><br><span class="line">	<span class="string">movslq</span>	<span class="number">20</span><span class="string">(%rsp),</span> <span class="string">%rdx</span>	<span class="comment"># 将 x2 符号扩展为四字放入 %rdx</span></span><br><span class="line">	<span class="string">addq</span>	<span class="number">24</span><span class="string">(%rsp),</span> <span class="string">%rdx</span>	<span class="comment"># 将 x2 + x1 放入 %rdx</span></span><br><span class="line">	<span class="string">movswl</span>	<span class="number">18</span><span class="string">(%rsp),</span> <span class="string">%eax</span>	<span class="comment"># 将 x3 符号扩展为双字放入 %eax</span></span><br><span class="line">	<span class="string">movsbl</span>	<span class="number">17</span><span class="string">(%rsp),</span> <span class="string">%ecx</span>	<span class="comment"># 将 x4 符号扩展为双字放入 %ecx</span></span><br><span class="line">	<span class="string">subl</span>	<span class="string">%ecx,</span> <span class="string">%eax</span>	<span class="comment"># 将 x3 - x4 放入 %eax</span></span><br><span class="line">	<span class="string">cltq</span>			<span class="comment"># 将 %eax 符号扩展到 %rax</span></span><br><span class="line">	<span class="string">imulq</span>	<span class="string">%rdx,</span> <span class="string">%rax</span>	<span class="comment"># 将 (x3 - x4) * (x2 + x1) 作为返回值</span></span><br><span class="line">	<span class="string">addq</span>	<span class="string">$32,</span> <span class="string">%rsp</span>	<span class="comment"># %rsp + 32，释放 32 字节大小的栈帧</span></span><br><span class="line">	<span class="string">ret</span></span><br></pre></td></tr></table></figure>
<p>函数 call_proc 的栈帧如图所示：</p>
<img src="https://img.gejiba.com/images/64c8434dd3f2a16518fbd172400264e8.webp" alt="call_proc 的栈帧" style="zoom:45%;" />
<h3 id="被调用者保存寄存器"><a class="markdownIt-Anchor" href="#被调用者保存寄存器"></a> [被]调用者保存寄存器</h3>
<p>在程序执行的过程中，寄存器是被所有函数共享的，因此为了确保在使用过程中寄存器内的数据不被覆盖，处理器采用了一组统一的寄存器使用惯例，所有函数都必须遵守。</p>
<p>根据惯例，对于 16 个通用寄存器，除了 %rsp 之外，其余 15 个寄存器被划分为调用者保存和被调用者保存。其中，%rbx、%rbp、%r12~%r15 被划分为 <strong>被调用者保存寄存器</strong>，剩余的被划分为 <strong>调用者保存寄存器</strong>。下面以一个例子说明其使用方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">P</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span> &#123;</span><br><span class="line">    <span class="type">long</span> u = Q(y);</span><br><span class="line">    <span class="type">long</span> v = Q(x);</span><br><span class="line">    <span class="keyword">return</span> u + v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># x in %rdi, y in %rsi</span></span><br><span class="line"><span class="attr">P:</span></span><br><span class="line">	<span class="string">pushq</span>	<span class="string">%rbp</span>		<span class="comment"># 保存 %rbp 中的值</span></span><br><span class="line">	<span class="string">pushq</span>	<span class="string">%rbx</span>		<span class="comment"># 保存 %rbx 中的值</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">%rdi,</span> <span class="string">%rbp</span>	<span class="comment"># 将 %rdi 中的值 x 保存到 %rbp 中</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">%rsi,</span> <span class="string">%rdi</span>	<span class="comment"># 将 y 放入 %rdi 作为第一个参数</span></span><br><span class="line">	<span class="string">call</span>	<span class="string">Q</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">%rax,</span> <span class="string">%rbx</span>	<span class="comment"># 将 Q 的返回结果 u 保存到 %rbx 中</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">%rbp,</span> <span class="string">%rdi</span>	<span class="comment"># 将 x 放入 %rdi 作为第一个参数</span></span><br><span class="line">	<span class="string">call</span>	<span class="string">Q</span></span><br><span class="line">	<span class="string">addq</span>	<span class="string">%rbx,</span> <span class="string">%rax</span>	<span class="comment"># 将 v + u 作为返回值</span></span><br><span class="line">	<span class="string">addq</span>	<span class="string">$8,</span> <span class="string">%rsp</span>	<span class="comment"># 释放 8 个字节的栈帧</span></span><br><span class="line">	<span class="string">popq</span>	<span class="string">%rbx</span>		<span class="comment"># 恢复 %rbx 中的值</span></span><br><span class="line">	<span class="string">popq</span>	<span class="string">%rbp</span>		<span class="comment"># 恢复 %rbp 中的值</span></span><br><span class="line">	<span class="string">ret</span></span><br></pre></td></tr></table></figure>
<p>在函数 P 中，x 保存在 %rdi 中，当在第 7 行调用函数 Q 时，由于 Q 有一个参数，因此也会使用 %rdi。为了防止 P 中的 %rdi 值被覆盖，需要先将其保存到一个其他无关的寄存器 %rbp 中（第 6 行），而为了防止原本 %rbp 中的内容被覆盖，在此之前还需将其中的内容压入栈中保存起来（第 3 行）。</p>
<p>同样的道理，当第一次调用 Q 结束时，结果会被保存在 %rax 中返回；而当第二次调用函数 Q 时，其返回结果仍然会保存在 %rax 中。为了防止第一次返回的结果被覆盖，需要先将其保存到一个其他无关的寄存器 %rbx 中（第 8 行），而为了防止原本 %rbx 中的内容被覆盖，在此之前还需将其中的内容压入栈中保存起来（第 4 行）。</p>
<blockquote>
<p>这里介绍一下 push 这条指令所进行的操作。实际上，执行一次 <code>pushq S</code>，等价于以下两条操作指令：<code>subq $8,%rsp</code> 与 <code>movq S,(%rsp)</code>，因此两次 push 之后 %rsp 依然指向栈顶。</p>
<p>相应地，<code>popq D</code> 也等价于两条指令：<code>movq (%rsp),D</code> 和 <code>addq $8,%rsp</code>。</p>
</blockquote>
<p>在函数 P 结束之前，按照栈后进先出的顺序出栈，依次恢复 %rbx 和 %rbp 中的内容。</p>
<h3 id="函数递归调用"><a class="markdownIt-Anchor" href="#函数递归调用"></a> 函数递归调用</h3>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">rfact</span><span class="params">(<span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)</span><br><span class="line">        result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        result = n * rfact(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># n in %rdi</span></span><br><span class="line"><span class="attr">rfact:</span></span><br><span class="line">	<span class="string">pushq</span>	<span class="string">%rbx</span>			<span class="comment"># 保存 %rbx 中的值</span></span><br><span class="line">	<span class="string">movq</span>	<span class="string">%rdi,</span> <span class="string">%rbx</span>		<span class="comment"># 将 n 放入 %rbx</span></span><br><span class="line">	<span class="string">movl</span>	<span class="string">$1,</span> <span class="string">%eax</span>		<span class="comment"># 将 1 放入 %rax</span></span><br><span class="line">	<span class="string">cmpq</span>	<span class="string">$1,</span> <span class="string">%rdi</span>		<span class="comment"># 根据 n - 1 的值设置条件码寄存器</span></span><br><span class="line">	<span class="string">jle</span>	<span class="string">.L35</span>			<span class="comment"># 如果 n &lt;= 1，跳转到 .L35</span></span><br><span class="line">	<span class="string">leaq</span>	<span class="number">-1</span><span class="string">(%rdi),</span> <span class="string">%rdi</span>		<span class="comment"># 将 n = n - 1 作为第一个参数</span></span><br><span class="line">	<span class="string">call</span>	<span class="string">rfact</span>			<span class="comment"># 调用函数 rfact</span></span><br><span class="line">	<span class="string">imulq</span>	<span class="string">%rbx,</span> <span class="string">%rax</span>		<span class="comment"># 将 rfact(n - 1) * n 的值放入 %rax</span></span><br><span class="line"><span class="string">.L35:</span></span><br><span class="line">	<span class="string">popq</span>	<span class="string">%rbx</span>			<span class="comment"># 恢复 %rbx 中的值</span></span><br><span class="line">	<span class="string">ret</span></span><br></pre></td></tr></table></figure>
<h2 id="数组和结构体"><a class="markdownIt-Anchor" href="#数组和结构体"></a> 数组和结构体</h2>
<h3 id="数组和指针"><a class="markdownIt-Anchor" href="#数组和指针"></a> 数组和指针</h3>
<p>数组在内存中是连续存放的，每个元素所占内存的大小由数组类型决定，如图所示：</p>
<img src="https://img.gejiba.com/images/e3d43bd460b0c20d24ce0fd3018b4f7b.webp" alt="array" style="zoom:62%;" />
<p>对指针进行运算时，计算结果会根据指针类型进行相应的伸缩。为方便理解，将内存抽象成一个很大的数组，假设初始时指针 p 和 q 都指向 0x100 处，现分别对两个指针进行加 1 操作，由于指针类型不同，指针 p + 1 会前进 1 个字节，而指针 q + 1 会前进 4 个字节，如图所示：</p>
<img src="https://img.gejiba.com/images/fb5a7e558f74a7c9c29816a82405f68a.webp" alt="padd" style="zoom:70%;" />
<p>而数组名正是指向该数组首元素的指针，因此对于数组 <code>int arr[5]</code> 中的每一个元素，均有两种表示方式，如图所示：</p>
<img src="https://img.gejiba.com/images/38e1cc7b41ea67d443c837bebf6bbe95.webp" alt="parr" style="zoom:75%;" />
<p>对于二维数组，在内存中是按照行优先的顺序存储的：</p>
<img src="https://img.gejiba.com/images/af9f4f55dd7d45b4c94e582e69595f8c.webp" alt="2D-array" style="zoom:70%;" />
<h3 id="结构体和联合体"><a class="markdownIt-Anchor" href="#结构体和联合体"></a> 结构体和联合体</h3>
<p>CPU 是按 32/64 位的大小进行存取的，为了提高 CPU 的执行效率，计算机系统对基本数据类型的合法地址做了一些限制，要求某种类型的地址必须是某个值（2 / 4 / 8）的倍数，这就是 <strong>数据对齐</strong>。数据对齐会由编译器自动实现，但了解其实现方法还是很有必要的，可以优化代码结构，达到节省空间和提高效率（减少访存次数）的目的。</p>
<p>数据对齐的基本原则是：<span class="p red">任何 K 字节的基本对象的地址必须是 K 的倍数</span>。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>  i;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span>  j;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果不进行数据对齐（以 64 位机器为例），结构体 S1 在内存中的分布如图 (a) 所示。</p>
<p>虽然整体只占了 9 个字节，但要访问成员 j，需要访问两次内存才行，这样效率并不高。而如果进行了数据对齐，则访问所有成员都只需访问一次内存即可，如图 (b)。其中在 c 后面插入 3 个字节，是因为 j 占 4 个字节，所以它的起始地址必须是 4 的倍数。</p>
<p>另外，在结构体的末尾，可能也需要一些填充。比如假设结构体 S1 中没有成员 j，那所有元素都是满足对齐要求的，但是当该结构体声明为数组时（比如 <code>struct S1 arr[2]</code>），对齐原则就无法保证了，因此需要在末尾进行填充以满足结构体数组的对齐原则，如图 (c)。</p>
<img src="https://img.gejiba.com/images/56afaf0f2107e96c0d3562725c18e2be.webp" alt="align" style="zoom:50%;" />
<p>与结构体不同，联合体中的所有字段共享同一存储区域，因此联合体的大小取决于其最大字段的大小。如果我们事先知道两个不同字段的使用是互斥的，那么就可以将这两个字段声明为一个联合体，从而达到节省内存空间的目的。</p>
<p>此外，联合体还可以用来访问不同数据类型的位模式，比如判断机器的大小端：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">    &#125; temp;</span><br><span class="line">    temp.i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(temp.c == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Little Endian\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Big Endian\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 i 占 4 个字节，c 占 1 个字节，二者共享同一段内存，因此只需为 temp 分配 4 字节的空间。当为联合体中的 i 赋值后（第 6 行），为 temp 分配的四个字节都填满了，此时访问其中的 c 成员，其实就是访问这段内存的第 1 个字节，即低地址处的第 1 个字节。</p>
<p>对于 4 字节的整型 1，其十六进制表示为 <code>0x0000 0001</code>。若机器是小端，则低位放低地址处，高位放高地址处，地址从低到高依次为 <code>0x01 0x00 0x00 0x00</code>；若机器是大端，则低位放高地址处，高位放低地址处，地址从低到高依次为 <code>0x00 0x00 0x00 0x01</code>。</p>
<p>此时只需判断 c 的值是 <code>0x01</code> 还是 <code>0x00</code>，即可判断机器是小端还是大端。</p>
<p>再比如，可以用如下方法来获取 double 类型的二进制位表示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">double2bits</span><span class="params">(<span class="type">double</span> d)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> u;</span><br><span class="line">    &#125; temp; <span class="comment">// 以一种类型存储，以另一种类型访问</span></span><br><span class="line">    temp.d = d;</span><br><span class="line">    <span class="keyword">return</span> temp.u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>double</code> 与 <code>unsigned long</code> 所占的字节相同，因此当为 d 赋值后，d 和 u 就共同拥有了相同大小的内存空间，此时对 u 的访问即是 d 的二进制位的十进制表示。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机系统漫游</title>
    <url>/posts/4223884717.html</url>
    <content><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>《深入理解计算机系统-CSAPP》是计算机领域的圣经✨之前翻看过两三次，不过由于平时在实验室一直都有各种事情牵扯时间跟精力，每次阅读都近乎走马观花。</p>
<p>最近论文送审之后终于有了充足的时间，于是便静下心来重新读了一遍。对于其中一些晦涩难懂且意义不大（个人愚见）的知识点（如浮点数的表示和运算、存储器山等等）本人并未细究，这里仅对自己之前没有完全掌握，或者易忘易混淆的知识点做个记录📝方便日后查阅。</p>
<p>在整理了部分内容之后我发现整体架构看起来依然有些零散，没有逻辑主线💥事实上我也确实是从<code>hello.c</code>程序编译的各个过程中发散出来的小的知识点。</p>
<p>为了使介绍能够更加聚焦，后续内容我决定采用问答的形式，然后从回答中抽取关键字来“浅挖”其原理和细节。能力一般，水平有限，所有内容仅仅是个人的一些粗浅的理解，之后我会尽量多读相关书籍来修正和完善这些内容🚩</p>
<p>『计算机系统漫游』部分主要是对全书中我比较感兴趣的部分做一个粗略的介绍，其中每个<span class="inline-tag blue">蓝色小标签</span>中的内容（包括但不限于此）都将是后续博客中进一步展开介绍的对象~~</p>
<h2 id="从hello-world开始"><a class="markdownIt-Anchor" href="#从hello-world开始"></a> 从Hello World开始</h2>
<p><img src="https://img.gejiba.com/images/2df68f1e0cc0ea3c4bd7722f0b09e509.webp" alt="Hello World编译过程" /></p>
<h2 id="文本文件与二进制文件"><a class="markdownIt-Anchor" href="#文本文件与二进制文件"></a> 文本文件与二进制文件</h2>
<p>我们所编写的<code>hello.c</code>程序属于文本文件，经过编译后生成的可执行文件是二进制文件。它们最终在物理内存上都是以二进制形式保存的，因此二者的主要区别是逻辑上的而不是物理上的：</p>
<ul>
<li>
<p>文本文件：基于字符编码，如ASCII、Unicode等，每个值都有固定的Size。</p>
</li>
<li>
<p>二进制文件：基于值编码，没有固定的Size，实际上就是把值在物理内存上的原始二进制形式。</p>
</li>
</ul>
<p>比如<code>\n</code>在文本文件中是换行符，而在二进制文件中会被认为是<code>\</code>和<code>n</code>两个字符。</p>
<h2 id="原码-反码和补码"><a class="markdownIt-Anchor" href="#原码-反码和补码"></a> 原码、反码和补码</h2>
<p>有符号数的表示方法有三种，分别是原码、反码和补码，它们都是用最高位的<code>0</code>和<code>1</code>来区分正负。对于正数，三者的表示都是一致的，即该数的二进制表示，主要区别是在负数上。例如<code>15</code>的二进制表示为<code>0000 1111</code>，而对于<code>-15</code>：</p>
<ul>
<li>原码：<code>1000 1111</code> 符号位 + 二进制表示</li>
<li>反码：<code>1111 0000</code> 在原码基础上，除符号位外全部取反</li>
<li>补码：<code>1111 0001</code> 反码 + 1</li>
</ul>
<p>在计算机中，有符号数是用补码来表示的。之所以不用另外两种编码方式，是因为对于数字<code>0</code>，二者都有两种不同的编码方式，分别是<code>+0</code>和<code>-0</code>，而补码则不存在这种问题。</p>
<h2 id="汇编程序与机器指令"><a class="markdownIt-Anchor" href="#汇编程序与机器指令"></a> 汇编程序与机器指令</h2>
<p>高级语言编写的程序可以在很多不同的机器上编译运行，生成该机器所支持的<span class="inline-tag blue">机器指令</span>。<span class="inline-tag blue">汇编程序</span>是机器指令的文本表示，在不同指令级架构的机器上有不同的表现形式，这也就解释了为什么最终生成的可执行目标文件一般都不能跨平台执行。</p>
<p>Java之所以能够跨平台（一次编译多次运行），是因为它并不是直接运行在CPU上的，而是生成字节码（.class）文件后由 JVM 统一执行。此时JVM有两种选择：一种是使用 Java 解释器解释执行，另一种是使用 JIT 编译器将字节码转化为本地机器指令。</p>
<p>二者的区别在于，前者启动速度快但运行速度慢，后者启动速度慢但运行速度快。这是因为解释器不需要像 JIT 编译器一样，将所有字节码都转化为机器指令，自然就省去了优化的时间。而当 JIT 编译器完成第一次编译后会将字节码对应的机器指令保存下来，下次可以直接使用。由于机器指令的执行效率要高于 Java 解释器，所以在实际情况中，为了速度和效率，通常采用两者相结合的方式。</p>
<h2 id="可重定位文件与可执行文件"><a class="markdownIt-Anchor" href="#可重定位文件与可执行文件"></a> 可重定位文件与可执行文件</h2>
<p>如果想让代码运行，那么生成的目标代码中的每个符号（函数或变量）的地址都应该是确定的。事实上，在汇编阶段，只有跟源代码在同一个模块中的符号地址能确定下来，而定义在其他模块中的全局变量和函数的地址要在链接的时候才能确定。编译器在没法确定地址的情况下，会先将其置为 0，等到链接的时候再去修正它们，这个过程就是<span class="inline-tag blue">重定位</span>。因此很自然地，在链接之前（汇编阶段）生成的目标文件叫做可重定位目标文件，在链接之后生成的目标文件叫做<span class="inline-tag blue">可执行目标文件</span>。</p>
<h2 id="静态链接与动态链接"><a class="markdownIt-Anchor" href="#静态链接与动态链接"></a> 静态链接与动态链接</h2>
<p>链接分为<span class="inline-tag blue">静态链接</span>和<span class="inline-tag blue">动态链接</span>，二者的区别在于：静态链接会把引用到的所有目标文件全部嵌入到可执行文件中，因此生成的是完全可执行的目标文件；动态链接只会链接所引用文件的重定位和符号表信息，因此生成的是部分链接的可执行目标文件，直到运行或加载的时候，才会由动态链接器将物理内存中的共享库的地址与其链接起来。</p>
<h2 id="cpu流水线划分"><a class="markdownIt-Anchor" href="#cpu流水线划分"></a> CPU流水线划分</h2>
<p>CPU流水线最经典的划分方式包括：取指、译码、执行、访存、写回、更新PC寄存器。这些阶段看似简单，但有很多细节与我之前的理解存在严重偏差。比如取指阶段就只是单纯地从PC寄存器取出指令吗？译码阶段是要对取出的机器指令进行翻译吗？执行阶段好像是最简单的，就是执行我们程序逻辑中的主体运算，但就只有这一种情况吗？访存就是访问DRAM内存吗？写回是将修改后的值重新写回到内存吗？当然这些答案都是否定的，后续我会详细介绍<span class="inline-tag blue">CPU流水线</span>的这几个阶段。</p>
<h2 id="高速缓存存储器"><a class="markdownIt-Anchor" href="#高速缓存存储器"></a> 高速缓存存储器</h2>
<p><span class="inline-tag blue">高速缓存</span>的结构可以用<code>(S, E, B, m)</code>来表示，每个缓存行中还保存了有效位和标记位，方便快速定位目标数据，那具体工作过程是怎样的呢？另外根据<code>E</code>的不同，可以分为直接映射、组相连和全相连的高速缓存，这样划分的目的是什么？各有都有哪些优缺点？每种方式都有自己的应用场景吗？</p>
<h2 id="物理内存和虚拟内存"><a class="markdownIt-Anchor" href="#物理内存和虚拟内存"></a> 物理内存和虚拟内存</h2>
<p><span class="inline-tag blue">虚拟内存</span>并不是虚拟的、非真实存在的内存，而是对磁盘的虚拟化，将内存视为磁盘的高速缓存，在内存空间不足时将磁盘的一块区域划分成虚拟内存，通过与物理内存的换入换出来满足程序运行的需求。有虚拟内存自然就有<span class="inline-tag blue">虚拟地址</span>，相应地也会有物理地址，它们之间是如何完成映射的？进程的虚拟地址空间是真实存在的吗？是保存在物理内存中的吗？程序请求分配到的内存是物理内存吗？<span class="inline-tag blue">内存分配</span>后忘记释放内存会怎么样？Java不需要手动释放内存，那它的<span class="inline-tag blue">垃圾回收</span>机制是怎么实现的？这些问题我都会在后续博客中一一解答。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>This is a test blog</title>
    <url>/posts/1243066710.html</url>
    <content><![CDATA[<h1 id="一级标题"><a class="markdownIt-Anchor" href="#一级标题"></a> 一级标题</h1>
<p>Welcome to <a href="https://hexo.io/">Hexo</a>!</p>
<h2 id="二级标题"><a class="markdownIt-Anchor" href="#二级标题"></a> 二级标题</h2>
<h3 id="三级标题"><a class="markdownIt-Anchor" href="#三级标题"></a> 三级标题</h3>
<h1 id="基础语法"><a class="markdownIt-Anchor" href="#基础语法"></a> 基础语法</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mapToBucket</span><span class="params">(<span class="type">unsigned</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v &gt;= <span class="number">0</span> &amp;&amp; v &lt; <span class="number">10</span>)  <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">if</span> (v &gt;= <span class="number">10</span> &amp;&amp; v &lt; <span class="number">20</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">if</span> (v &gt;= <span class="number">20</span> &amp;&amp; v &lt; <span class="number">30</span>) <span class="keyword">return</span> <span class="number">2</span>; <span class="keyword">if</span> (v &gt;= <span class="number">30</span> &amp;&amp; v &lt; <span class="number">40</span>) <span class="keyword">return</span> <span class="number">3</span>; <span class="keyword">if</span> (v &gt;= <span class="number">40</span> &amp;&amp; v &lt; <span class="number">50</span>) <span class="keyword">return</span> <span class="number">4</span>; <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按住<kbd>Ctrl</kbd>键<code>跳转</code></p>
<blockquote>
<p>提示块标签</p>
</blockquote>
<ul>
<li>
<p>无序列表1</p>
</li>
<li>
<p>无序列表2</p>
</li>
</ul>
<ol>
<li>有序列表1</li>
<li>有序列表2</li>
</ol>
<p><mark>文本高亮</mark>，<strong>加粗</strong>，<em>斜体</em>，<mark><em><strong>斜体高亮加粗</strong></em></mark>，<s>删除线</s>，<u>下划线</u>。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">+ 新增行</span></span><br><span class="line"><span class="deletion">- 删除行</span></span><br><span class="line">其他行</span><br></pre></td></tr></table></figure>
<h1 id="分隔线"><a class="markdownIt-Anchor" href="#分隔线"></a> 分隔线</h1>
<hr />
<h1 id="标签外挂"><a class="markdownIt-Anchor" href="#标签外挂"></a> 标签外挂</h1>
<div class="note default flat"><p>default 标签外挂</p>
</div>
<div class="note primary flat"><p>primary 标签外挂</p>
</div>
<div class="note success flat"><p>success 标签外挂</p>
</div>
<div class="note danger flat"><p>danger 标签外挂</p>
</div>
<div class="note info flat"><p>info 标签外挂</p>
</div>
<div class="note warning flat"><p>warning 标签外挂</p>
</div>
<div class="note red flat"><p>red  标签外挂</p>
</div>
<div class="note quote flat"><p>quote  标签外挂</p>
</div>
<div class="tip">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<div class="tip success">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<div class="tip error">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<div class="tip warning">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<div class="tip wtgo">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<div class="tip ban">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<div class="tip home">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<div class="tip important">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<div class="tip ref">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<div class="tip ffa">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<div class="tip key">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<div class="tip socd">
    <p>为简单的一句话提供的简便写法。</p>
</div>
<h1 id="容器"><a class="markdownIt-Anchor" href="#容器"></a> 容器</h1>
<div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test2-1">test2 1</button></li><li class="tab"><button type="button" data-href="#test2-2">test2 2</button></li><li class="tab active"><button type="button" data-href="#test2-3">test2 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test2-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="test2-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<div class="tabs" id="test3"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test3-1">test3 1</button></li><li class="tab"><button type="button" data-href="#test3-2">test3 2</button></li><li class="tab"><button type="button" data-href="#test3-3">test3 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test3-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">第一个Tab</button></li><li class="tab"><button type="button" data-href="#test4-2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#test4-3"><i class="fas fa-bomb"></i>炸弹</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab名字为第一个Tab</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><strong>只有图标 没有Tab名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p><strong>名字+icon</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h1 id="tag-hide"><a class="markdownIt-Anchor" href="#tag-hide"></a> tag hide</h1>
<p>哪个英文字母最酷？ <span class="hide-inline"><button type="button" class="hide-button" style="background-color: #FF7242;color: #fff">查看答案
  </button><span class="hide-content">因为西装裤(C装酷)</span></span></p>
<p>门里站着一个人? <span class="hide-inline"><button type="button" class="hide-button" style="">Click
  </button><span class="hide-content">闪</span></span></p>
<h1 id="block"><a class="markdownIt-Anchor" href="#block"></a> Block</h1>
<div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><div class="fj-gallery"><p><img src="https://cdn1.tianli0.top/gh/exploreMeta/cdn/img/banner/about.webp" alt="" /><br /><img src="https://cdn1.tianli0.top/gh/exploreMeta/cdn/img/banner/donate.webp" alt="" /></p>
          </div></div></div>
<h1 id="toggle"><a class="markdownIt-Anchor" href="#toggle"></a> Toggle</h1>
<details class="toggle" ><summary class="toggle-button" style="">查看代码</summary><div class="toggle-content"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure></div></details>
<h1 id="按键"><a class="markdownIt-Anchor" href="#按键"></a> 按键</h1>
<p><kbd>Ctrl </kbd>+<kbd>C </kbd> <kbd>Ctrl </kbd>+<kbd>V </kbd></p>
<h1 id="小标签"><a class="markdownIt-Anchor" href="#小标签"></a> 小标签</h1>
<!-- note语法示例 -->
<p class='div-border green left right'>加粗绿色</p>
<p class='div-border green'>绿色</p>
<p class='div-border red'>红色</p>
<p class='div-border yellow'>黄色</p>
<p class='div-border grey'>灰色</p>
<p class='div-border blue'>蓝色</p>
<!-- 小tag标签语法示例 -->
<span class="inline-tag red">红色小标签</span>
<span class="inline-tag green">绿色小标签</span>
<span class="inline-tag blue">蓝色小标签</span>
<span class="inline-tag yellow">黄色小标签</span>
<span class="inline-tag grey">灰色小标签</span>
<h1 id="彩色文字"><a class="markdownIt-Anchor" href="#彩色文字"></a> 彩色文字</h1>
<p>在一段话中方便插入各种颜色的标签，包括：<span class="p red">红色</span>、<span style="color:#ffbd2b">黄色</span>、<span class="p green">绿色</span>、<span class="p cyan">青色</span>、<span class="p blue">蓝色</span>。</p>
<h1 id="密码样式文本"><a class="markdownIt-Anchor" href="#密码样式文本"></a> 密码样式文本</h1>
<p><psw>你能看见我吗？</psw></p>
<h1 id="用markdown编写的表格样式"><a class="markdownIt-Anchor" href="#用markdown编写的表格样式"></a> 用markdown编写的表格样式</h1>
<table>
<thead>
<tr>
<th>写法</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>title</td>
<td>【必需】文章标题</td>
</tr>
<tr>
<td>date</td>
<td>【必需】文章创建日期</td>
</tr>
<tr>
<td>updated</td>
<td>【可选】文章更新日期</td>
</tr>
<tr>
<td>tags</td>
<td>【可选】文章标籤</td>
</tr>
<tr>
<td>categories</td>
<td>【可选】文章分类</td>
</tr>
<tr>
<td>keywords</td>
<td>【可选】文章关键字</td>
</tr>
<tr>
<td>description</td>
<td>【可选】文章描述</td>
</tr>
<tr>
<td>top_img</td>
<td>【可选】文章顶部图片</td>
</tr>
<tr>
<td>cover</td>
<td>【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false/图片地址/留空)</td>
</tr>
<tr>
<td>toc</td>
<td>【可选】显示文章TOC(默认为设置中toc的enable配置)</td>
</tr>
<tr>
<td>toc_number</td>
<td>【可选】显示toc_number(默认为设置中toc的number配置)</td>
</tr>
<tr>
<td>auto_open</td>
<td>【可选】是否自动打开TOC(默认为设置中toc的auto_open配置)</td>
</tr>
<tr>
<td>copyright</td>
<td>【可选】显示文章版权模块(默认为设置中post_copyright的enable配置)</td>
</tr>
<tr>
<td>mathjax</td>
<td>【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</td>
</tr>
<tr>
<td>katex</td>
<td>【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</td>
</tr>
<tr>
<td>aplayer</td>
<td>【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</td>
</tr>
<tr>
<td>highlight_shrink</td>
<td>【可选】配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置)</td>
</tr>
<tr>
<td>comments</td>
<td>【可选】显示文章评论模块(默认 true)</td>
</tr>
</tbody>
</table>
<p>另一种常见表格样式：</p>
<div alt="three-table"> <!--alt还可取值为"notitle-table"，一种无表头的小型表格-->
<table>
  <tr>
    <th alt="left">标题1</th>
    <th alt="center">标题2</th>
    <th alt="right">标题3</th>
  </tr>
  <tr>
    <td alt="left">居左：alt="left"</td>
    <td alt="center">居中：alt="center"</td>
    <td alt="right">居右：alt="right"</td>
  </tr>
  <tr>
    <td alt="left">x</td>
    <td alt="center">y</td>
    <td alt="right">z</td>
  </tr>
</table>
</div>
<p><a href="#%E4%BA%8C%E7%BA%A7%E6%A0%87%E9%A2%98">跳转</a>至二级标题（锚点）</p>
<h1 id="上下标"><a class="markdownIt-Anchor" href="#上下标"></a> 上下标</h1>
<p>X<sup>2</sup>, H<sub>2</sub>O，下标如果是多个单词或字符并以空格分隔，需要对空格进行转义，即在空格前面加<code>\</code>，（X<sub>下标1 下标2</sub>）。要显示*特殊字符等，也是通过反斜杠转义</p>
<h1 id="双语"><a class="markdownIt-Anchor" href="#双语"></a> 双语</h1>
<ul>
<li>
<p><ruby>Base<rp> (</rp><rt>top</rt><rp>)</p>
</li>
<li>
<p></rp></ruby>、<ruby>佐天泪子<rp> (</rp><rt>xiān qún kuáng mó</rt><rp>) </rp></ruby></p>
</li>
<li>
<p><ruby>超電磁砲<rp> (</rp><rt>レールガン</rt><rp>) </rp></ruby></p>
</li>
</ul>
<h1 id="图片"><a class="markdownIt-Anchor" href="#图片"></a> 图片</h1>
<img src="https://cdn1.tianli0.top/gh/exploreMeta/cdn/img/banner/client.jpg" style="zoom: 67%;"/>
<p>Gallery 相册</p>
<div class="fj-gallery"><p><img src="https://cdn1.tianli0.top/gh/exploreMeta/cdn/img/banner/about.webp" alt="" /><br /><img src="https://cdn1.tianli0.top/gh/exploreMeta/cdn/img/banner/donate.webp" alt="" /></p>
          </div>
<h1 id="音乐"><a class="markdownIt-Anchor" href="#音乐"></a> 音乐</h1>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" src="//music.163.com/outchain/player?type=2&id=1342183925&auto=0"></iframe>
<h1 id="emoji表情"><a class="markdownIt-Anchor" href="#emoji表情"></a> Emoji表情</h1>
<p><a href="https://hub.xn--gzu630h.xn--kpry57d/SmallOyster/emoji">查询链接</a></p>
]]></content>
  </entry>
</search>
